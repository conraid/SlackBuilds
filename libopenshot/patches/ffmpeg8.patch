diff -Naupr a/src/FFmpegReader.cpp b/src/FFmpegReader.cpp
--- a/src/FFmpegReader.cpp	2025-12-16 06:34:48.000000000 +0100
+++ b/src/FFmpegReader.cpp	2025-12-16 13:04:09.846392321 +0100
@@ -566,8 +566,16 @@ void FFmpegReader::Open() {
 			AVStream* st = pFormatCtx->streams[i];
 			if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
 				// Only inspect the first video stream
+#if LIBAVFORMAT_VERSION_MAJOR >= 61
+				// FFmpeg 7.0+ usa la nuova API per side data
+				int nb_side_data = st->codecpar->nb_coded_side_data;
+				for (int j = 0; j < nb_side_data; j++) {
+					const AVPacketSideData *sd = &st->codecpar->coded_side_data[j];
+#else
+				// FFmpeg < 7.0 usa la vecchia API
 				for (int j = 0; j < st->nb_side_data; j++) {
 					AVPacketSideData *sd = &st->side_data[j];
+#endif
 
 					// Handle rotation metadata (unchanged)
 					if (sd->type == AV_PKT_DATA_DISPLAYMATRIX &&
diff -Naupr a/src/FFmpegWriter.cpp b/src/FFmpegWriter.cpp
--- a/src/FFmpegWriter.cpp	2025-12-16 06:34:48.000000000 +0100
+++ b/src/FFmpegWriter.cpp	2025-12-16 13:17:07.402249221 +0100
@@ -1500,7 +1500,7 @@ void FFmpegWriter::open_video(AVFormatCo
 		switch (video_codec_ctx->codec_id) {
 			case AV_CODEC_ID_H264:
 				video_codec_ctx->max_b_frames = 0;  // At least this GPU doesn't support b-frames
-				video_codec_ctx->profile = FF_PROFILE_H264_BASELINE | FF_PROFILE_H264_CONSTRAINED;
+				video_codec_ctx->profile = AV_PROFILE_H264_BASELINE | AV_PROFILE_H264_CONSTRAINED;
 				av_opt_set(video_codec_ctx->priv_data, "preset", "slow", 0);
 				av_opt_set(video_codec_ctx->priv_data, "tune", "zerolatency", 0);
 				av_opt_set(video_codec_ctx->priv_data, "vprofile", "baseline", AV_OPT_SEARCH_CHILDREN);
@@ -2368,21 +2368,17 @@ void FFmpegWriter::ResampleAudio(int sam
 void FFmpegWriter::AddSphericalMetadata(const std::string& projection, float yaw_deg, float pitch_deg, float roll_deg) {
 	if (!oc) return;
 	if (!info.has_video || !video_st) return;
-
 	// Allow movenc.c to write out the sv3d atom
 	oc->strict_std_compliance = FF_COMPLIANCE_UNOFFICIAL;
-
 #if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(57, 0, 0)
 	// Map the projection name to the enum (defaults to equirectangular)
 	int proj = av_spherical_from_name(projection.c_str());
 	if (proj < 0)
 		proj = AV_SPHERICAL_EQUIRECTANGULAR;
-
 	// Allocate the sideâ€data structure
 	size_t sd_size = 0;
 	AVSphericalMapping* map = av_spherical_alloc(&sd_size);
 	if (!map) return;
-
 	// Populate it
 	map->projection = static_cast<AVSphericalProjection>(proj);
 	// yaw/pitch/roll are 16.16 fixed point
@@ -2390,6 +2386,22 @@ void FFmpegWriter::AddSphericalMetadata(
 	map->pitch = static_cast<int32_t>(pitch_deg * (1 << 16));
 	map->roll  = static_cast<int32_t>(roll_deg  * (1 << 16));
 
-	av_stream_add_side_data(video_st, AV_PKT_DATA_SPHERICAL, reinterpret_cast<uint8_t*>(map), sd_size);
+#if LIBAVFORMAT_VERSION_MAJOR >= 61
+	// FFmpeg 7.0+: aggiungi side data al codec parameters
+	AVPacketSideData* side_data = av_packet_side_data_new(
+		&video_st->codecpar->coded_side_data,
+		&video_st->codecpar->nb_coded_side_data,
+		AV_PKT_DATA_SPHERICAL,
+		sd_size,
+		0
+	);
+	if (side_data) {
+		memcpy(side_data->data, map, sd_size);
+	}
+	av_free(map);
+#else
+    av_stream_add_side_data(video_st, AV_PKT_DATA_SPHERICAL, reinterpret_cast<uint8_t*>(map), sd_size);
+#endif
+
 #endif
 }
