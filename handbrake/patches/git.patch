diff -Naupr a/NEWS.markdown b/NEWS.markdown
--- a/NEWS.markdown	2025-02-20 19:37:15.000000000 +0100
+++ b/NEWS.markdown	2025-03-31 11:55:35.191885298 +0200
@@ -10,6 +10,49 @@ Download available from Microsoft:
 - [For x64 (AMD or Intel CPUs)](https://aka.ms/dotnet/8.0/windowsdesktop-runtime-win-x64.exe)
 - [For Arm64 (Qualcomm or other)](https://aka.ms/dotnet/8.0/windowsdesktop-runtime-win-arm64.exe)
 
+## HandBrake 1.10.0
+
+#### General
+
+- Added new "Social 10MB" presets
+- Improved metadata passthru, preserving additional metadata including:
+    - Creation date
+    - Cover art
+    - Location
+
+#### Command line interface
+
+- Added an option to disable Dolby Vision and HDR10+ passthru
+
+#### Subtitles
+
+- SubRip/UTF-8 subtitles are now passed through to MKV without conversion to SSA
+
+#### Third-party libraries
+
+- Updated libraries
+  - FFmpeg 7.1.1 (decoding and filters)
+  - HarfBuzz 10.4.0 (subtitles)
+  - nv-codec-headers 13.0.19.0 (Nvidia NVENC encoding)
+  - oneVPL 2.14.0 (Intel QSV video encoding/decoding)
+  - SVT-AV1 3.0.0 (AV1 video encoding)
+
+### Mac
+
+- Added a Metal accelerated Render Sub filter
+- Added a contextual menu to the presets popover
+- Reduced CPU usage when using VideoToolbox decoders and encoders
+
+### Windows
+
+- Added a new preference "Default Range Mode for titles". See Preferences -> Advanced (#6385)
+- Added a new preference to run a custom action when the queue completes. See Preferences -> When Done (#4851)
+- Added "{destination_folder}" as option on the "Encode Completed" "Send File To" option.
+- Updated Auto Naming Preferences to add "{angle}" as a filename generation option (#6086)
+- Minor Performance Optimisations for ARM64 devices running Windows
+- Minor UI improvements throughout the UI.
+- Various bug fixes and improvements (#6524, #6517, #6514, #6477, #6473, #6086)
+
 
 ## HandBrake 1.9.2
 
@@ -17,13 +60,14 @@ Download available from Microsoft:
 
 #### General
 
-- Allowed muxing NVENC AV1 and VCN AV1 WebM container
-- Fixed a crash that could happen when a source contains chapters with no titles (#6565)
-  
+- Allowed muxing NVENC AV1 and VCN AV1 in WebM container
+- Fixed a crash that could happen when a source contains chapters with no titles (#6632)
+
 ### Windows
 
 - Fixed and issue where the audio track name would not reset on source track change. (#6642)
 
+
 ## HandBrake 1.9.1
 
 ### All platforms
@@ -68,7 +112,7 @@ Download available from Microsoft:
 #### General
 
 - Added Intel QSV VVC (hardware) video decoder
-- Added an option to enable AV1 screen content coding(SCC) on Intel Lunar Lake QSV AV1 encoder
+- Added an option to enable AV1 screen content coding (SCC) on Intel Lunar Lake QSV AV1 encoder
 - Added support for lossless VP9 encoding
 - Added a preference to keep duplicated Blu-ray titles
 - Added support for Max Duration of Scan titles for disc based sources (#6304)
diff -Naupr a/contrib/cpuinfo/module.defs b/contrib/cpuinfo/module.defs
--- a/contrib/cpuinfo/module.defs	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/cpuinfo/module.defs	2025-03-31 11:55:35.192885280 +0200
@@ -0,0 +1,47 @@
+$(eval $(call import.MODULE.defs,CPUINFO,cpuinfo))
+$(eval $(call import.CONTRIB.defs,CPUINFO))
+
+CPUINFO.FETCH.url     = https://github.com/HandBrake/HandBrake-contribs/releases/download/contribs2/cpuinfo-b73ae6c.tar.gz
+CPUINFO.FETCH.sha256  = 589c9241d361667ef9a2f2ee68846795949331f13ed7acc86f5d3cc4b856b6a8
+
+CPUINFO.build_dir             = build
+CPUINFO.CONFIGURE.exe         = cmake
+CPUINFO.CONFIGURE.args.prefix = -DCMAKE_INSTALL_PREFIX="$(CPUINFO.CONFIGURE.prefix)"
+CPUINFO.CONFIGURE.deps        =
+CPUINFO.CONFIGURE.static      =
+CPUINFO.CONFIGURE.shared      = -DCPUINFO_LIBRARY_TYPE=static -DCPUINFO_BUILD_TOOLS=OFF -DCPUINFO_BUILD_UNIT_TESTS=OFF \
+                                -DCPUINFO_BUILD_MOCK_TESTS=OFF -DCPUINFO_BUILD_BENCHMARKS=OFF
+CPUINFO.CONFIGURE.extra       = -DCMAKE_INSTALL_LIBDIR=lib
+
+ifneq (none,$(CPUINFO.GCC.g))
+    CPUINFO.CONFIGURE.extra += -DCMAKE_BUILD_TYPE=Debug
+else
+    CPUINFO.CONFIGURE.extra += -DCMAKE_BUILD_TYPE=Release
+endif
+
+ifeq (darwin,$(HOST.system))
+    CPUINFO.CONFIGURE.extra += -DCMAKE_SYSTEM_PROCESSOR=$(HOST.machine)
+    CPUINFO.CONFIGURE.extra += -DCMAKE_OSX_ARCHITECTURES=$(HOST.machine)
+endif
+
+ifeq (1,$(HOST.cross))
+    ifeq (mingw,$(HOST.system))
+        CPUINFO.CONFIGURE.extra += -DWIN32=ON -DMINGW=ON
+        CPUINFO.CONFIGURE.extra += -DCMAKE_SYSTEM_NAME=Windows
+        CPUINFO.CONFIGURE.extra += -DCMAKE_SYSTEM_PROCESSOR=$(HOST.machine)
+        CPUINFO.CONFIGURE.extra += -DCMAKE_C_COMPILER=$(CPUINFO.GCC.gcc)
+        CPUINFO.CONFIGURE.extra += -DCMAKE_CXX_COMPILER=$(CPUINFO.GCC.gxx)
+        CPUINFO.CONFIGURE.extra += -DCMAKE_RC_COMPILER=$(HOST.cross.prefix)windres
+        CPUINFO.CONFIGURE.args.host  = -DCMAKE_HOST_SYSTEM="$(CPUINFO.CONFIGURE.host)"
+    else ifeq ($(HOST.system),darwin)
+        CPUINFO.CONFIGURE.args.host  = -DCMAKE_HOST_SYSTEM="$(CPUINFO.CONFIGURE.host)"
+    else
+        CPUINFO.CONFIGURE.args.host  = -DCMAKE_SYSTEM_NAME="$(CPUINFO.CONFIGURE.host)"
+    endif
+    CPUINFO.CONFIGURE.args.build = -DCMAKE_HOST_SYSTEM="$(CPUINFO.CONFIGURE.build)"
+else
+    CPUINFO.CONFIGURE.args.host  = -DCMAKE_HOST_SYSTEM="$(CPUINFO.CONFIGURE.host)"
+endif
+
+## find CMakeLists.txt
+CPUINFO.CONFIGURE.extra += "$(call fn.ABSOLUTE,$(CPUINFO.EXTRACT.dir/))"
diff -Naupr a/contrib/cpuinfo/module.rules b/contrib/cpuinfo/module.rules
--- a/contrib/cpuinfo/module.rules	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/cpuinfo/module.rules	2025-03-31 11:55:35.192885280 +0200
@@ -0,0 +1,2 @@
+$(eval $(call import.MODULE.rules,CPUINFO))
+$(eval $(call import.CONTRIB.rules,CPUINFO))
diff -Naupr a/contrib/ffmpeg/A18-Revert-avcodec-amfenc-GPU-driver-version-check.patch b/contrib/ffmpeg/A18-Revert-avcodec-amfenc-GPU-driver-version-check.patch
--- a/contrib/ffmpeg/A18-Revert-avcodec-amfenc-GPU-driver-version-check.patch	2025-02-20 19:37:15.000000000 +0100
+++ b/contrib/ffmpeg/A18-Revert-avcodec-amfenc-GPU-driver-version-check.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-From 9d5ef6ed5f21ccfb746667106fa1df3fdeef1a80 Mon Sep 17 00:00:00 2001
-From: Damiano Galassi <damiog@gmail.com>
-Date: Sat, 19 Oct 2024 09:50:44 +0200
-Subject: [PATCH] Revert "avcodec/amfenc: GPU driver version check"
-
-This reverts commit eda3fc60534c4a30f49c930611d4130427d08ff1.
-
-There is hardware with HEVC 10-bit encoders that has no updated drivers yet.
----
- libavcodec/amfenc.c | 4 ----
- 1 file changed, 4 deletions(-)
-
-diff --git a/libavcodec/amfenc.c b/libavcodec/amfenc.c
-index a83f5b2013..95fce9ac96 100644
---- a/libavcodec/amfenc.c
-+++ b/libavcodec/amfenc.c
-@@ -415,10 +415,6 @@ static int amf_init_encoder(AVCodecContext *avctx)
-     else
-         pix_fmt = avctx->pix_fmt;
- 
--    if (pix_fmt == AV_PIX_FMT_P010) {
--        AMF_RETURN_IF_FALSE(ctx, ctx->version >= AMF_MAKE_FULL_VERSION(1, 4, 32, 0), AVERROR_UNKNOWN, "10-bit encoder is not supported by AMD GPU drivers versions lower than 23.30.\n");
--    }
--
-     ctx->format = amf_av_to_amf_format(pix_fmt);
-     AMF_RETURN_IF_FALSE(ctx, ctx->format != AMF_SURFACE_UNKNOWN, AVERROR(EINVAL),
-                         "Format %s is not supported\n", av_get_pix_fmt_name(pix_fmt));
--- 
-2.39.5 (Apple Git-154)
-
diff -Naupr a/contrib/ffmpeg/A18-libavcodec-qsvenc-update-has_b_frames-value.patch b/contrib/ffmpeg/A18-libavcodec-qsvenc-update-has_b_frames-value.patch
--- a/contrib/ffmpeg/A18-libavcodec-qsvenc-update-has_b_frames-value.patch	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/ffmpeg/A18-libavcodec-qsvenc-update-has_b_frames-value.patch	2025-03-31 11:55:35.193885263 +0200
@@ -0,0 +1,31 @@
+From 95676fcc5c7141124a10bab0498110aed88680ce Mon Sep 17 00:00:00 2001
+From: galinart <artem.galin@intel.com>
+Date: Thu, 17 Oct 2024 16:17:36 +0100
+Subject: [PATCH] libavcodec/qsvenc.c: update has_b_frames value after
+ initialization of encoder
+
+---
+ libavcodec/qsvenc.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/libavcodec/qsvenc.c b/libavcodec/qsvenc.c
+index 8200a14..c2bb5e5 100644
+--- a/libavcodec/qsvenc.c
++++ b/libavcodec/qsvenc.c
+@@ -1842,6 +1842,13 @@ int ff_qsv_enc_init(AVCodecContext *avctx, QSVEncContext *q)
+         return ret;
+     }
+ 
++    // Update AVCodecContext with actual encoding parameters
++    mfxInfoMFX *info = &q->param.mfx;
++    avctx->has_b_frames = 0;
++    if (info->GopRefDist > 1) {
++        avctx->has_b_frames = info->GopRefDist - 1;
++    }
++
+     q->avctx = avctx;
+ 
+     return 0;
+-- 
+2.25.1
+
diff -Naupr a/contrib/ffmpeg/A19-lavc-pgssubdec-Add-graphic-plane-and-cropping.patch b/contrib/ffmpeg/A19-lavc-pgssubdec-Add-graphic-plane-and-cropping.patch
--- a/contrib/ffmpeg/A19-lavc-pgssubdec-Add-graphic-plane-and-cropping.patch	2025-02-20 19:37:15.000000000 +0100
+++ b/contrib/ffmpeg/A19-lavc-pgssubdec-Add-graphic-plane-and-cropping.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,793 +0,0 @@
-From 2a2fdb2c75d74e37840597cf88578d43ab2f5f70 Mon Sep 17 00:00:00 2001
-From: cubicibo <55701024+cubicibo@users.noreply.github.com>
-Date: Thu, 22 Aug 2024 22:57:54 +0200
-Subject: [PATCH] lavc/pgssubdec: Add graphic plane and cropping.
-
----
- libavcodec/pgssubdec.c | 554 ++++++++++++++++++++++++++---------------
- 1 file changed, 353 insertions(+), 201 deletions(-)
-
-diff --git a/libavcodec/pgssubdec.c b/libavcodec/pgssubdec.c
-index 5f76f12615..973a264105 100644
---- a/libavcodec/pgssubdec.c
-+++ b/libavcodec/pgssubdec.c
-@@ -34,9 +34,11 @@
- #include "libavutil/opt.h"
- 
- #define RGBA(r,g,b,a) (((unsigned)(a) << 24) | ((r) << 16) | ((g) << 8) | (b))
--#define MAX_EPOCH_PALETTES 8   // Max 8 allowed per PGS epoch
--#define MAX_EPOCH_OBJECTS  64  // Max 64 allowed per PGS epoch
--#define MAX_OBJECT_REFS    2   // Max objects per display set
-+#define MAX_EPOCH_PALETTES 8    // Max 8 allowed per PGS epoch
-+#define MAX_EPOCH_OBJECTS  64   // Max 64 allowed per PGS epoch
-+#define MAX_OBJECT_REFS    2    // Max objects per display set
-+#define MAX_OBJECT_WH      4096 // Max object width/height
-+
- 
- enum SegmentType {
-     PALETTE_SEGMENT      = 0x14,
-@@ -47,57 +49,80 @@ enum SegmentType {
- };
- 
- typedef struct PGSSubObjectRef {
--    int     id;
--    int     window_id;
--    uint8_t composition_flag;
--    int     x;
--    int     y;
--    int     crop_x;
--    int     crop_y;
--    int     crop_w;
--    int     crop_h;
-+    uint16_t id;
-+    uint8_t  window_id;
-+    uint8_t  composition_flag;
-+    uint16_t x;
-+    uint16_t y;
-+    uint16_t crop_x;
-+    uint16_t crop_y;
-+    uint16_t crop_w;
-+    uint16_t crop_h;
- } PGSSubObjectRef;
- 
- typedef struct PGSSubPresentation {
--    int id_number;
--    int palette_id;
--    int object_count;
-+    uint8_t         palette_flag;
-+    uint8_t         palette_id;
-+    uint8_t         object_count;
-     PGSSubObjectRef objects[MAX_OBJECT_REFS];
--    int64_t pts;
-+    int64_t         pts;
- } PGSSubPresentation;
- 
- typedef struct PGSSubObject {
--    int          id;
--    int          w;
--    int          h;
--    uint8_t      *rle;
--    unsigned int rle_buffer_size, rle_data_len;
--    unsigned int rle_remaining_len;
-+    uint16_t  id;
-+    uint16_t  w;
-+    uint16_t  h;
-+    uint8_t   *rle;
-+    uint8_t   *bitmap;
-+    uint32_t  rle_buffer_size;
-+    uint32_t  rle_data_len;
-+    uint32_t  rle_remaining_len;
-+    uint32_t  bitmap_buffer_size;
-+    uint32_t  bitmap_size;
- } PGSSubObject;
- 
- typedef struct PGSSubObjects {
--    int          count;
-+    uint8_t      count;
-     PGSSubObject object[MAX_EPOCH_OBJECTS];
- } PGSSubObjects;
- 
- typedef struct PGSSubPalette {
--    int         id;
--    uint32_t    clut[256];
-+    uint8_t     id;
-+    uint32_t    clut[AVPALETTE_COUNT];
- } PGSSubPalette;
- 
- typedef struct PGSSubPalettes {
--    int           count;
-+    uint8_t       count;
-     PGSSubPalette palette[MAX_EPOCH_PALETTES];
- } PGSSubPalettes;
- 
-+typedef struct PGSGraphicPlane {
-+   uint8_t        count;
-+   uint8_t        writable;
-+   AVSubtitleRect visible_rect[MAX_OBJECT_REFS];
-+} PGSGraphicPlane;
-+
- typedef struct PGSSubContext {
-     AVClass *class;
-     PGSSubPresentation presentation;
-     PGSSubPalettes     palettes;
-     PGSSubObjects      objects;
-+    PGSGraphicPlane    plane;
-     int forced_subs_only;
- } PGSSubContext;
- 
-+static void clear_graphic_plane(PGSSubContext *ctx)
-+{
-+    int i;
-+
-+    for (i = 0; i < ctx->plane.count; i++) {
-+       av_freep(&ctx->plane.visible_rect[i].data[0]);
-+       memset(&ctx->plane.visible_rect[i], 0, sizeof(ctx->plane.visible_rect[i]));
-+    }
-+    ctx->plane.writable = 0;
-+    ctx->plane.count = 0;
-+}
-+
- static void flush_cache(AVCodecContext *avctx)
- {
-     PGSSubContext *ctx = avctx->priv_data;
-@@ -105,8 +130,11 @@ static void flush_cache(AVCodecContext *avctx)
- 
-     for (i = 0; i < ctx->objects.count; i++) {
-         av_freep(&ctx->objects.object[i].rle);
--        ctx->objects.object[i].rle_buffer_size  = 0;
-+        ctx->objects.object[i].rle_buffer_size    = 0;
-         ctx->objects.object[i].rle_remaining_len  = 0;
-+        av_freep(&ctx->objects.object[i].bitmap);
-+        ctx->objects.object[i].bitmap_buffer_size = 0;
-+        ctx->objects.object[i].bitmap_size        = 0;
-     }
-     ctx->objects.count = 0;
-     ctx->palettes.count = 0;
-@@ -143,6 +171,7 @@ static av_cold int init_decoder(AVCodecContext *avctx)
- 
- static av_cold int close_decoder(AVCodecContext *avctx)
- {
-+    clear_graphic_plane((PGSSubContext *)avctx->priv_data);
-     flush_cache(avctx);
- 
-     return 0;
-@@ -158,48 +187,51 @@ static av_cold int close_decoder(AVCodecContext *avctx)
-  * @param buf pointer to the RLE data to process
-  * @param buf_size size of the RLE data to process
-  */
--static int decode_rle(AVCodecContext *avctx, AVSubtitleRect *rect,
--                      const uint8_t *buf, unsigned int buf_size)
-+static int decode_object_rle(AVCodecContext *avctx, PGSSubObject *object)
- {
--    const uint8_t *rle_bitmap_end;
-+    const uint8_t *rle_buf;
-+    const uint8_t *rle_end;
-     int pixel_count, line_count;
-+    rle_buf = object->rle;
-+    rle_end = object->rle + object->rle_data_len;
- 
--    rle_bitmap_end = buf + buf_size;
-+    object->bitmap_size = object->w * object->h;
-+    av_fast_padded_malloc(&object->bitmap, &object->bitmap_buffer_size,
-+                          object->bitmap_size);
- 
--    rect->data[0] = av_malloc_array(rect->w, rect->h);
--
--    if (!rect->data[0])
-+    if (!object->bitmap)
-         return AVERROR(ENOMEM);
- 
-     pixel_count = 0;
-     line_count  = 0;
- 
--    while (buf < rle_bitmap_end && line_count < rect->h) {
-+    while (rle_buf < rle_end && line_count < object->h) {
-         uint8_t flags, color;
-         int run;
- 
--        color = bytestream_get_byte(&buf);
-+        color = bytestream_get_byte(&rle_buf);
-         run   = 1;
- 
-         if (color == 0x00) {
--            flags = bytestream_get_byte(&buf);
-+            flags = bytestream_get_byte(&rle_buf);
-             run   = flags & 0x3f;
-             if (flags & 0x40)
--                run = (run << 8) + bytestream_get_byte(&buf);
--            color = flags & 0x80 ? bytestream_get_byte(&buf) : 0;
-+                run = (run << 8) + bytestream_get_byte(&rle_buf);
-+            color = flags & 0x80 ? bytestream_get_byte(&rle_buf) : 0;
-         }
- 
--        if (run > 0 && pixel_count + run <= rect->w * rect->h) {
--            memset(rect->data[0] + pixel_count, color, run);
-+        if (run > 0 && pixel_count + run <= object->w * object->h) {
-+            memset(object->bitmap + pixel_count, color, run);
-             pixel_count += run;
-         } else if (!run) {
-             /*
-              * New Line. Check if correct pixels decoded, if not display warning
-              * and adjust bitmap pointer to correct new line position.
-              */
--            if (pixel_count % rect->w > 0) {
--                av_log(avctx, AV_LOG_ERROR, "Decoded %d pixels, when line should be %d pixels\n",
--                       pixel_count % rect->w, rect->w);
-+            if (pixel_count % object->w > 0) {
-+                av_log(avctx, AV_LOG_ERROR,
-+                       "Decoded %d pixels, when object line should be %d pixels\n",
-+                       pixel_count % object->w, object->w);
-                 if (avctx->err_recognition & AV_EF_EXPLODE) {
-                     return AVERROR_INVALIDDATA;
-                 }
-@@ -208,13 +240,11 @@ static int decode_rle(AVCodecContext *avctx, AVSubtitleRect *rect,
-         }
-     }
- 
--    if (pixel_count < rect->w * rect->h) {
--        av_log(avctx, AV_LOG_ERROR, "Insufficient RLE data for subtitle\n");
-+    if (pixel_count < object->w * object->h) {
-+        av_log(avctx, AV_LOG_ERROR, "Insufficient RLE data for object\n");
-         return AVERROR_INVALIDDATA;
-     }
--
--    ff_dlog(avctx, "Pixel Count = %d, Area = %d\n", pixel_count, rect->w * rect->h);
--
-+    ff_dlog(avctx, "Pixel Count = %d, Area = %d\n", pixel_count, object->w * object->h);
-     return 0;
- }
- 
-@@ -236,7 +266,7 @@ static int parse_object_segment(AVCodecContext *avctx,
- 
-     uint8_t sequence_desc;
-     unsigned int rle_bitmap_len, width, height;
--    int id;
-+    int id, ret;
- 
-     if (buf_size <= 4)
-         return AVERROR_INVALIDDATA;
-@@ -259,57 +289,71 @@ static int parse_object_segment(AVCodecContext *avctx,
-     /* Read the Sequence Description to determine if start of RLE data or appended to previous RLE */
-     sequence_desc = bytestream_get_byte(&buf);
- 
--    if (!(sequence_desc & 0x80)) {
--        /* Additional RLE data */
--        if (buf_size > object->rle_remaining_len)
-+    /* First in sequence object definition segment */
-+    if (sequence_desc & 0x80) {
-+        if (buf_size <= 7)
-             return AVERROR_INVALIDDATA;
-+        buf_size -= 7;
- 
--        memcpy(object->rle + object->rle_data_len, buf, buf_size);
--        object->rle_data_len += buf_size;
--        object->rle_remaining_len -= buf_size;
--
--        return 0;
--    }
--
--    if (buf_size <= 7)
--        return AVERROR_INVALIDDATA;
--    buf_size -= 7;
-+        /* Decode rle bitmap length, stored size includes width/height data */
-+        rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;
- 
--    /* Decode rle bitmap length, stored size includes width/height data */
--    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;
-+        if (buf_size > rle_bitmap_len) {
-+            av_log(avctx, AV_LOG_ERROR,
-+                   "Buffer dimension %d larger than the expected RLE data %d\n",
-+                   buf_size, rle_bitmap_len);
-+            return AVERROR_INVALIDDATA;
-+        }
- 
--    if (buf_size > rle_bitmap_len) {
--        av_log(avctx, AV_LOG_ERROR,
--               "Buffer dimension %d larger than the expected RLE data %d\n",
--               buf_size, rle_bitmap_len);
--        return AVERROR_INVALIDDATA;
--    }
-+        /* Get bitmap dimensions from data */
-+        width  = bytestream_get_be16(&buf);
-+        height = bytestream_get_be16(&buf);
- 
--    /* Get bitmap dimensions from data */
--    width  = bytestream_get_be16(&buf);
--    height = bytestream_get_be16(&buf);
-+        /* Make sure the bitmap is not too large */
-+        if (MAX_OBJECT_WH < width || MAX_OBJECT_WH < height || !width || !height) {
-+            av_log(avctx, AV_LOG_ERROR, "Bitmap dimensions (%dx%d) invalid.\n", width, height);
-+            return AVERROR_INVALIDDATA;
-+        }
- 
--    /* Make sure the bitmap is not too large */
--    if (avctx->width < width || avctx->height < height || !width || !height) {
--        av_log(avctx, AV_LOG_ERROR, "Bitmap dimensions (%dx%d) invalid.\n", width, height);
--        return AVERROR_INVALIDDATA;
--    }
-+        object->rle_data_len = 0;
-+        object->w = width;
-+        object->h = height;
-+        /* Dimensions against video are checked at decode after cropping. */
-+        av_fast_padded_malloc(&object->rle, &object->rle_buffer_size, rle_bitmap_len);
- 
--    object->w = width;
--    object->h = height;
-+        if (!object->rle) {
-+            object->rle_remaining_len = 0;
-+            return AVERROR(ENOMEM);
-+        }
- 
--    av_fast_padded_malloc(&object->rle, &object->rle_buffer_size, rle_bitmap_len);
-+        memcpy(object->rle, buf, buf_size);
-+        object->rle_remaining_len = rle_bitmap_len;
-+    } else {
-+        /* Additional RLE data */
-+        if (buf_size > object->rle_remaining_len)
-+            return AVERROR_INVALIDDATA;
- 
--    if (!object->rle) {
--        object->rle_data_len = 0;
--        object->rle_remaining_len = 0;
--        return AVERROR(ENOMEM);
-+        memcpy(object->rle + object->rle_data_len, buf, buf_size);
-+    }
-+    object->rle_data_len += buf_size;
-+    object->rle_remaining_len -= buf_size;
-+
-+    /* Last in sequence object definition (can be both first and last) */
-+    if (sequence_desc & 0x40) {
-+        /* Attempt decoding if data is valid */
-+        if (0 == object->rle_remaining_len) {
-+            ret = decode_object_rle(avctx, object);
-+            if (ret < 0 && (avctx->err_recognition & AV_EF_EXPLODE || ret == AVERROR(ENOMEM))) {
-+                return ret;
-+            }
-+        } else {
-+            av_log(avctx, AV_LOG_ERROR,
-+                "RLE data length %u is %u bytes shorter than expected\n",
-+                object->rle_data_len, object->rle_remaining_len);
-+            if (avctx->err_recognition & AV_EF_EXPLODE)
-+                return AVERROR_INVALIDDATA;
-+        }
-     }
--
--    memcpy(object->rle, buf, buf_size);
--    object->rle_data_len = buf_size;
--    object->rle_remaining_len = rle_bitmap_len - buf_size;
--
-     return 0;
- }
- 
-@@ -317,7 +361,7 @@ static int parse_object_segment(AVCodecContext *avctx,
-  * Parse the palette segment packet.
-  *
-  * The palette segment contains details of the palette,
-- * a maximum of 256 colors can be defined.
-+ * a maximum of 256 colors (AVPALETTE_COUNT) can be defined.
-  *
-  * @param avctx contains the current codec context
-  * @param buf pointer to the packet to process
-@@ -390,13 +434,17 @@ static int parse_presentation_segment(AVCodecContext *avctx,
-                                       int64_t pts)
- {
-     PGSSubContext *ctx = avctx->priv_data;
--    int i, state, ret;
-+    int ret;
-+    uint8_t i, state;
-     const uint8_t *buf_end = buf + buf_size;
- 
-     // Video descriptor
-     int w = bytestream_get_be16(&buf);
-     int h = bytestream_get_be16(&buf);
- 
-+    // On a new display set, reset writability of the graphic plane
-+    ctx->plane.writable = 0;
-+
-     ctx->presentation.pts = pts;
- 
-     ff_dlog(avctx, "Video Dimensions %dx%d\n",
-@@ -405,88 +453,121 @@ static int parse_presentation_segment(AVCodecContext *avctx,
-     if (ret < 0)
-         return ret;
- 
--    /* Skip 1 bytes of unknown, frame rate */
--    buf++;
-+    /* Skip 3 bytes: framerate (1), presentation id number (2) */
-+    buf+=3;
- 
--    // Composition descriptor
--    ctx->presentation.id_number = bytestream_get_be16(&buf);
-     /*
--     * state is a 2 bit field that defines pgs epoch boundaries
-+     * State is a 2 bit field that defines pgs epoch boundaries
-      * 00 - Normal, previously defined objects and palettes are still valid
-      * 01 - Acquisition point, previous objects and palettes can be released
-      * 10 - Epoch start, previous objects and palettes can be released
-      * 11 - Epoch continue, previous objects and palettes can be released
-      *
--     * reserved 6 bits discarded
-+     * Reserved 6 bits discarded
-      */
-     state = bytestream_get_byte(&buf) >> 6;
-     if (state != 0) {
-+        /* Epoch start always wipes the graphic plane. Epoch continue does only if
-+         * playback is not seamless, which should not happen with a proper stream.
-+         */
-+        if (0b10 == state)
-+            clear_graphic_plane((PGSSubContext *)avctx->priv_data);
-         flush_cache(avctx);
-     }
- 
-+    /* Reserved 7 bits discarded. */
-+    ctx->presentation.palette_flag = bytestream_get_byte(&buf) & 0x80;
-+    ctx->presentation.palette_id = bytestream_get_byte(&buf);
-+
-     /*
--     * skip palette_update_flag (0x80),
-+     * On palette update, don't parse the compositions references,
-+     * just evaluate the existing graphic plane with the new palette.
-      */
--    buf += 1;
--    ctx->presentation.palette_id = bytestream_get_byte(&buf);
--    ctx->presentation.object_count = bytestream_get_byte(&buf);
--    if (ctx->presentation.object_count > MAX_OBJECT_REFS) {
--        av_log(avctx, AV_LOG_ERROR,
--               "Invalid number of presentation objects %d\n",
--               ctx->presentation.object_count);
--        ctx->presentation.object_count = 2;
--        if (avctx->err_recognition & AV_EF_EXPLODE) {
--            return AVERROR_INVALIDDATA;
-+    if (!ctx->presentation.palette_flag) {
-+        ctx->presentation.object_count = bytestream_get_byte(&buf);
-+        if (ctx->presentation.object_count > MAX_OBJECT_REFS) {
-+            av_log(avctx, AV_LOG_ERROR,
-+                   "Invalid number of presentation objects %d\n",
-+                   ctx->presentation.object_count);
-+            ctx->presentation.object_count = 2;
-+            if (avctx->err_recognition & AV_EF_EXPLODE) {
-+                return AVERROR_INVALIDDATA;
-+            }
-         }
--    }
- 
-+        for (i = 0; i < ctx->presentation.object_count; i++) {
-+            PGSSubObjectRef *const object = &ctx->presentation.objects[i];
- 
--    for (i = 0; i < ctx->presentation.object_count; i++)
--    {
--        PGSSubObjectRef *const object = &ctx->presentation.objects[i];
-+            if (buf_end - buf < 8) {
-+                av_log(avctx, AV_LOG_ERROR, "Insufficent space for object\n");
-+                ctx->presentation.object_count = i;
-+                return AVERROR_INVALIDDATA;
-+            }
- 
--        if (buf_end - buf < 8) {
--            av_log(avctx, AV_LOG_ERROR, "Insufficent space for object\n");
--            ctx->presentation.object_count = i;
--            return AVERROR_INVALIDDATA;
--        }
-+            object->id               = bytestream_get_be16(&buf);
-+            object->window_id        = bytestream_get_byte(&buf);
-+            object->composition_flag = bytestream_get_byte(&buf);
- 
--        object->id               = bytestream_get_be16(&buf);
--        object->window_id        = bytestream_get_byte(&buf);
--        object->composition_flag = bytestream_get_byte(&buf);
-+            object->x = bytestream_get_be16(&buf);
-+            object->y = bytestream_get_be16(&buf);
- 
--        object->x = bytestream_get_be16(&buf);
--        object->y = bytestream_get_be16(&buf);
-+            // If cropping
-+            if (object->composition_flag & 0x80) {
-+                object->crop_x = bytestream_get_be16(&buf);
-+                object->crop_y = bytestream_get_be16(&buf);
-+                object->crop_w = bytestream_get_be16(&buf);
-+                object->crop_h = bytestream_get_be16(&buf);
-+            }
- 
--        // If cropping
--        if (object->composition_flag & 0x80) {
--            object->crop_x = bytestream_get_be16(&buf);
--            object->crop_y = bytestream_get_be16(&buf);
--            object->crop_w = bytestream_get_be16(&buf);
--            object->crop_h = bytestream_get_be16(&buf);
-+            /* Placement is checked at decode after cropping. */
-+            ff_dlog(avctx, "Subtitle Placement x=%d, y=%d\n",
-+                    object->x, object->y);
-         }
-+    }
-+    return 0;
-+}
- 
--        ff_dlog(avctx, "Subtitle Placement x=%d, y=%d\n",
--                object->x, object->y);
-+/**
-+ * Parse the window segment packet.
-+ *
-+ * The window segment instructs the decoder to redraw the graphic plane
-+ * with the composition references provided in the presentation segment
-+ *
-+ * @param avctx contains the current codec context
-+ */
-+static int parse_window_segment(AVCodecContext *avctx, const uint8_t *buf,
-+                                int buf_size)
-+{
-+    PGSSubContext *ctx = (PGSSubContext *)avctx->priv_data;
- 
--        if (object->x > avctx->width || object->y > avctx->height) {
--            av_log(avctx, AV_LOG_ERROR, "Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\n",
--                   object->x, object->y,
--                    avctx->width, avctx->height);
--            object->y = object->x = 0;
--            if (avctx->err_recognition & AV_EF_EXPLODE) {
--                return AVERROR_INVALIDDATA;
--            }
--        }
-+    // 1 byte: number of windows defined
-+    if (bytestream_get_byte(&buf) > MAX_OBJECT_REFS) {
-+        av_log(avctx, AV_LOG_ERROR, "Too many windows defined.\n");
-+        return AVERROR_INVALIDDATA;
-     }
- 
-+    /* TODO: mask objects with windows when transfering to the graphic plane
-+     * Window Segment Structure
-+     *     {
-+     *       1 byte : window id,
-+     *       2 bytes: X position of window,
-+     *       2 bytes: Y position of window,
-+     *       2 bytes: Width of window,
-+     *       2 bytes: Height of window.
-+     *     }
-+     */
-+    // Flush the graphic plane, it will be redrawn.
-+    clear_graphic_plane(ctx);
-+    ctx->plane.writable = 1;
-+    ctx->plane.count = ctx->presentation.object_count;
-     return 0;
- }
- 
- /**
-  * Parse the display segment packet.
-  *
-- * The display segment controls the updating of the display.
-+ * The display segment closes the display set. The inferred data is used
-+ * to decide if the display should be updated.
-  *
-  * @param avctx contains the current codec context
-  * @param data pointer to the data pertaining the subtitle to display
-@@ -499,26 +580,33 @@ static int display_end_segment(AVCodecContext *avctx, AVSubtitle *sub,
-     PGSSubContext *ctx = avctx->priv_data;
-     int64_t pts;
-     PGSSubPalette *palette;
--    int i, ret;
-+    int i;
- 
-     pts = ctx->presentation.pts != AV_NOPTS_VALUE ? ctx->presentation.pts : sub->pts;
-     memset(sub, 0, sizeof(*sub));
-     sub->pts = pts;
-     ctx->presentation.pts = AV_NOPTS_VALUE;
--    sub->start_display_time = 0;
-     // There is no explicit end time for PGS subtitles.  The end time
-     // is defined by the start of the next sub which may contain no
-     // objects (i.e. clears the previous sub)
-     sub->end_display_time   = UINT32_MAX;
--    sub->format             = 0;
- 
--    // Blank if last object_count was 0.
--    if (!ctx->presentation.object_count)
-+    // Object count is zero only on an epoch start with no WDS
-+    // or the last DS with a WDS had no presentation object.
-+    if (!ctx->plane.count) {
-         return 1;
--    sub->rects = av_calloc(ctx->presentation.object_count, sizeof(*sub->rects));
--    if (!sub->rects) {
--        return AVERROR(ENOMEM);
-     }
-+
-+    if (!ctx->presentation.palette_flag && !ctx->plane.writable) {
-+        // This display set does not perform a display update
-+        // E.g. it only defines new objects or palettes for future usage.
-+        return 0;
-+    }
-+
-+    sub->rects = av_calloc(ctx->plane.count, sizeof(*sub->rects));
-+    if (!sub->rects)
-+        return AVERROR(ENOMEM);
-+
-     palette = find_palette(ctx->presentation.palette_id, &ctx->palettes);
-     if (!palette) {
-         // Missing palette.  Should only happen with damaged streams.
-@@ -527,57 +615,128 @@ static int display_end_segment(AVCodecContext *avctx, AVSubtitle *sub,
-         avsubtitle_free(sub);
-         return AVERROR_INVALIDDATA;
-     }
--    for (i = 0; i < ctx->presentation.object_count; i++) {
--        AVSubtitleRect *const rect = av_mallocz(sizeof(*rect));
--        PGSSubObject *object;
- 
--        if (!rect)
--            return AVERROR(ENOMEM);
--        sub->rects[sub->num_rects++] = rect;
--        rect->type = SUBTITLE_BITMAP;
--
--        /* Process bitmap */
--        object = find_object(ctx->presentation.objects[i].id, &ctx->objects);
--        if (!object) {
--            // Missing object.  Should only happen with damaged streams.
--            av_log(avctx, AV_LOG_ERROR, "Invalid object id %d\n",
--                   ctx->presentation.objects[i].id);
--            if (avctx->err_recognition & AV_EF_EXPLODE)
--                return AVERROR_INVALIDDATA;
--            // Leaves rect empty with 0 width and height.
--            continue;
--        }
--        if (ctx->presentation.objects[i].composition_flag & 0x40)
--            rect->flags |= AV_SUBTITLE_FLAG_FORCED;
-+    for (i = 0; i < ctx->plane.count; i++) {
-+        const PGSSubObjectRef *sub_object = &ctx->presentation.objects[i];
-+        AVSubtitleRect *const gp_rect = &ctx->plane.visible_rect[i];
-+        AVSubtitleRect *rect;
-+        gp_rect->type = SUBTITLE_BITMAP;
-+
-+        // Compose the graphic plane if a window segment has been provided
-+        if (ctx->plane.writable) {
-+            PGSSubObject *object;
-+
-+            // Process bitmap
-+            object = find_object(sub_object->id, &ctx->objects);
-+            if (!object) {
-+                // Missing object.  Should only happen with damaged streams.
-+                av_log(avctx, AV_LOG_ERROR, "Invalid object id %d\n", sub_object->id);
-+                if (avctx->err_recognition & AV_EF_EXPLODE)
-+                    return AVERROR_INVALIDDATA;
-+                // Leaves rect empty with 0 width and height.
-+                continue;
-+            }
-+            if (sub_object->composition_flag & 0x40)
-+                gp_rect->flags |= AV_SUBTITLE_FLAG_FORCED;
-+
-+            gp_rect->x    = sub_object->x;
-+            gp_rect->y    = sub_object->y;
-+
-+            if (object->rle) {
-+                int out_of_picture = 0;
-+                gp_rect->w = object->w;
-+                gp_rect->h = object->h;
-+
-+                gp_rect->linesize[0] = object->w;
-+
-+                // Check for cropping.
-+                if (sub_object->composition_flag & 0x80) {
-+                    int out_of_object = 0;
-+
-+                    if (object->w < sub_object->crop_x + sub_object->crop_w)
-+                        out_of_object = 1;
-+                    if (object->h < sub_object->crop_y + sub_object->crop_h)
-+                        out_of_object = 1;
-+
-+                    if (out_of_object) {
-+                        av_log(avctx, AV_LOG_ERROR,
-+                               "Subtitle cropping values are out of object. "
-+                               "obj_w = %d, obj_h = %d, crop_x = %d, crop_y = %d, "
-+                               "crop_w = %d, crop_h = %d.\n",
-+                               object->w,
-+                               object->h,
-+                               sub_object->crop_x,
-+                               sub_object->crop_y,
-+                               sub_object->crop_w,
-+                               sub_object->crop_h);
-+                        if (avctx->err_recognition & AV_EF_EXPLODE)
-+                            return AVERROR_INVALIDDATA;
-+                    } else {
-+                        // Replace subtitle dimensions with cropping ones.
-+                        gp_rect->w = sub_object->crop_w;
-+                        gp_rect->h = sub_object->crop_h;
-+                        gp_rect->linesize[0] = sub_object->crop_w;
-+                    }
-+                }
-+
-+                /* Make sure the subtitle is not out of picture. */
-+                if (avctx->width < gp_rect->x + gp_rect->w || !gp_rect->w)
-+                    out_of_picture = 1;
-+                if (avctx->height < gp_rect->y + gp_rect->h || !gp_rect->h)
-+                    out_of_picture = 1;
-+                if (out_of_picture) {
-+                    av_log(avctx, AV_LOG_ERROR,
-+                           "Subtitle out of video bounds. "
-+                           "x = %d, y = %d, width = %d, height = %d.\n",
-+                           gp_rect->x, gp_rect->y, gp_rect->w, gp_rect->h);
-+                    if (avctx->err_recognition & AV_EF_EXPLODE)
-+                        return AVERROR_INVALIDDATA;
-+                    gp_rect->w = 0;
-+                    gp_rect->h = 0;
-+                    continue;
-+                }
- 
--        rect->x    = ctx->presentation.objects[i].x;
--        rect->y    = ctx->presentation.objects[i].y;
-+                if (!object->bitmap_size || object->rle_remaining_len) {
-+                    gp_rect->w = 0;
-+                    gp_rect->h = 0;
-+                    continue;
-+                }
- 
--        if (object->rle) {
--            rect->w    = object->w;
--            rect->h    = object->h;
-+                gp_rect->data[0] = av_malloc_array(gp_rect->w, gp_rect->h);
-+                if (!gp_rect->data[0])
-+                    return AVERROR(ENOMEM);
- 
--            rect->linesize[0] = object->w;
-+                if (sub_object->composition_flag & 0x80) {
-+                    /* Copy cropped bitmap. */
-+                    int y;
- 
--            if (object->rle_remaining_len) {
--                av_log(avctx, AV_LOG_ERROR, "RLE data length %u is %u bytes shorter than expected\n",
--                       object->rle_data_len, object->rle_remaining_len);
--                if (avctx->err_recognition & AV_EF_EXPLODE)
--                    return AVERROR_INVALIDDATA;
--            }
--            ret = decode_rle(avctx, rect, object->rle, object->rle_data_len);
--            if (ret < 0) {
--                if ((avctx->err_recognition & AV_EF_EXPLODE) ||
--                    ret == AVERROR(ENOMEM)) {
--                    return ret;
-+                    for (y = 0; y < sub_object->crop_h; y++) {
-+                        memcpy(&gp_rect->data[0][y * sub_object->crop_w],
-+                               &object->bitmap[(sub_object->crop_y + y) *
-+                               object->w + sub_object->crop_x],
-+                               sub_object->crop_w);
-+                    }
-+                }
-+                else {
-+                    /* copy full object */
-+                    memcpy(gp_rect->data[0], object->bitmap, object->bitmap_size);
-                 }
--                rect->w = 0;
--                rect->h = 0;
--                continue;
-             }
-         }
--        /* Allocate memory for colors */
--        rect->nb_colors = 256;
-+        // Export graphic plane content with latest palette
-+        rect = av_memdup(gp_rect, sizeof(*gp_rect));
-+        if (!rect)
-+            return AVERROR(ENOMEM);
-+
-+        sub->rects[sub->num_rects++] = rect;
-+        if (gp_rect->data[0]) {
-+            rect->data[0] = av_memdup(gp_rect->data[0], rect->w*rect->h);
-+            if (!rect->data[0])
-+                return AVERROR(ENOMEM);
-+        }
-+
-+        // Allocate memory for colors
-+        rect->nb_colors = AVPALETTE_COUNT;
-         rect->data[1]   = av_mallocz(AVPALETTE_SIZE);
-         if (!rect->data[1])
-             return AVERROR(ENOMEM);
-@@ -640,14 +799,7 @@ static int decode(AVCodecContext *avctx, AVSubtitle *sub,
-             ret = parse_presentation_segment(avctx, buf, segment_length, sub->pts);
-             break;
-         case WINDOW_SEGMENT:
--            /*
--             * Window Segment Structure (No new information provided):
--             *     2 bytes: Unknown,
--             *     2 bytes: X position of subtitle,
--             *     2 bytes: Y position of subtitle,
--             *     2 bytes: Width of subtitle,
--             *     2 bytes: Height of subtitle.
--             */
-+            ret = parse_window_segment(avctx, buf, segment_length);
-             break;
-         case DISPLAY_SEGMENT:
-             if (*got_sub_ptr) {
--- 
-2.32.0 (Apple Git-132)
-
diff -Naupr a/contrib/ffmpeg/A19-libavcodec-qsv-enable-av1-scc.patch b/contrib/ffmpeg/A19-libavcodec-qsv-enable-av1-scc.patch
--- a/contrib/ffmpeg/A19-libavcodec-qsv-enable-av1-scc.patch	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/ffmpeg/A19-libavcodec-qsv-enable-av1-scc.patch	2025-03-31 11:55:35.193885263 +0200
@@ -0,0 +1,144 @@
+From 71b77865d4955440106015bd08172b876abed1f5 Mon Sep 17 00:00:00 2001
+From: galinart <artem.galin@intel.com>
+Date: Tue, 12 Nov 2024 15:50:06 +0000
+Subject: [PATCH] qsv: enable av1 scc
+
+---
+ libavcodec/qsvenc.c     | 42 +++++++++++++++++++++++++++++++++++++++++
+ libavcodec/qsvenc.h     |  8 +++++++-
+ libavcodec/qsvenc_av1.c |  4 ++++
+ 3 files changed, 53 insertions(+), 1 deletion(-)
+
+diff --git a/libavcodec/qsvenc.c b/libavcodec/qsvenc.c
+index c2bb5e5..284b608 100644
+--- a/libavcodec/qsvenc.c
++++ b/libavcodec/qsvenc.c
+@@ -494,6 +494,9 @@ static void dump_video_av1_param(AVCodecContext *avctx, QSVEncContext *q,
+     mfxExtAV1BitstreamParam *av1_bs_param = (mfxExtAV1BitstreamParam *)coding_opts[1];
+     mfxExtCodingOption2 *co2 = (mfxExtCodingOption2*)coding_opts[2];
+     mfxExtCodingOption3 *co3 = (mfxExtCodingOption3*)coding_opts[3];
++#if QSV_HAVE_EXT_AV1_SCC
++    mfxExtAV1ScreenContentTools *scc = (mfxExtAV1ScreenContentTools*)coding_opts[4];
++#endif
+ 
+     av_log(avctx, AV_LOG_VERBOSE, "profile: %s; level: %"PRIu16"\n",
+            print_profile(avctx->codec_id, info->CodecProfile), info->CodecLevel);
+@@ -566,6 +569,13 @@ static void dump_video_av1_param(AVCodecContext *avctx, QSVEncContext *q,
+            print_threestate(av1_bs_param->WriteIVFHeaders));
+     av_log(avctx, AV_LOG_VERBOSE, "LowDelayBRC: %s\n", print_threestate(co3->LowDelayBRC));
+     av_log(avctx, AV_LOG_VERBOSE, "MaxFrameSize: %d;\n", co2->MaxFrameSize);
++#if QSV_HAVE_EXT_AV1_SCC
++    if (scc) {
++        av_log(avctx, AV_LOG_VERBOSE,
++               "Palette: %s; IntraBlockCopy: %s\n",
++               print_threestate(scc->Palette), print_threestate(scc->IntraBlockCopy));
++    }
++#endif
+ }
+ #endif
+ 
+@@ -1282,6 +1292,28 @@ static int init_video_param(AVCodecContext *avctx, QSVEncContext *q)
+     }
+ #endif
+ 
++#if QSV_HAVE_EXT_AV1_SCC
++    if (q->palette_mode || q->intrabc) {
++        if (QSV_RUNTIME_VERSION_ATLEAST(q->ver, 2, 13)) {
++            if (q->param.mfx.CodecId != MFX_CODEC_AV1) {
++                av_log(avctx, AV_LOG_ERROR, "Not supported encoder for Screen Content Tool Encode. "
++                                            "Supported: av1_qsv \n");
++                return AVERROR_UNKNOWN;
++            }
++
++            q->extsccparam.Header.BufferId = MFX_EXTBUFF_AV1_SCREEN_CONTENT_TOOLS;
++            q->extsccparam.Header.BufferSz = sizeof(q->extsccparam);
++            q->extsccparam.Palette = q->palette_mode ? MFX_CODINGOPTION_ON : MFX_CODINGOPTION_OFF;
++            q->extsccparam.IntraBlockCopy = q->intrabc ? MFX_CODINGOPTION_ON : MFX_CODINGOPTION_OFF;
++            q->extparam_internal[q->nb_extparam_internal++] = (mfxExtBuffer *)&q->extsccparam;
++        } else {
++            av_log(avctx, AV_LOG_ERROR,
++                   "This version of runtime doesn't support Screen Content Tool Encode\n");
++            return AVERROR_UNKNOWN;
++        }
++    }
++#endif
++
+     if (!check_enc_param(avctx,q)) {
+         av_log(avctx, AV_LOG_ERROR,
+                "some encoding parameters are not supported by the QSV "
+@@ -1389,11 +1421,21 @@ static int qsv_retrieve_enc_av1_params(AVCodecContext *avctx, QSVEncContext *q)
+         .Header.BufferSz = sizeof(co3),
+     };
+ 
++#if QSV_HAVE_EXT_AV1_SCC
++    mfxExtAV1ScreenContentTools scc_buf = {
++        .Header.BufferId = MFX_EXTBUFF_AV1_SCREEN_CONTENT_TOOLS,
++        .Header.BufferSz = sizeof(scc_buf),
++    };
++#endif
++
+     mfxExtBuffer *ext_buffers[] = {
+         (mfxExtBuffer*)&av1_extend_tile_buf,
+         (mfxExtBuffer*)&av1_bs_param,
+         (mfxExtBuffer*)&co2,
+         (mfxExtBuffer*)&co3,
++#if QSV_HAVE_EXT_AV1_SCC
++        (mfxExtBuffer*)&scc_buf,
++#endif
+     };
+ 
+     if (!QSV_RUNTIME_VERSION_ATLEAST(q->ver, 2, 5)) {
+diff --git a/libavcodec/qsvenc.h b/libavcodec/qsvenc.h
+index 4bc77f2..2e0a19b 100644
+--- a/libavcodec/qsvenc.h
++++ b/libavcodec/qsvenc.h
+@@ -38,6 +38,7 @@
+ 
+ #define QSV_HAVE_EXT_VP9_TILES QSV_VERSION_ATLEAST(1, 29)
+ #define QSV_HAVE_EXT_AV1_PARAM QSV_VERSION_ATLEAST(2, 5)
++#define QSV_HAVE_EXT_AV1_SCC   QSV_VERSION_ATLEAST(2, 13)
+ 
+ #if defined(_WIN32) || defined(__CYGWIN__)
+ #define QSV_HAVE_AVBR   1
+@@ -188,10 +189,13 @@ typedef struct QSVEncContext {
+     mfxFrameSurface1       **opaque_surfaces;
+     AVBufferRef             *opaque_alloc_buf;
+ #endif
++#if QSV_HAVE_EXT_AV1_SCC
++    mfxExtAV1ScreenContentTools extsccparam;
++#endif
+ 
+     mfxExtVideoSignalInfo extvsi;
+ 
+-    mfxExtBuffer  *extparam_internal[5 + (QSV_HAVE_MF * 2) + (QSV_HAVE_EXT_AV1_PARAM * 2) + QSV_HAVE_HE];
++    mfxExtBuffer  *extparam_internal[5 + (QSV_HAVE_MF * 2) + (QSV_HAVE_EXT_AV1_PARAM * 2) + QSV_HAVE_HE + QSV_HAVE_EXT_AV1_SCC];
+     int         nb_extparam_internal;
+ 
+     mfxExtBuffer  **extparam_str;
+@@ -319,6 +323,8 @@ typedef struct QSVEncContext {
+     int dual_gfx;
+ 
+     AVDictionary *qsv_params;
++    int palette_mode;
++    int intrabc;
+ } QSVEncContext;
+ 
+ int ff_qsv_enc_init(AVCodecContext *avctx, QSVEncContext *q);
+diff --git a/libavcodec/qsvenc_av1.c b/libavcodec/qsvenc_av1.c
+index a86b409..4f035f3 100644
+--- a/libavcodec/qsvenc_av1.c
++++ b/libavcodec/qsvenc_av1.c
+@@ -189,6 +189,10 @@ static const AVOption options[] = {
+     { "tile_cols",  "Number of columns for tiled encoding",   OFFSET(qsv.tile_cols),    AV_OPT_TYPE_INT, { .i64 = 0 }, 0, UINT16_MAX, VE },
+     { "tile_rows",  "Number of rows for tiled encoding",      OFFSET(qsv.tile_rows),    AV_OPT_TYPE_INT, { .i64 = 0 }, 0, UINT16_MAX, VE },
+     { "look_ahead_depth", "Depth of look ahead in number frames, available when extbrc option is enabled", OFFSET(qsv.look_ahead_depth), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 100, VE },
++#if QSV_HAVE_EXT_AV1_SCC
++    { "palette_mode", "Enable palette mode of Screen Content Tool for encoding", OFFSET(qsv.palette_mode), AV_OPT_TYPE_BOOL, { .i64 = 0}, 0, 1, VE},
++    { "intrabc", "Enable intra block copy of Screen Content Tool for encoding", OFFSET(qsv.intrabc), AV_OPT_TYPE_BOOL, { .i64 = 0}, 0, 1, VE},
++#endif
+     { NULL },
+ };
+ 
+-- 
+2.25.1
+
diff -Naupr a/contrib/ffmpeg/A20-Revert-avcodec-amfenc-GPU-driver-version-check.patch b/contrib/ffmpeg/A20-Revert-avcodec-amfenc-GPU-driver-version-check.patch
--- a/contrib/ffmpeg/A20-Revert-avcodec-amfenc-GPU-driver-version-check.patch	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/ffmpeg/A20-Revert-avcodec-amfenc-GPU-driver-version-check.patch	2025-03-31 11:55:35.193885263 +0200
@@ -0,0 +1,30 @@
+From 9d5ef6ed5f21ccfb746667106fa1df3fdeef1a80 Mon Sep 17 00:00:00 2001
+From: Damiano Galassi <damiog@gmail.com>
+Date: Sat, 19 Oct 2024 09:50:44 +0200
+Subject: [PATCH] Revert "avcodec/amfenc: GPU driver version check"
+
+This reverts commit eda3fc60534c4a30f49c930611d4130427d08ff1.
+
+There is hardware with HEVC 10-bit encoders that has no updated drivers yet.
+---
+ libavcodec/amfenc.c | 4 ----
+ 1 file changed, 4 deletions(-)
+
+diff --git a/libavcodec/amfenc.c b/libavcodec/amfenc.c
+index a83f5b2013..95fce9ac96 100644
+--- a/libavcodec/amfenc.c
++++ b/libavcodec/amfenc.c
+@@ -415,10 +415,6 @@ static int amf_init_encoder(AVCodecContext *avctx)
+     else
+         pix_fmt = avctx->pix_fmt;
+ 
+-    if (pix_fmt == AV_PIX_FMT_P010) {
+-        AMF_RETURN_IF_FALSE(ctx, ctx->version >= AMF_MAKE_FULL_VERSION(1, 4, 32, 0), AVERROR_UNKNOWN, "10-bit encoder is not supported by AMD GPU drivers versions lower than 23.30.\n");
+-    }
+-
+     ctx->format = amf_av_to_amf_format(pix_fmt);
+     AMF_RETURN_IF_FALSE(ctx, ctx->format != AMF_SURFACE_UNKNOWN, AVERROR(EINVAL),
+                         "Format %s is not supported\n", av_get_pix_fmt_name(pix_fmt));
+-- 
+2.39.5 (Apple Git-154)
+
diff -Naupr a/contrib/ffmpeg/A21-lavc-pgssubdec-Add-graphic-plane-and-cropping.patch b/contrib/ffmpeg/A21-lavc-pgssubdec-Add-graphic-plane-and-cropping.patch
--- a/contrib/ffmpeg/A21-lavc-pgssubdec-Add-graphic-plane-and-cropping.patch	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/ffmpeg/A21-lavc-pgssubdec-Add-graphic-plane-and-cropping.patch	2025-03-31 11:55:35.193885263 +0200
@@ -0,0 +1,793 @@
+From 2a2fdb2c75d74e37840597cf88578d43ab2f5f70 Mon Sep 17 00:00:00 2001
+From: cubicibo <55701024+cubicibo@users.noreply.github.com>
+Date: Thu, 22 Aug 2024 22:57:54 +0200
+Subject: [PATCH] lavc/pgssubdec: Add graphic plane and cropping.
+
+---
+ libavcodec/pgssubdec.c | 554 ++++++++++++++++++++++++++---------------
+ 1 file changed, 353 insertions(+), 201 deletions(-)
+
+diff --git a/libavcodec/pgssubdec.c b/libavcodec/pgssubdec.c
+index 5f76f12615..973a264105 100644
+--- a/libavcodec/pgssubdec.c
++++ b/libavcodec/pgssubdec.c
+@@ -34,9 +34,11 @@
+ #include "libavutil/opt.h"
+ 
+ #define RGBA(r,g,b,a) (((unsigned)(a) << 24) | ((r) << 16) | ((g) << 8) | (b))
+-#define MAX_EPOCH_PALETTES 8   // Max 8 allowed per PGS epoch
+-#define MAX_EPOCH_OBJECTS  64  // Max 64 allowed per PGS epoch
+-#define MAX_OBJECT_REFS    2   // Max objects per display set
++#define MAX_EPOCH_PALETTES 8    // Max 8 allowed per PGS epoch
++#define MAX_EPOCH_OBJECTS  64   // Max 64 allowed per PGS epoch
++#define MAX_OBJECT_REFS    2    // Max objects per display set
++#define MAX_OBJECT_WH      4096 // Max object width/height
++
+ 
+ enum SegmentType {
+     PALETTE_SEGMENT      = 0x14,
+@@ -47,57 +49,80 @@ enum SegmentType {
+ };
+ 
+ typedef struct PGSSubObjectRef {
+-    int     id;
+-    int     window_id;
+-    uint8_t composition_flag;
+-    int     x;
+-    int     y;
+-    int     crop_x;
+-    int     crop_y;
+-    int     crop_w;
+-    int     crop_h;
++    uint16_t id;
++    uint8_t  window_id;
++    uint8_t  composition_flag;
++    uint16_t x;
++    uint16_t y;
++    uint16_t crop_x;
++    uint16_t crop_y;
++    uint16_t crop_w;
++    uint16_t crop_h;
+ } PGSSubObjectRef;
+ 
+ typedef struct PGSSubPresentation {
+-    int id_number;
+-    int palette_id;
+-    int object_count;
++    uint8_t         palette_flag;
++    uint8_t         palette_id;
++    uint8_t         object_count;
+     PGSSubObjectRef objects[MAX_OBJECT_REFS];
+-    int64_t pts;
++    int64_t         pts;
+ } PGSSubPresentation;
+ 
+ typedef struct PGSSubObject {
+-    int          id;
+-    int          w;
+-    int          h;
+-    uint8_t      *rle;
+-    unsigned int rle_buffer_size, rle_data_len;
+-    unsigned int rle_remaining_len;
++    uint16_t  id;
++    uint16_t  w;
++    uint16_t  h;
++    uint8_t   *rle;
++    uint8_t   *bitmap;
++    uint32_t  rle_buffer_size;
++    uint32_t  rle_data_len;
++    uint32_t  rle_remaining_len;
++    uint32_t  bitmap_buffer_size;
++    uint32_t  bitmap_size;
+ } PGSSubObject;
+ 
+ typedef struct PGSSubObjects {
+-    int          count;
++    uint8_t      count;
+     PGSSubObject object[MAX_EPOCH_OBJECTS];
+ } PGSSubObjects;
+ 
+ typedef struct PGSSubPalette {
+-    int         id;
+-    uint32_t    clut[256];
++    uint8_t     id;
++    uint32_t    clut[AVPALETTE_COUNT];
+ } PGSSubPalette;
+ 
+ typedef struct PGSSubPalettes {
+-    int           count;
++    uint8_t       count;
+     PGSSubPalette palette[MAX_EPOCH_PALETTES];
+ } PGSSubPalettes;
+ 
++typedef struct PGSGraphicPlane {
++   uint8_t        count;
++   uint8_t        writable;
++   AVSubtitleRect visible_rect[MAX_OBJECT_REFS];
++} PGSGraphicPlane;
++
+ typedef struct PGSSubContext {
+     AVClass *class;
+     PGSSubPresentation presentation;
+     PGSSubPalettes     palettes;
+     PGSSubObjects      objects;
++    PGSGraphicPlane    plane;
+     int forced_subs_only;
+ } PGSSubContext;
+ 
++static void clear_graphic_plane(PGSSubContext *ctx)
++{
++    int i;
++
++    for (i = 0; i < ctx->plane.count; i++) {
++       av_freep(&ctx->plane.visible_rect[i].data[0]);
++       memset(&ctx->plane.visible_rect[i], 0, sizeof(ctx->plane.visible_rect[i]));
++    }
++    ctx->plane.writable = 0;
++    ctx->plane.count = 0;
++}
++
+ static void flush_cache(AVCodecContext *avctx)
+ {
+     PGSSubContext *ctx = avctx->priv_data;
+@@ -105,8 +130,11 @@ static void flush_cache(AVCodecContext *avctx)
+ 
+     for (i = 0; i < ctx->objects.count; i++) {
+         av_freep(&ctx->objects.object[i].rle);
+-        ctx->objects.object[i].rle_buffer_size  = 0;
++        ctx->objects.object[i].rle_buffer_size    = 0;
+         ctx->objects.object[i].rle_remaining_len  = 0;
++        av_freep(&ctx->objects.object[i].bitmap);
++        ctx->objects.object[i].bitmap_buffer_size = 0;
++        ctx->objects.object[i].bitmap_size        = 0;
+     }
+     ctx->objects.count = 0;
+     ctx->palettes.count = 0;
+@@ -143,6 +171,7 @@ static av_cold int init_decoder(AVCodecContext *avctx)
+ 
+ static av_cold int close_decoder(AVCodecContext *avctx)
+ {
++    clear_graphic_plane((PGSSubContext *)avctx->priv_data);
+     flush_cache(avctx);
+ 
+     return 0;
+@@ -158,48 +187,51 @@ static av_cold int close_decoder(AVCodecContext *avctx)
+  * @param buf pointer to the RLE data to process
+  * @param buf_size size of the RLE data to process
+  */
+-static int decode_rle(AVCodecContext *avctx, AVSubtitleRect *rect,
+-                      const uint8_t *buf, unsigned int buf_size)
++static int decode_object_rle(AVCodecContext *avctx, PGSSubObject *object)
+ {
+-    const uint8_t *rle_bitmap_end;
++    const uint8_t *rle_buf;
++    const uint8_t *rle_end;
+     int pixel_count, line_count;
++    rle_buf = object->rle;
++    rle_end = object->rle + object->rle_data_len;
+ 
+-    rle_bitmap_end = buf + buf_size;
++    object->bitmap_size = object->w * object->h;
++    av_fast_padded_malloc(&object->bitmap, &object->bitmap_buffer_size,
++                          object->bitmap_size);
+ 
+-    rect->data[0] = av_malloc_array(rect->w, rect->h);
+-
+-    if (!rect->data[0])
++    if (!object->bitmap)
+         return AVERROR(ENOMEM);
+ 
+     pixel_count = 0;
+     line_count  = 0;
+ 
+-    while (buf < rle_bitmap_end && line_count < rect->h) {
++    while (rle_buf < rle_end && line_count < object->h) {
+         uint8_t flags, color;
+         int run;
+ 
+-        color = bytestream_get_byte(&buf);
++        color = bytestream_get_byte(&rle_buf);
+         run   = 1;
+ 
+         if (color == 0x00) {
+-            flags = bytestream_get_byte(&buf);
++            flags = bytestream_get_byte(&rle_buf);
+             run   = flags & 0x3f;
+             if (flags & 0x40)
+-                run = (run << 8) + bytestream_get_byte(&buf);
+-            color = flags & 0x80 ? bytestream_get_byte(&buf) : 0;
++                run = (run << 8) + bytestream_get_byte(&rle_buf);
++            color = flags & 0x80 ? bytestream_get_byte(&rle_buf) : 0;
+         }
+ 
+-        if (run > 0 && pixel_count + run <= rect->w * rect->h) {
+-            memset(rect->data[0] + pixel_count, color, run);
++        if (run > 0 && pixel_count + run <= object->w * object->h) {
++            memset(object->bitmap + pixel_count, color, run);
+             pixel_count += run;
+         } else if (!run) {
+             /*
+              * New Line. Check if correct pixels decoded, if not display warning
+              * and adjust bitmap pointer to correct new line position.
+              */
+-            if (pixel_count % rect->w > 0) {
+-                av_log(avctx, AV_LOG_ERROR, "Decoded %d pixels, when line should be %d pixels\n",
+-                       pixel_count % rect->w, rect->w);
++            if (pixel_count % object->w > 0) {
++                av_log(avctx, AV_LOG_ERROR,
++                       "Decoded %d pixels, when object line should be %d pixels\n",
++                       pixel_count % object->w, object->w);
+                 if (avctx->err_recognition & AV_EF_EXPLODE) {
+                     return AVERROR_INVALIDDATA;
+                 }
+@@ -208,13 +240,11 @@ static int decode_rle(AVCodecContext *avctx, AVSubtitleRect *rect,
+         }
+     }
+ 
+-    if (pixel_count < rect->w * rect->h) {
+-        av_log(avctx, AV_LOG_ERROR, "Insufficient RLE data for subtitle\n");
++    if (pixel_count < object->w * object->h) {
++        av_log(avctx, AV_LOG_ERROR, "Insufficient RLE data for object\n");
+         return AVERROR_INVALIDDATA;
+     }
+-
+-    ff_dlog(avctx, "Pixel Count = %d, Area = %d\n", pixel_count, rect->w * rect->h);
+-
++    ff_dlog(avctx, "Pixel Count = %d, Area = %d\n", pixel_count, object->w * object->h);
+     return 0;
+ }
+ 
+@@ -236,7 +266,7 @@ static int parse_object_segment(AVCodecContext *avctx,
+ 
+     uint8_t sequence_desc;
+     unsigned int rle_bitmap_len, width, height;
+-    int id;
++    int id, ret;
+ 
+     if (buf_size <= 4)
+         return AVERROR_INVALIDDATA;
+@@ -259,57 +289,71 @@ static int parse_object_segment(AVCodecContext *avctx,
+     /* Read the Sequence Description to determine if start of RLE data or appended to previous RLE */
+     sequence_desc = bytestream_get_byte(&buf);
+ 
+-    if (!(sequence_desc & 0x80)) {
+-        /* Additional RLE data */
+-        if (buf_size > object->rle_remaining_len)
++    /* First in sequence object definition segment */
++    if (sequence_desc & 0x80) {
++        if (buf_size <= 7)
+             return AVERROR_INVALIDDATA;
++        buf_size -= 7;
+ 
+-        memcpy(object->rle + object->rle_data_len, buf, buf_size);
+-        object->rle_data_len += buf_size;
+-        object->rle_remaining_len -= buf_size;
+-
+-        return 0;
+-    }
+-
+-    if (buf_size <= 7)
+-        return AVERROR_INVALIDDATA;
+-    buf_size -= 7;
++        /* Decode rle bitmap length, stored size includes width/height data */
++        rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;
+ 
+-    /* Decode rle bitmap length, stored size includes width/height data */
+-    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;
++        if (buf_size > rle_bitmap_len) {
++            av_log(avctx, AV_LOG_ERROR,
++                   "Buffer dimension %d larger than the expected RLE data %d\n",
++                   buf_size, rle_bitmap_len);
++            return AVERROR_INVALIDDATA;
++        }
+ 
+-    if (buf_size > rle_bitmap_len) {
+-        av_log(avctx, AV_LOG_ERROR,
+-               "Buffer dimension %d larger than the expected RLE data %d\n",
+-               buf_size, rle_bitmap_len);
+-        return AVERROR_INVALIDDATA;
+-    }
++        /* Get bitmap dimensions from data */
++        width  = bytestream_get_be16(&buf);
++        height = bytestream_get_be16(&buf);
+ 
+-    /* Get bitmap dimensions from data */
+-    width  = bytestream_get_be16(&buf);
+-    height = bytestream_get_be16(&buf);
++        /* Make sure the bitmap is not too large */
++        if (MAX_OBJECT_WH < width || MAX_OBJECT_WH < height || !width || !height) {
++            av_log(avctx, AV_LOG_ERROR, "Bitmap dimensions (%dx%d) invalid.\n", width, height);
++            return AVERROR_INVALIDDATA;
++        }
+ 
+-    /* Make sure the bitmap is not too large */
+-    if (avctx->width < width || avctx->height < height || !width || !height) {
+-        av_log(avctx, AV_LOG_ERROR, "Bitmap dimensions (%dx%d) invalid.\n", width, height);
+-        return AVERROR_INVALIDDATA;
+-    }
++        object->rle_data_len = 0;
++        object->w = width;
++        object->h = height;
++        /* Dimensions against video are checked at decode after cropping. */
++        av_fast_padded_malloc(&object->rle, &object->rle_buffer_size, rle_bitmap_len);
+ 
+-    object->w = width;
+-    object->h = height;
++        if (!object->rle) {
++            object->rle_remaining_len = 0;
++            return AVERROR(ENOMEM);
++        }
+ 
+-    av_fast_padded_malloc(&object->rle, &object->rle_buffer_size, rle_bitmap_len);
++        memcpy(object->rle, buf, buf_size);
++        object->rle_remaining_len = rle_bitmap_len;
++    } else {
++        /* Additional RLE data */
++        if (buf_size > object->rle_remaining_len)
++            return AVERROR_INVALIDDATA;
+ 
+-    if (!object->rle) {
+-        object->rle_data_len = 0;
+-        object->rle_remaining_len = 0;
+-        return AVERROR(ENOMEM);
++        memcpy(object->rle + object->rle_data_len, buf, buf_size);
++    }
++    object->rle_data_len += buf_size;
++    object->rle_remaining_len -= buf_size;
++
++    /* Last in sequence object definition (can be both first and last) */
++    if (sequence_desc & 0x40) {
++        /* Attempt decoding if data is valid */
++        if (0 == object->rle_remaining_len) {
++            ret = decode_object_rle(avctx, object);
++            if (ret < 0 && (avctx->err_recognition & AV_EF_EXPLODE || ret == AVERROR(ENOMEM))) {
++                return ret;
++            }
++        } else {
++            av_log(avctx, AV_LOG_ERROR,
++                "RLE data length %u is %u bytes shorter than expected\n",
++                object->rle_data_len, object->rle_remaining_len);
++            if (avctx->err_recognition & AV_EF_EXPLODE)
++                return AVERROR_INVALIDDATA;
++        }
+     }
+-
+-    memcpy(object->rle, buf, buf_size);
+-    object->rle_data_len = buf_size;
+-    object->rle_remaining_len = rle_bitmap_len - buf_size;
+-
+     return 0;
+ }
+ 
+@@ -317,7 +361,7 @@ static int parse_object_segment(AVCodecContext *avctx,
+  * Parse the palette segment packet.
+  *
+  * The palette segment contains details of the palette,
+- * a maximum of 256 colors can be defined.
++ * a maximum of 256 colors (AVPALETTE_COUNT) can be defined.
+  *
+  * @param avctx contains the current codec context
+  * @param buf pointer to the packet to process
+@@ -390,13 +434,17 @@ static int parse_presentation_segment(AVCodecContext *avctx,
+                                       int64_t pts)
+ {
+     PGSSubContext *ctx = avctx->priv_data;
+-    int i, state, ret;
++    int ret;
++    uint8_t i, state;
+     const uint8_t *buf_end = buf + buf_size;
+ 
+     // Video descriptor
+     int w = bytestream_get_be16(&buf);
+     int h = bytestream_get_be16(&buf);
+ 
++    // On a new display set, reset writability of the graphic plane
++    ctx->plane.writable = 0;
++
+     ctx->presentation.pts = pts;
+ 
+     ff_dlog(avctx, "Video Dimensions %dx%d\n",
+@@ -405,88 +453,121 @@ static int parse_presentation_segment(AVCodecContext *avctx,
+     if (ret < 0)
+         return ret;
+ 
+-    /* Skip 1 bytes of unknown, frame rate */
+-    buf++;
++    /* Skip 3 bytes: framerate (1), presentation id number (2) */
++    buf+=3;
+ 
+-    // Composition descriptor
+-    ctx->presentation.id_number = bytestream_get_be16(&buf);
+     /*
+-     * state is a 2 bit field that defines pgs epoch boundaries
++     * State is a 2 bit field that defines pgs epoch boundaries
+      * 00 - Normal, previously defined objects and palettes are still valid
+      * 01 - Acquisition point, previous objects and palettes can be released
+      * 10 - Epoch start, previous objects and palettes can be released
+      * 11 - Epoch continue, previous objects and palettes can be released
+      *
+-     * reserved 6 bits discarded
++     * Reserved 6 bits discarded
+      */
+     state = bytestream_get_byte(&buf) >> 6;
+     if (state != 0) {
++        /* Epoch start always wipes the graphic plane. Epoch continue does only if
++         * playback is not seamless, which should not happen with a proper stream.
++         */
++        if (0b10 == state)
++            clear_graphic_plane((PGSSubContext *)avctx->priv_data);
+         flush_cache(avctx);
+     }
+ 
++    /* Reserved 7 bits discarded. */
++    ctx->presentation.palette_flag = bytestream_get_byte(&buf) & 0x80;
++    ctx->presentation.palette_id = bytestream_get_byte(&buf);
++
+     /*
+-     * skip palette_update_flag (0x80),
++     * On palette update, don't parse the compositions references,
++     * just evaluate the existing graphic plane with the new palette.
+      */
+-    buf += 1;
+-    ctx->presentation.palette_id = bytestream_get_byte(&buf);
+-    ctx->presentation.object_count = bytestream_get_byte(&buf);
+-    if (ctx->presentation.object_count > MAX_OBJECT_REFS) {
+-        av_log(avctx, AV_LOG_ERROR,
+-               "Invalid number of presentation objects %d\n",
+-               ctx->presentation.object_count);
+-        ctx->presentation.object_count = 2;
+-        if (avctx->err_recognition & AV_EF_EXPLODE) {
+-            return AVERROR_INVALIDDATA;
++    if (!ctx->presentation.palette_flag) {
++        ctx->presentation.object_count = bytestream_get_byte(&buf);
++        if (ctx->presentation.object_count > MAX_OBJECT_REFS) {
++            av_log(avctx, AV_LOG_ERROR,
++                   "Invalid number of presentation objects %d\n",
++                   ctx->presentation.object_count);
++            ctx->presentation.object_count = 2;
++            if (avctx->err_recognition & AV_EF_EXPLODE) {
++                return AVERROR_INVALIDDATA;
++            }
+         }
+-    }
+ 
++        for (i = 0; i < ctx->presentation.object_count; i++) {
++            PGSSubObjectRef *const object = &ctx->presentation.objects[i];
+ 
+-    for (i = 0; i < ctx->presentation.object_count; i++)
+-    {
+-        PGSSubObjectRef *const object = &ctx->presentation.objects[i];
++            if (buf_end - buf < 8) {
++                av_log(avctx, AV_LOG_ERROR, "Insufficent space for object\n");
++                ctx->presentation.object_count = i;
++                return AVERROR_INVALIDDATA;
++            }
+ 
+-        if (buf_end - buf < 8) {
+-            av_log(avctx, AV_LOG_ERROR, "Insufficent space for object\n");
+-            ctx->presentation.object_count = i;
+-            return AVERROR_INVALIDDATA;
+-        }
++            object->id               = bytestream_get_be16(&buf);
++            object->window_id        = bytestream_get_byte(&buf);
++            object->composition_flag = bytestream_get_byte(&buf);
+ 
+-        object->id               = bytestream_get_be16(&buf);
+-        object->window_id        = bytestream_get_byte(&buf);
+-        object->composition_flag = bytestream_get_byte(&buf);
++            object->x = bytestream_get_be16(&buf);
++            object->y = bytestream_get_be16(&buf);
+ 
+-        object->x = bytestream_get_be16(&buf);
+-        object->y = bytestream_get_be16(&buf);
++            // If cropping
++            if (object->composition_flag & 0x80) {
++                object->crop_x = bytestream_get_be16(&buf);
++                object->crop_y = bytestream_get_be16(&buf);
++                object->crop_w = bytestream_get_be16(&buf);
++                object->crop_h = bytestream_get_be16(&buf);
++            }
+ 
+-        // If cropping
+-        if (object->composition_flag & 0x80) {
+-            object->crop_x = bytestream_get_be16(&buf);
+-            object->crop_y = bytestream_get_be16(&buf);
+-            object->crop_w = bytestream_get_be16(&buf);
+-            object->crop_h = bytestream_get_be16(&buf);
++            /* Placement is checked at decode after cropping. */
++            ff_dlog(avctx, "Subtitle Placement x=%d, y=%d\n",
++                    object->x, object->y);
+         }
++    }
++    return 0;
++}
+ 
+-        ff_dlog(avctx, "Subtitle Placement x=%d, y=%d\n",
+-                object->x, object->y);
++/**
++ * Parse the window segment packet.
++ *
++ * The window segment instructs the decoder to redraw the graphic plane
++ * with the composition references provided in the presentation segment
++ *
++ * @param avctx contains the current codec context
++ */
++static int parse_window_segment(AVCodecContext *avctx, const uint8_t *buf,
++                                int buf_size)
++{
++    PGSSubContext *ctx = (PGSSubContext *)avctx->priv_data;
+ 
+-        if (object->x > avctx->width || object->y > avctx->height) {
+-            av_log(avctx, AV_LOG_ERROR, "Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\n",
+-                   object->x, object->y,
+-                    avctx->width, avctx->height);
+-            object->y = object->x = 0;
+-            if (avctx->err_recognition & AV_EF_EXPLODE) {
+-                return AVERROR_INVALIDDATA;
+-            }
+-        }
++    // 1 byte: number of windows defined
++    if (bytestream_get_byte(&buf) > MAX_OBJECT_REFS) {
++        av_log(avctx, AV_LOG_ERROR, "Too many windows defined.\n");
++        return AVERROR_INVALIDDATA;
+     }
+ 
++    /* TODO: mask objects with windows when transfering to the graphic plane
++     * Window Segment Structure
++     *     {
++     *       1 byte : window id,
++     *       2 bytes: X position of window,
++     *       2 bytes: Y position of window,
++     *       2 bytes: Width of window,
++     *       2 bytes: Height of window.
++     *     }
++     */
++    // Flush the graphic plane, it will be redrawn.
++    clear_graphic_plane(ctx);
++    ctx->plane.writable = 1;
++    ctx->plane.count = ctx->presentation.object_count;
+     return 0;
+ }
+ 
+ /**
+  * Parse the display segment packet.
+  *
+- * The display segment controls the updating of the display.
++ * The display segment closes the display set. The inferred data is used
++ * to decide if the display should be updated.
+  *
+  * @param avctx contains the current codec context
+  * @param data pointer to the data pertaining the subtitle to display
+@@ -499,26 +580,33 @@ static int display_end_segment(AVCodecContext *avctx, AVSubtitle *sub,
+     PGSSubContext *ctx = avctx->priv_data;
+     int64_t pts;
+     PGSSubPalette *palette;
+-    int i, ret;
++    int i;
+ 
+     pts = ctx->presentation.pts != AV_NOPTS_VALUE ? ctx->presentation.pts : sub->pts;
+     memset(sub, 0, sizeof(*sub));
+     sub->pts = pts;
+     ctx->presentation.pts = AV_NOPTS_VALUE;
+-    sub->start_display_time = 0;
+     // There is no explicit end time for PGS subtitles.  The end time
+     // is defined by the start of the next sub which may contain no
+     // objects (i.e. clears the previous sub)
+     sub->end_display_time   = UINT32_MAX;
+-    sub->format             = 0;
+ 
+-    // Blank if last object_count was 0.
+-    if (!ctx->presentation.object_count)
++    // Object count is zero only on an epoch start with no WDS
++    // or the last DS with a WDS had no presentation object.
++    if (!ctx->plane.count) {
+         return 1;
+-    sub->rects = av_calloc(ctx->presentation.object_count, sizeof(*sub->rects));
+-    if (!sub->rects) {
+-        return AVERROR(ENOMEM);
+     }
++
++    if (!ctx->presentation.palette_flag && !ctx->plane.writable) {
++        // This display set does not perform a display update
++        // E.g. it only defines new objects or palettes for future usage.
++        return 0;
++    }
++
++    sub->rects = av_calloc(ctx->plane.count, sizeof(*sub->rects));
++    if (!sub->rects)
++        return AVERROR(ENOMEM);
++
+     palette = find_palette(ctx->presentation.palette_id, &ctx->palettes);
+     if (!palette) {
+         // Missing palette.  Should only happen with damaged streams.
+@@ -527,57 +615,128 @@ static int display_end_segment(AVCodecContext *avctx, AVSubtitle *sub,
+         avsubtitle_free(sub);
+         return AVERROR_INVALIDDATA;
+     }
+-    for (i = 0; i < ctx->presentation.object_count; i++) {
+-        AVSubtitleRect *const rect = av_mallocz(sizeof(*rect));
+-        PGSSubObject *object;
+ 
+-        if (!rect)
+-            return AVERROR(ENOMEM);
+-        sub->rects[sub->num_rects++] = rect;
+-        rect->type = SUBTITLE_BITMAP;
+-
+-        /* Process bitmap */
+-        object = find_object(ctx->presentation.objects[i].id, &ctx->objects);
+-        if (!object) {
+-            // Missing object.  Should only happen with damaged streams.
+-            av_log(avctx, AV_LOG_ERROR, "Invalid object id %d\n",
+-                   ctx->presentation.objects[i].id);
+-            if (avctx->err_recognition & AV_EF_EXPLODE)
+-                return AVERROR_INVALIDDATA;
+-            // Leaves rect empty with 0 width and height.
+-            continue;
+-        }
+-        if (ctx->presentation.objects[i].composition_flag & 0x40)
+-            rect->flags |= AV_SUBTITLE_FLAG_FORCED;
++    for (i = 0; i < ctx->plane.count; i++) {
++        const PGSSubObjectRef *sub_object = &ctx->presentation.objects[i];
++        AVSubtitleRect *const gp_rect = &ctx->plane.visible_rect[i];
++        AVSubtitleRect *rect;
++        gp_rect->type = SUBTITLE_BITMAP;
++
++        // Compose the graphic plane if a window segment has been provided
++        if (ctx->plane.writable) {
++            PGSSubObject *object;
++
++            // Process bitmap
++            object = find_object(sub_object->id, &ctx->objects);
++            if (!object) {
++                // Missing object.  Should only happen with damaged streams.
++                av_log(avctx, AV_LOG_ERROR, "Invalid object id %d\n", sub_object->id);
++                if (avctx->err_recognition & AV_EF_EXPLODE)
++                    return AVERROR_INVALIDDATA;
++                // Leaves rect empty with 0 width and height.
++                continue;
++            }
++            if (sub_object->composition_flag & 0x40)
++                gp_rect->flags |= AV_SUBTITLE_FLAG_FORCED;
++
++            gp_rect->x    = sub_object->x;
++            gp_rect->y    = sub_object->y;
++
++            if (object->rle) {
++                int out_of_picture = 0;
++                gp_rect->w = object->w;
++                gp_rect->h = object->h;
++
++                gp_rect->linesize[0] = object->w;
++
++                // Check for cropping.
++                if (sub_object->composition_flag & 0x80) {
++                    int out_of_object = 0;
++
++                    if (object->w < sub_object->crop_x + sub_object->crop_w)
++                        out_of_object = 1;
++                    if (object->h < sub_object->crop_y + sub_object->crop_h)
++                        out_of_object = 1;
++
++                    if (out_of_object) {
++                        av_log(avctx, AV_LOG_ERROR,
++                               "Subtitle cropping values are out of object. "
++                               "obj_w = %d, obj_h = %d, crop_x = %d, crop_y = %d, "
++                               "crop_w = %d, crop_h = %d.\n",
++                               object->w,
++                               object->h,
++                               sub_object->crop_x,
++                               sub_object->crop_y,
++                               sub_object->crop_w,
++                               sub_object->crop_h);
++                        if (avctx->err_recognition & AV_EF_EXPLODE)
++                            return AVERROR_INVALIDDATA;
++                    } else {
++                        // Replace subtitle dimensions with cropping ones.
++                        gp_rect->w = sub_object->crop_w;
++                        gp_rect->h = sub_object->crop_h;
++                        gp_rect->linesize[0] = sub_object->crop_w;
++                    }
++                }
++
++                /* Make sure the subtitle is not out of picture. */
++                if (avctx->width < gp_rect->x + gp_rect->w || !gp_rect->w)
++                    out_of_picture = 1;
++                if (avctx->height < gp_rect->y + gp_rect->h || !gp_rect->h)
++                    out_of_picture = 1;
++                if (out_of_picture) {
++                    av_log(avctx, AV_LOG_ERROR,
++                           "Subtitle out of video bounds. "
++                           "x = %d, y = %d, width = %d, height = %d.\n",
++                           gp_rect->x, gp_rect->y, gp_rect->w, gp_rect->h);
++                    if (avctx->err_recognition & AV_EF_EXPLODE)
++                        return AVERROR_INVALIDDATA;
++                    gp_rect->w = 0;
++                    gp_rect->h = 0;
++                    continue;
++                }
+ 
+-        rect->x    = ctx->presentation.objects[i].x;
+-        rect->y    = ctx->presentation.objects[i].y;
++                if (!object->bitmap_size || object->rle_remaining_len) {
++                    gp_rect->w = 0;
++                    gp_rect->h = 0;
++                    continue;
++                }
+ 
+-        if (object->rle) {
+-            rect->w    = object->w;
+-            rect->h    = object->h;
++                gp_rect->data[0] = av_malloc_array(gp_rect->w, gp_rect->h);
++                if (!gp_rect->data[0])
++                    return AVERROR(ENOMEM);
+ 
+-            rect->linesize[0] = object->w;
++                if (sub_object->composition_flag & 0x80) {
++                    /* Copy cropped bitmap. */
++                    int y;
+ 
+-            if (object->rle_remaining_len) {
+-                av_log(avctx, AV_LOG_ERROR, "RLE data length %u is %u bytes shorter than expected\n",
+-                       object->rle_data_len, object->rle_remaining_len);
+-                if (avctx->err_recognition & AV_EF_EXPLODE)
+-                    return AVERROR_INVALIDDATA;
+-            }
+-            ret = decode_rle(avctx, rect, object->rle, object->rle_data_len);
+-            if (ret < 0) {
+-                if ((avctx->err_recognition & AV_EF_EXPLODE) ||
+-                    ret == AVERROR(ENOMEM)) {
+-                    return ret;
++                    for (y = 0; y < sub_object->crop_h; y++) {
++                        memcpy(&gp_rect->data[0][y * sub_object->crop_w],
++                               &object->bitmap[(sub_object->crop_y + y) *
++                               object->w + sub_object->crop_x],
++                               sub_object->crop_w);
++                    }
++                }
++                else {
++                    /* copy full object */
++                    memcpy(gp_rect->data[0], object->bitmap, object->bitmap_size);
+                 }
+-                rect->w = 0;
+-                rect->h = 0;
+-                continue;
+             }
+         }
+-        /* Allocate memory for colors */
+-        rect->nb_colors = 256;
++        // Export graphic plane content with latest palette
++        rect = av_memdup(gp_rect, sizeof(*gp_rect));
++        if (!rect)
++            return AVERROR(ENOMEM);
++
++        sub->rects[sub->num_rects++] = rect;
++        if (gp_rect->data[0]) {
++            rect->data[0] = av_memdup(gp_rect->data[0], rect->w*rect->h);
++            if (!rect->data[0])
++                return AVERROR(ENOMEM);
++        }
++
++        // Allocate memory for colors
++        rect->nb_colors = AVPALETTE_COUNT;
+         rect->data[1]   = av_mallocz(AVPALETTE_SIZE);
+         if (!rect->data[1])
+             return AVERROR(ENOMEM);
+@@ -640,14 +799,7 @@ static int decode(AVCodecContext *avctx, AVSubtitle *sub,
+             ret = parse_presentation_segment(avctx, buf, segment_length, sub->pts);
+             break;
+         case WINDOW_SEGMENT:
+-            /*
+-             * Window Segment Structure (No new information provided):
+-             *     2 bytes: Unknown,
+-             *     2 bytes: X position of subtitle,
+-             *     2 bytes: Y position of subtitle,
+-             *     2 bytes: Width of subtitle,
+-             *     2 bytes: Height of subtitle.
+-             */
++            ret = parse_window_segment(avctx, buf, segment_length);
+             break;
+         case DISPLAY_SEGMENT:
+             if (*got_sub_ptr) {
+-- 
+2.32.0 (Apple Git-132)
+
diff -Naupr a/contrib/ffmpeg/A22-avformat-mov-read-and-write-additional-iTunes-style-.patch b/contrib/ffmpeg/A22-avformat-mov-read-and-write-additional-iTunes-style-.patch
--- a/contrib/ffmpeg/A22-avformat-mov-read-and-write-additional-iTunes-style-.patch	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/ffmpeg/A22-avformat-mov-read-and-write-additional-iTunes-style-.patch	2025-03-31 11:55:35.193885263 +0200
@@ -0,0 +1,279 @@
+From b62c3a69a5f286eee2be4d14cf3705c476a953a4 Mon Sep 17 00:00:00 2001
+From: Damiano Galassi <damiog@gmail.com>
+Date: Tue, 18 Feb 2025 07:32:08 +0100
+Subject: [PATCH 1/2] avformat/mov: read and write additional iTunes style
+ metadata
+
+---
+ libavformat/mov.c    | 67 +++++++++++++++++++++++++++++++++++++++++-
+ libavformat/movenc.c | 70 +++++++++++++++++++++++++++++++++++++++++---
+ 2 files changed, 132 insertions(+), 5 deletions(-)
+
+diff --git a/libavformat/mov.c b/libavformat/mov.c
+index e1e668e40c..e64b0dbe63 100644
+--- a/libavformat/mov.c
++++ b/libavformat/mov.c
+@@ -132,6 +132,33 @@ static int mov_metadata_int8_no_padding(MOVContext *c, AVIOContext *pb,
+     return 0;
+ }
+ 
++static int mov_metadata_int16_no_padding(MOVContext *c, AVIOContext *pb,
++                                         unsigned len, const char *key)
++{
++    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;
++    av_dict_set_int(&c->fc->metadata, key, avio_rb16(pb), 0);
++
++    return 0;
++}
++
++static int mov_metadata_int32_no_padding(MOVContext *c, AVIOContext *pb,
++                                         unsigned len, const char *key)
++{
++    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;
++    av_dict_set_int(&c->fc->metadata, key, avio_rb32(pb), 0);
++
++    return 0;
++}
++
++static int mov_metadata_int64_no_padding(MOVContext *c, AVIOContext *pb,
++                                         unsigned len, const char *key)
++{
++    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;
++    av_dict_set_int(&c->fc->metadata, key, avio_rb64(pb), 0);
++
++    return 0;
++}
++
+ static int mov_metadata_gnre(MOVContext *c, AVIOContext *pb,
+                              unsigned len, const char *key)
+ {
+@@ -417,7 +444,13 @@ static int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)
+     case MKTAG( 'a','k','I','D'): key = "account_type";
+         parse = mov_metadata_int8_no_padding; break;
+     case MKTAG( 'a','p','I','D'): key = "account_id"; break;
++    case MKTAG( 'a','t','I','D'): key = "artist_id";
++        parse = mov_metadata_int32_no_padding; break;
+     case MKTAG( 'c','a','t','g'): key = "category"; break;
++    case MKTAG( 'c','m','I','D'): key = "composer_id";
++        parse = mov_metadata_int32_no_padding; break;
++    case MKTAG( 'c','n','I','D'): key = "content_id";
++        parse = mov_metadata_int32_no_padding; break;
+     case MKTAG( 'c','p','i','l'): key = "compilation";
+         parse = mov_metadata_int8_no_padding; break;
+     case MKTAG( 'c','p','r','t'):
+@@ -436,6 +469,8 @@ static int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)
+     case MKTAG( 'e','g','i','d'): key = "episode_uid";
+         parse = mov_metadata_int8_no_padding; break;
+     case MKTAG( 'F','I','R','M'): key = "firmware"; raw = 1; break;
++    case MKTAG( 'g','e','I','D'): key = "genre_id";
++        parse = mov_metadata_int32_no_padding; break;
+     case MKTAG( 'g','n','r','e'):
+         key = "genre";
+         parse = mov_metadata_gnre;
+@@ -451,6 +486,8 @@ static int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)
+         parse = mov_metadata_int8_no_padding; break;
+     case MKTAG( 'H','M','M','T'):
+         return mov_metadata_hmmt(c, pb, atom.size);
++    case MKTAG( 'i','t','n','u'): key = "itunes_u";
++        parse = mov_metadata_int8_no_padding; break;
+     case MKTAG( 'k','e','y','w'): key = "keywords";  break;
+     case MKTAG( 'l','d','e','s'): key = "synopsis";  break;
+     case MKTAG( 'l','o','c','i'):
+@@ -462,9 +499,16 @@ static int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)
+         parse = mov_metadata_int8_no_padding; break;
+     case MKTAG( 'p','g','a','p'): key = "gapless_playback";
+         parse = mov_metadata_int8_no_padding; break;
++    case MKTAG( 'p','l','I','D'): key = "playlist_id";
++        parse = mov_metadata_int64_no_padding; break;
+     case MKTAG( 'p','u','r','d'): key = "purchase_date"; break;
+     case MKTAG( 'r','t','n','g'): key = "rating";
+         parse = mov_metadata_int8_no_padding; break;
++    case MKTAG( 's','f','I','D'): key = "itunes_country";
++        parse = mov_metadata_int32_no_padding; break;
++    case MKTAG( 's','d','e','s'): key = "series_description"; break;
++    case MKTAG( 's','h','w','m'): key = "show_work_and_movement";
++        parse = mov_metadata_int8_no_padding; break;
+     case MKTAG( 's','o','a','a'): key = "sort_album_artist"; break;
+     case MKTAG( 's','o','a','l'): key = "sort_album";   break;
+     case MKTAG( 's','o','a','r'): key = "sort_artist";  break;
+@@ -473,6 +517,8 @@ static int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)
+     case MKTAG( 's','o','s','n'): key = "sort_show";    break;
+     case MKTAG( 's','t','i','k'): key = "media_type";
+         parse = mov_metadata_int8_no_padding; break;
++    case MKTAG( 't','m','p','o'): key = "tmpo";
++        parse = mov_metadata_int16_no_padding; break;
+     case MKTAG( 't','r','k','n'): key = "track";
+         parse = mov_metadata_track_or_disc_number; break;
+     case MKTAG( 't','v','e','n'): key = "episode_id"; break;
+@@ -482,17 +528,23 @@ static int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)
+     case MKTAG( 't','v','s','h'): key = "show";      break;
+     case MKTAG( 't','v','s','n'): key = "season_number";
+         parse = mov_metadata_int8_bypass_padding; break;
++    case MKTAG( 'x','i','d',' '): key = "xid";       break;
+     case MKTAG(0xa9,'A','R','T'): key = "artist";    break;
+     case MKTAG(0xa9,'P','R','D'): key = "producer";  break;
+     case MKTAG(0xa9,'a','l','b'): key = "album";     break;
+-    case MKTAG(0xa9,'a','u','t'): key = "artist";    break;
++    case MKTAG(0xa9,'a','r','d'): key = "art_director"; break;
++    case MKTAG(0xa9,'a','r','g'): key = "arranger";  break;
++    case MKTAG(0xa9,'a','u','t'): key = "author";    break;
++    case MKTAG(0xa9,'c','a','k'): key = "acknowledgement"; break;
+     case MKTAG(0xa9,'c','h','p'): key = "chapter";   break;
+     case MKTAG(0xa9,'c','m','t'): key = "comment";   break;
+     case MKTAG(0xa9,'c','o','m'): key = "composer";  break;
++    case MKTAG(0xa9,'c','o','n'): key = "conductor"; break;
+     case MKTAG(0xa9,'c','p','y'): key = "copyright"; break;
+     case MKTAG(0xa9,'d','a','y'): key = "date";      break;
+     case MKTAG(0xa9,'d','i','r'): key = "director";  break;
+     case MKTAG(0xa9,'d','i','s'): key = "disclaimer"; break;
++    case MKTAG(0xa9,'d','e','s'): key = "song_description"; break;
+     case MKTAG(0xa9,'e','d','1'): key = "edit_date"; break;
+     case MKTAG(0xa9,'e','n','c'): key = "encoder";   break;
+     case MKTAG(0xa9,'f','m','t'): key = "original_format"; break;
+@@ -500,22 +552,35 @@ static int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)
+     case MKTAG(0xa9,'g','r','p'): key = "grouping";  break;
+     case MKTAG(0xa9,'h','s','t'): key = "host_computer"; break;
+     case MKTAG(0xa9,'i','n','f'): key = "comment";   break;
++    case MKTAG(0xa9,'l','n','t'): key = "linear_notes"; break;
+     case MKTAG(0xa9,'l','y','r'): key = "lyrics";    break;
+     case MKTAG(0xa9,'m','a','k'): key = "make";      break;
+     case MKTAG(0xa9,'m','o','d'): key = "model";     break;
++    case MKTAG(0xa9,'m','v','n'): key = "movement_name"; break;
++    case MKTAG(0xa9,'m','v','i'): key = "movement_number";
++        parse = mov_metadata_int16_no_padding; break;
++    case MKTAG(0xa9,'m','v','c'): key = "movement_count";
++        parse = mov_metadata_int16_no_padding; break;
+     case MKTAG(0xa9,'n','a','m'): key = "title";     break;
+     case MKTAG(0xa9,'o','p','e'): key = "original_artist"; break;
++    case MKTAG(0xa9,'p','h','g'): key = "phonogram_rights"; break;
+     case MKTAG(0xa9,'p','r','d'): key = "producer";  break;
+     case MKTAG(0xa9,'p','r','f'): key = "performers"; break;
++    case MKTAG(0xa9,'p','u','b'): key = "publisher"; break;
+     case MKTAG(0xa9,'r','e','q'): key = "playback_requirements"; break;
++    case MKTAG(0xa9,'s','n','e'): key = "sound_engineer"; break;
++    case MKTAG(0xa9,'s','o','l'): key = "soloist";   break;
+     case MKTAG(0xa9,'s','r','c'): key = "original_source"; break;
+     case MKTAG(0xa9,'s','t','3'): key = "subtitle";  break;
+     case MKTAG(0xa9,'s','w','r'): key = "encoder";   break;
++    case MKTAG(0xa9,'t','h','x'): key = "thanks";    break;
+     case MKTAG(0xa9,'t','o','o'): key = "encoder";   break;
+     case MKTAG(0xa9,'t','r','k'): key = "track";     break;
+     case MKTAG(0xa9,'u','r','l'): key = "URL";       break;
++    case MKTAG(0xa9,'w','r','k'): key = "work_name"; break;
+     case MKTAG(0xa9,'w','r','n'): key = "warning";   break;
+     case MKTAG(0xa9,'w','r','t'): key = "composer";  break;
++    case MKTAG(0xa9,'x','p','d'): key = "executive_producer"; break;
+     case MKTAG(0xa9,'x','y','z'): key = "location";  break;
+     case MKTAG( 'a','l','b','m'):
+     case MKTAG( 'a','u','t','h'):
+diff --git a/libavformat/movenc.c b/libavformat/movenc.c
+index 3486c6e3e5..11df7b0368 100644
+--- a/libavformat/movenc.c
++++ b/libavformat/movenc.c
+@@ -4557,15 +4557,19 @@ static int mov_write_int8_metadata(AVFormatContext *s, AVIOContext *pb,
+                                    int len)
+ {
+     AVDictionaryEntry *t = NULL;
+-    uint8_t num;
++    uint64_t num;
+     int size = 24 + len;
+ 
+-    if (len != 1 && len != 4)
++    if (len != 1 && len != 4 &&
++        len != 2 && len != 8)
+         return -1;
+ 
+     if (!(t = av_dict_get(s->metadata, tag, NULL, 0)))
+         return 0;
+-    num = atoi(t->value);
++    if (len <= 4)
++        num = atoi(t->value);
++    else
++        num = atol(t->value);
+ 
+     avio_wb32(pb, size);
+     ffio_wfourcc(pb, name);
+@@ -4573,7 +4577,9 @@ static int mov_write_int8_metadata(AVFormatContext *s, AVIOContext *pb,
+     ffio_wfourcc(pb, "data");
+     avio_wb32(pb, 0x15);
+     avio_wb32(pb, 0);
+-    if (len==4) avio_wb32(pb, num);
++    if (len==8) avio_wb64(pb, num);
++    else if (len==4) avio_wb32(pb, num);
++    else if (len==2) avio_wb16(pb, num);
+     else        avio_w8 (pb, num);
+ 
+     return size;
+@@ -4629,6 +4635,8 @@ static int mov_write_ilst_tag(AVIOContext *pb, MOVMuxContext *mov,
+     mov_write_string_metadata(s, pb, "\251lyr", "lyrics"   , 1);
+     mov_write_string_metadata(s, pb, "desc",    "description",1);
+     mov_write_string_metadata(s, pb, "ldes",    "synopsis" , 1);
++    mov_write_string_metadata(s, pb, "sdes",    "series_description", 1);
++    mov_write_string_metadata(s, pb, "rtng",    "rating",    1);
+     mov_write_string_metadata(s, pb, "tvsh",    "show"     , 1);
+     mov_write_string_metadata(s, pb, "tven",    "episode_id",1);
+     mov_write_string_metadata(s, pb, "tvnn",    "network"  , 1);
+@@ -4639,6 +4647,60 @@ static int mov_write_ilst_tag(AVIOContext *pb, MOVMuxContext *mov,
+     mov_write_int8_metadata  (s, pb, "hdvd",    "hd_video",  1);
+     mov_write_int8_metadata  (s, pb, "pgap",    "gapless_playback",1);
+     mov_write_int8_metadata  (s, pb, "cpil",    "compilation", 1);
++
++    mov_write_string_metadata(s, pb, "\251st3", "subtitle"        , 1);
++    mov_write_string_metadata(s, pb, "\251des", "song_description", 1);
++    mov_write_string_metadata(s, pb, "\251dir", "director"        , 1);
++    mov_write_string_metadata(s, pb, "\251ard", "art_director"    , 1);
++    mov_write_string_metadata(s, pb, "\251arg", "arranger"        , 1);
++    mov_write_string_metadata(s, pb, "\251aut", "author"          , 1);
++    mov_write_string_metadata(s, pb, "\251cak", "acknowledgement" , 1);
++    mov_write_string_metadata(s, pb, "\251con", "conductor"       , 1);
++
++    mov_write_string_metadata(s, pb, "\251wrk", "work_name"     , 1);
++    mov_write_string_metadata(s, pb, "\251mvn", "movement_name" , 1);
++    mov_write_int8_metadata  (s, pb, "\251mvi", "movement_number", 2);
++    mov_write_int8_metadata  (s, pb, "\251mvc", "movement_count" , 2);
++    mov_write_int8_metadata  (s, pb, "shwm",    "show_work_and_movement", 1);
++
++    mov_write_string_metadata(s, pb, "\251lnt", "linear_notes"      , 1);
++    mov_write_string_metadata(s, pb, "\251mak", "make"              , 1); // Record company
++    mov_write_string_metadata(s, pb, "\251ope", "original_artist"   , 1);
++    mov_write_string_metadata(s, pb, "\251phg", "phonogram_rights"  , 1);
++    mov_write_string_metadata(s, pb, "\251prd", "producer"          , 1);
++    mov_write_string_metadata(s, pb, "\251prf", "performers"        , 1);
++    mov_write_string_metadata(s, pb, "\251pub", "publisher"         , 1);
++    mov_write_string_metadata(s, pb, "\251sne", "sound_engineer"    , 1);
++    mov_write_string_metadata(s, pb, "\251sol", "soloist"           , 1);
++    mov_write_string_metadata(s, pb, "\251src", "original_source"   , 1); // Credits
++    mov_write_string_metadata(s, pb, "\251thx", "thanks"            , 1);
++    mov_write_string_metadata(s, pb, "\251url", "URL"               , 1); // Online extras
++    mov_write_string_metadata(s, pb, "\251xpd", "executive_producer", 1);
++
++    mov_write_string_metadata(s, pb, "sonm", "sort_name"        , 1);
++    mov_write_string_metadata(s, pb, "soar", "sort_artist"      , 1);
++    mov_write_string_metadata(s, pb, "soaa", "sort_album_artist", 1);
++    mov_write_string_metadata(s, pb, "soal", "sort_album"       , 1);
++    mov_write_string_metadata(s, pb, "soco", "sort_composer"    , 1);
++    mov_write_string_metadata(s, pb, "sosn", "sort_show"        , 1);
++
++    mov_write_string_metadata(s, pb, "\251enc", "encoder"       , 1); // Encoded by
++    mov_write_string_metadata(s, pb, "purd",    "purchase_date" , 1);
++
++    mov_write_int8_metadata  (s, pb, "itnu",    "itunes_u"      , 1);
++    mov_write_int8_metadata  (s, pb, "pcst",    "podcast"       , 1);
++    mov_write_string_metadata(s, pb, "catg",    "category"      , 1);
++
++    mov_write_string_metadata(s, pb, "apID",    "account_id"    , 1);
++    mov_write_int8_metadata  (s, pb, "akID",    "account_type"  , 1);
++    mov_write_int8_metadata  (s, pb, "sfID",    "itunes_country", 4);
++    mov_write_int8_metadata  (s, pb, "cnID",    "content_id"    , 4);
++    mov_write_int8_metadata  (s, pb, "atID",    "artist_id"     , 4);
++    mov_write_int8_metadata  (s, pb, "plID",    "playlist_id"   , 8);
++    mov_write_int8_metadata  (s, pb, "geID",    "genre_id"      , 4);
++    mov_write_int8_metadata  (s, pb, "cmID",    "composer_id"   , 4);
++    mov_write_string_metadata(s, pb, "xid ",    "xid"           , 1);
++
+     mov_write_covr(pb, s);
+     mov_write_trkn_tag(pb, mov, s, 0); // track number
+     mov_write_trkn_tag(pb, mov, s, 1); // disc number
+-- 
+2.39.5 (Apple Git-154)
+
diff -Naupr a/contrib/ffmpeg/A23-avformat-movenc-write-iTunEXTC-and-iTunMOVI-metadata.patch b/contrib/ffmpeg/A23-avformat-movenc-write-iTunEXTC-and-iTunMOVI-metadata.patch
--- a/contrib/ffmpeg/A23-avformat-movenc-write-iTunEXTC-and-iTunMOVI-metadata.patch	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/ffmpeg/A23-avformat-movenc-write-iTunEXTC-and-iTunMOVI-metadata.patch	2025-03-31 11:55:35.193885263 +0200
@@ -0,0 +1,75 @@
+From 2f4b1e3b6818ade62ae19e0abdcefdd50d401ad8 Mon Sep 17 00:00:00 2001
+From: Damiano Galassi <damiog@gmail.com>
+Date: Thu, 13 Feb 2025 09:46:30 +0100
+Subject: [PATCH 2/2] avformat/movenc: write iTunEXTC and iTunMOVI metadata
+
+---
+ libavformat/movenc.c | 45 ++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 45 insertions(+)
+
+diff --git a/libavformat/movenc.c b/libavformat/movenc.c
+index 11df7b0368..c45f15ad77 100644
+--- a/libavformat/movenc.c
++++ b/libavformat/movenc.c
+@@ -4552,6 +4552,48 @@ static int mov_write_trkn_tag(AVIOContext *pb, MOVMuxContext *mov,
+     return size;
+ }
+ 
++/* iTunes iTMF metadata */
++static int mov_write_itmf_tag(AVIOContext *pb, AVFormatContext *s,
++                              const char *name, const char *tag)
++{
++    AVDictionaryEntry *t = av_dict_get(s->metadata, tag, NULL, 0);
++    uint64_t size = 0;
++    if (t) {
++        size_t name_len = strlen(name);
++        size_t value_len = strlen(t->value);
++        size = 8 + 28 + 12 + name_len + 16 + value_len;
++
++        if (size > INT_MAX) {
++            av_log(s, AV_LOG_WARNING,
++                   "Unable to write %s, invalid value len %ld\n",
++                   name, value_len);
++            return 0;
++        }
++
++        avio_wb32(pb, size);           // size
++        ffio_wfourcc(pb, "----");      // type
++
++        avio_wb32(pb, 28);             // size
++        ffio_wfourcc(pb, "mean");      // type
++        avio_wb32(pb, 0);              // version + flags
++        avio_write(pb, "com.apple.iTunes", 16);
++
++        avio_wb32(pb, 12 + name_len);  // size
++        ffio_wfourcc(pb, "name");      // type
++        avio_wb32(pb, 0);              // version + flags
++        avio_write(pb, name, name_len);
++
++        avio_wb32(pb, 16 + value_len); // size
++        ffio_wfourcc(pb, "data");      // type
++        avio_wb16(pb, 0);              // typeReserved
++        avio_w8(pb, 0);                // typeSetIdentifier
++        avio_w8(pb, 1);                // typeCode = UTF-8
++        avio_wb32(pb, 0);              // locale
++        avio_write(pb, t->value, value_len);
++    }
++    return size;
++}
++
+ static int mov_write_int8_metadata(AVFormatContext *s, AVIOContext *pb,
+                                    const char *name, const char *tag,
+                                    int len)
+@@ -4705,6 +4747,9 @@ static int mov_write_ilst_tag(AVIOContext *pb, MOVMuxContext *mov,
+     mov_write_trkn_tag(pb, mov, s, 0); // track number
+     mov_write_trkn_tag(pb, mov, s, 1); // disc number
+     mov_write_tmpo_tag(pb, s);
++    mov_write_itmf_tag(pb, s, "iTunEXTC", "iTunEXTC");
++    mov_write_itmf_tag(pb, s, "iTunMOVI", "iTunMOVI");
++
+     return update_size(pb, pos);
+ }
+ 
+-- 
+2.39.5 (Apple Git-154)
+
diff -Naupr a/contrib/ffmpeg/A24-videotoolbox-speedup-decoding.patch b/contrib/ffmpeg/A24-videotoolbox-speedup-decoding.patch
--- a/contrib/ffmpeg/A24-videotoolbox-speedup-decoding.patch	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/ffmpeg/A24-videotoolbox-speedup-decoding.patch	2025-03-31 11:55:35.193885263 +0200
@@ -0,0 +1,68 @@
+From 1325e2dabe9220f0d24eb0da3c9c98b3f10efc88 Mon Sep 17 00:00:00 2001
+From: Damiano Galassi <damiog@gmail.com>
+Date: Sat, 15 Feb 2025 09:47:36 +0100
+Subject: [PATCH] videotoolbox: speedup decoding
+
+HandBrake doesn't need OpenGL compatibility or CVBuffer attachments, disable both for a minor performance improvement.
+Align buffers to 16 to avoid additional automatic pixel conversions in VTCompressionSession.
+---
+ libavcodec/videotoolbox.c          |  5 +----
+ libavutil/hwcontext_videotoolbox.c | 12 +++++++++++-
+ 2 files changed, 12 insertions(+), 5 deletions(-)
+
+diff --git a/libavcodec/videotoolbox.c b/libavcodec/videotoolbox.c
+index bbb00d2c8a..75fa4c6709 100644
+--- a/libavcodec/videotoolbox.c
++++ b/libavcodec/videotoolbox.c
+@@ -108,9 +108,6 @@ static int videotoolbox_postproc_frame(void *avctx, AVFrame *frame)
+     frame->crop_top = 0;
+     frame->crop_bottom = 0;
+
+-    if ((ret = av_vt_pixbuf_set_attachments(avctx, ref->pixbuf, frame)) < 0)
+-        return ret;
+-
+     frame->data[3] = (uint8_t*)ref->pixbuf;
+
+     if (ref->hw_frames_ctx) {
+@@ -790,7 +787,7 @@ static CFDictionaryRef videotoolbox_buffer_attributes_create(int width,
+ #if TARGET_OS_IPHONE
+     CFDictionarySetValue(buffer_attributes, kCVPixelBufferOpenGLESCompatibilityKey, kCFBooleanTrue);
+ #else
+-    CFDictionarySetValue(buffer_attributes, kCVPixelBufferIOSurfaceOpenGLTextureCompatibilityKey, kCFBooleanTrue);
++    CFDictionarySetValue(buffer_attributes, kCVPixelBufferMetalCompatibilityKey, kCFBooleanTrue);
+ #endif
+
+     CFRelease(io_surface_properties);
+diff --git a/libavutil/hwcontext_videotoolbox.c b/libavutil/hwcontext_videotoolbox.c
+index 122a61d5e7..04e0f0c418 100644
+--- a/libavutil/hwcontext_videotoolbox.c
++++ b/libavutil/hwcontext_videotoolbox.c
+@@ -183,7 +183,8 @@ static int vt_pool_alloc(AVHWFramesContext *ctx)
+     VTFramesContext *fctx = ctx->hwctx;
+     AVVTFramesContext *hw_ctx = &fctx->p;
+     CVReturn err;
+-    CFNumberRef w, h, pixfmt;
++    CFNumberRef w, h, extend_w_num, extend_h_num, pixfmt;
++    int extend_w, extend_h;
+     uint32_t cv_pixfmt;
+     CFMutableDictionaryRef attributes, iosurface_properties;
+
+@@ -216,6 +217,15 @@ static int vt_pool_alloc(AVHWFramesContext *ctx)
+     CFRelease(w);
+     CFRelease(h);
+
++    extend_w = FFALIGN(ctx->width,  16) - ctx->width;
++    extend_h = FFALIGN(ctx->height, 16) - ctx->height;
++    extend_w_num = CFNumberCreate(NULL, kCFNumberSInt32Type, &extend_w);
++    extend_h_num = CFNumberCreate(NULL, kCFNumberSInt32Type, &extend_h);
++    CFDictionarySetValue(attributes, kCVPixelBufferExtendedPixelsRightKey, extend_w_num);
++    CFDictionarySetValue(attributes, kCVPixelBufferExtendedPixelsBottomKey, extend_h_num);
++    CFRelease(extend_w_num);
++    CFRelease(extend_h_num);
++
+     err = CVPixelBufferPoolCreate(
+         NULL,
+         NULL,
+--
+2.39.5 (Apple Git-154)
+
diff -Naupr a/contrib/ffmpeg/A29-Revert-lavc-Check-codec_whitelist-early-in-avcodec_o.patch b/contrib/ffmpeg/A29-Revert-lavc-Check-codec_whitelist-early-in-avcodec_o.patch
--- a/contrib/ffmpeg/A29-Revert-lavc-Check-codec_whitelist-early-in-avcodec_o.patch	2025-02-20 19:37:15.000000000 +0100
+++ b/contrib/ffmpeg/A29-Revert-lavc-Check-codec_whitelist-early-in-avcodec_o.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,47 +0,0 @@
-From 1266d5d35e90619350372b5656fce35114b798cb Mon Sep 17 00:00:00 2001
-From: Sam H <samhutchins@users.noreply.github.com>
-Date: Tue, 12 Nov 2024 19:03:02 +0000
-Subject: [PATCH] Revert "lavc: Check codec_whitelist early in avcodec_open2()"
-
-This reverts commit 7753a9d62725d5bd8313e2d249acbe1c8af79ab1.
----
- libavcodec/avcodec.c | 16 ++++++++--------
- 1 file changed, 8 insertions(+), 8 deletions(-)
-
-diff --git a/libavcodec/avcodec.c b/libavcodec/avcodec.c
-index d1daf47611..d9b0e1246f 100644
---- a/libavcodec/avcodec.c
-+++ b/libavcodec/avcodec.c
-@@ -175,14 +175,6 @@ int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *code
-     if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)
-         return AVERROR(EINVAL);
- 
--    if ((ret = av_opt_set_dict(avctx, options)) < 0)
--        return ret;
--
--    if (avctx->codec_whitelist && av_match_list(codec->name, avctx->codec_whitelist, ',') <= 0) {
--        av_log(avctx, AV_LOG_ERROR, "Codec (%s) not on whitelist \'%s\'\n", codec->name, avctx->codec_whitelist);
--        return AVERROR(EINVAL);
--    }
--
-     avci = av_codec_is_decoder(codec) ?
-         ff_decode_internal_alloc()    :
-         ff_encode_internal_alloc();
-@@ -216,6 +208,14 @@ int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *code
-     } else {
-         avctx->priv_data = NULL;
-     }
-+    if ((ret = av_opt_set_dict(avctx, options)) < 0)
-+        goto free_and_end;
-+
-+    if (avctx->codec_whitelist && av_match_list(codec->name, avctx->codec_whitelist, ',') <= 0) {
-+        av_log(avctx, AV_LOG_ERROR, "Codec (%s) not on whitelist \'%s\'\n", codec->name, avctx->codec_whitelist);
-+        ret = AVERROR(EINVAL);
-+        goto free_and_end;
-+    }
- 
-     // only call ff_set_dimensions() for non H.264/VP6F/DXV codecs so as not to overwrite previously setup dimensions
-     if (!(avctx->coded_width && avctx->coded_height && avctx->width && avctx->height &&
--- 
-2.47.0
-
diff -Naupr a/contrib/ffmpeg/A30-qsv-fixed-BT2020-BT709-conversion.patch b/contrib/ffmpeg/A30-qsv-fixed-BT2020-BT709-conversion.patch
--- a/contrib/ffmpeg/A30-qsv-fixed-BT2020-BT709-conversion.patch	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/ffmpeg/A30-qsv-fixed-BT2020-BT709-conversion.patch	2025-03-31 11:55:35.193885263 +0200
@@ -0,0 +1,29 @@
+From 9ff8a988aeb77fc8501f27e28d924a350d52c8a8 Mon Sep 17 00:00:00 2001
+From: galinart <artem.galin@intel.com>
+Date: Fri, 21 Feb 2025 09:41:34 +0000
+Subject: [PATCH] fixed BT2020 -> BT709 conversion via VPP
+
+---
+ libavfilter/vf_vpp_qsv.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/libavfilter/vf_vpp_qsv.c b/libavfilter/vf_vpp_qsv.c
+index 7f05f1f..223e919 100644
+--- a/libavfilter/vf_vpp_qsv.c
++++ b/libavfilter/vf_vpp_qsv.c
+@@ -494,9 +494,9 @@ static int vpp_set_frame_ext_params(AVFilterContext *ctx, const AVFrame *in, AVF
+     outvsi_conf.Header.BufferId          = MFX_EXTBUFF_VIDEO_SIGNAL_INFO_OUT;
+     outvsi_conf.Header.BufferSz          = sizeof(mfxExtVideoSignalInfo);
+     outvsi_conf.VideoFullRange           = (out->color_range == AVCOL_RANGE_JPEG);
+-    outvsi_conf.ColourPrimaries          = (out->color_primaries == AVCOL_PRI_UNSPECIFIED) ? AVCOL_PRI_BT709 : out->color_primaries;
+-    outvsi_conf.TransferCharacteristics  = (out->color_trc == AVCOL_TRC_UNSPECIFIED) ? AVCOL_TRC_BT709 : out->color_trc;
+-    outvsi_conf.MatrixCoefficients       = (out->colorspace == AVCOL_SPC_UNSPECIFIED) ? AVCOL_SPC_BT709 : out->colorspace;
++    outvsi_conf.ColourPrimaries          = (out->color_primaries == AVCOL_PRI_UNSPECIFIED) ? invsi_conf.ColourPrimaries : out->color_primaries;
++    outvsi_conf.TransferCharacteristics  = (out->color_trc == AVCOL_TRC_UNSPECIFIED) ? invsi_conf.TransferCharacteristics : out->color_trc;
++    outvsi_conf.MatrixCoefficients       = (out->colorspace == AVCOL_SPC_UNSPECIFIED) ? invsi_conf.MatrixCoefficients : out->colorspace;
+     outvsi_conf.ColourDescriptionPresent = 1;
+ 
+     if (memcmp(&vpp->invsi_conf, &invsi_conf, sizeof(mfxExtVideoSignalInfo)) ||
+-- 
+2.25.1
+
diff -Naupr a/contrib/ffmpeg/module.defs b/contrib/ffmpeg/module.defs
--- a/contrib/ffmpeg/module.defs	2025-02-20 19:37:15.000000000 +0100
+++ b/contrib/ffmpeg/module.defs	2025-03-31 11:55:35.193885263 +0200
@@ -12,9 +12,9 @@ endif
 $(eval $(call import.MODULE.defs,FFMPEG,ffmpeg,$(__deps__)))
 $(eval $(call import.CONTRIB.defs,FFMPEG))
 
-FFMPEG.FETCH.url    = https://github.com/HandBrake/HandBrake-contribs/releases/download/contribs2/ffmpeg-7.1.tar.bz2
-FFMPEG.FETCH.url   += https://ffmpeg.org/releases/ffmpeg-7.1.tar.bz2
-FFMPEG.FETCH.sha256 = fd59e6160476095082e94150ada5a6032d7dcc282fe38ce682a00c18e7820528
+FFMPEG.FETCH.url    = https://github.com/HandBrake/HandBrake-contribs/releases/download/contribs2/ffmpeg-7.1.1.tar.bz2
+FFMPEG.FETCH.url   += https://ffmpeg.org/releases/ffmpeg-7.1.1.tar.bz2
+FFMPEG.FETCH.sha256 = 0c8da2f11579a01e014fc007cbacf5bb4da1d06afd0b43c7f8097ec7c0f143ba
 
 FFMPEG.GCC.args.c_std =
 
@@ -45,6 +45,8 @@ FFMPEG.CONFIGURE.extra = \
     --enable-encoder=mpeg2video \
     --enable-encoder=mpeg4 \
     --enable-encoder=libmp3lame \
+    --enable-encoder=movtext \
+    --enable-encoder=subrip \
     --enable-libopus \
     --enable-encoder=libopus \
     --enable-libspeex \
@@ -109,7 +111,10 @@ FFMPEG.CONFIGURE.extra += \
     --enable-muxer=mov \
     --enable-muxer=mp4 \
     --enable-muxer=psp \
-    --enable-muxer=ipod
+    --enable-muxer=ipod \
+    --enable-muxer=ass \
+    --enable-muxer=srt \
+    --enable-muxer=sup
 
 ifeq (darwin,$(HOST.system))
     FFMPEG.CONFIGURE.extra += --disable-audiotoolbox --disable-coreimage --enable-hwaccel=h264_videotoolbox --enable-hwaccel=hevc_videotoolbox --enable-hwaccel=prores_videotoolbox
@@ -167,6 +172,9 @@ endif
 ifeq (1,$(FEATURE.qsv))
   FFMPEG.CONFIGURE.extra += --enable-libvpl
   FFMPEG.CONFIGURE.extra += --enable-filter=vpp_qsv
+  FFMPEG.CONFIGURE.extra += --enable-encoder=hevc_qsv
+  FFMPEG.CONFIGURE.extra += --enable-encoder=h264_qsv
+  FFMPEG.CONFIGURE.extra += --enable-encoder=av1_qsv
 endif
 
 ifeq (1,$(FEATURE.vce))
diff -Naupr a/contrib/harfbuzz/module.defs b/contrib/harfbuzz/module.defs
--- a/contrib/harfbuzz/module.defs	2025-02-20 19:37:15.000000000 +0100
+++ b/contrib/harfbuzz/module.defs	2025-03-31 11:55:35.193885263 +0200
@@ -3,9 +3,9 @@ __deps__ := FREETYPE
 $(eval $(call import.MODULE.defs,HARFBUZZ,harfbuzz,$(__deps__)))
 $(eval $(call import.CONTRIB.defs,HARFBUZZ))
 
-HARFBUZZ.FETCH.url     = https://github.com/HandBrake/HandBrake-contribs/releases/download/contribs2/harfbuzz-10.2.0.tar.xz
-HARFBUZZ.FETCH.url    += https://github.com/harfbuzz/harfbuzz/releases/download/10.2.0/harfbuzz-10.2.0.tar.xz
-HARFBUZZ.FETCH.sha256  = 620e3468faec2ea8685d32c46a58469b850ef63040b3565cde05959825b48227
+HARFBUZZ.FETCH.url     = https://github.com/HandBrake/HandBrake-contribs/releases/download/contribs2/harfbuzz-10.4.0.tar.xz
+HARFBUZZ.FETCH.url    += https://github.com/harfbuzz/harfbuzz/releases/download/10.4.0/harfbuzz-10.4.0.tar.xz
+HARFBUZZ.FETCH.sha256  = 480b6d25014169300669aa1fc39fb356c142d5028324ea52b3a27648b9beaad8
 
 HARFBUZZ.build_dir             = build
 HARFBUZZ.CONFIGURE.exe         = cmake
diff -Naupr a/contrib/libdovi/A01-RpuDataNlq.patch b/contrib/libdovi/A01-RpuDataNlq.patch
--- a/contrib/libdovi/A01-RpuDataNlq.patch	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/libdovi/A01-RpuDataNlq.patch	2025-03-31 11:55:35.194885246 +0200
@@ -0,0 +1,57 @@
+From fd624d6b1bda6b6f2ccb30ca960439dbe0375b7f Mon Sep 17 00:00:00 2001
+From: quietvoid <tcChlisop0@gmail.com>
+Date: Tue, 18 Mar 2025 18:30:13 -0400
+Subject: [PATCH] Fix incorrect value written in RpuDataNlq
+
+Bug present since #1
+---
+ dolby_vision/src/rpu/rpu_data_nlq.rs | 32 +++++++++++++++++++++++++++-
+ 1 file changed, 31 insertions(+), 1 deletion(-)
+
+diff --git a/dolby_vision/src/rpu/rpu_data_nlq.rs b/dolby_vision/src/rpu/rpu_data_nlq.rs
+index bfc1d4c..5b63f93 100644
+--- a/dolby_vision/src/rpu/rpu_data_nlq.rs
++++ b/dolby_vision/src/rpu/rpu_data_nlq.rs
+@@ -137,7 +137,7 @@ impl RpuDataNlq {
+                     )?;
+ 
+                     if header.coefficient_data_type == 0 {
+-                        writer.write_ue(&self.linear_deadzone_slope_int[cmp])?;
++                        writer.write_ue(&self.linear_deadzone_threshold_int[cmp])?;
+                     }
+ 
+                     writer.write_n(
+@@ -207,3 +207,33 @@ impl Display for DoviELType {
+         f.write_str(self.as_str())
+     }
+ }
++
++#[cfg(test)]
++mod tests {
++    use anyhow::Result;
++
++    use crate::rpu::{dovi_rpu::DoviRpu, generate::GenerateConfig};
++
++    #[test]
++    fn write_linear_dz_threshold() -> Result<()> {
++        let mut rpu = DoviRpu::profile81_config(&GenerateConfig::default())?;
++        rpu.convert_with_mode(1)?;
++
++        {
++            let nlq = rpu
++                .rpu_data_mapping
++                .as_mut()
++                .and_then(|rpu_data_mapping| rpu_data_mapping.nlq.as_mut())
++                .unwrap();
++            nlq.linear_deadzone_threshold_int = [1, 2, 3];
++        }
++
++        let out = rpu.write_rpu()?;
++        let rpu = DoviRpu::parse(&out)?;
++
++        let nlq = rpu.rpu_data_mapping.and_then(|e| e.nlq).unwrap();
++        assert_eq!(nlq.linear_deadzone_threshold_int, [1, 2, 3]);
++
++        Ok(())
++    }
++}
diff -Naupr a/contrib/libjpeg-turbo/module.defs b/contrib/libjpeg-turbo/module.defs
--- a/contrib/libjpeg-turbo/module.defs	2025-02-20 19:37:15.000000000 +0100
+++ b/contrib/libjpeg-turbo/module.defs	2025-03-31 13:14:17.722692235 +0200
@@ -11,7 +11,7 @@ LIBJPEGTURBO.CONFIGURE.args.prefix = -DC
 LIBJPEGTURBO.CONFIGURE.deps        =
 LIBJPEGTURBO.CONFIGURE.static      =
 LIBJPEGTURBO.CONFIGURE.shared      = -DENABLE_SHARED=OFF
-LIBJPEGTURBO.CONFIGURE.extra       = -DCMAKE_INSTALL_LIBDIR=lib
+LIBJPEGTURBO.CONFIGURE.extra       = -DCMAKE_INSTALL_LIBDIR=lib -DCMAKE_POLICY_VERSION_MINIMUM=3.5
 
 ifeq (size-aggressive,$(GCC.O))
     LIBJPEGTURBO.CONFIGURE.extra += -DCMAKE_CXX_FLAGS_MINSIZEREL="-Oz -DNDEBUG" -DCMAKE_C_FLAGS_MINSIZEREL="-Oz -DNDEBUG"
diff -Naupr a/contrib/libvpl/module.defs b/contrib/libvpl/module.defs
--- a/contrib/libvpl/module.defs	2025-02-20 19:37:15.000000000 +0100
+++ b/contrib/libvpl/module.defs	2025-03-31 13:14:26.163547688 +0200
@@ -1,11 +1,11 @@
 $(eval $(call import.MODULE.defs,LIBVPL,libvpl))
 $(eval $(call import.CONTRIB.defs,LIBVPL))
 
-LIBVPL.FETCH.url       = https://github.com/intel/libvpl/archive/refs/tags/v2.13.0.tar.gz
-LIBVPL.FETCH.url      += https://github.com/HandBrake/HandBrake-contribs/releases/download/contribs2/libvpl-2.13.0.tar.gz
-LIBVPL.FETCH.sha256    = 1c740e2b58f7853f56b618bdb7d4a7e5d37f8c1a9b30105a0b79ba80873e1cbd
-LIBVPL.FETCH.basename  = libvpl-2.13.0.tar.gz
-LIBVPL.EXTRACT.tarbase = libvpl-2.13.0
+LIBVPL.FETCH.url       = https://github.com/intel/libvpl/archive/refs/tags/v2.14.0.tar.gz
+LIBVPL.FETCH.url      += https://github.com/HandBrake/HandBrake-contribs/releases/download/contribs2/libvpl-2.14.0.tar.gz
+LIBVPL.FETCH.sha256    = 7c6bff1c1708d910032c2e6c44998ffff3f5fdbf06b00972bc48bf2dd9e5ac06
+LIBVPL.FETCH.basename  = libvpl-2.14.0.tar.gz
+LIBVPL.EXTRACT.tarbase = libvpl-2.14.0
 
 LIBVPL.build_dir             = build
 LIBVPL.CONFIGURE.exe         = cmake
@@ -15,7 +15,7 @@ LIBVPL.CONFIGURE.args.prefix = -DCMAKE_I
 LIBVPL.CONFIGURE.deps        =
 LIBVPL.CONFIGURE.static      =
 LIBVPL.CONFIGURE.shared      = -DBUILD_SHARED_LIBS=OFF
-LIBVPL.CONFIGURE.extra       = -DBUILD_EXPERIMENTAL=ON -DBUILD_TOOLS=OFF -DBUILD_EXAMPLES=OFF
+LIBVPL.CONFIGURE.extra       = -DBUILD_EXPERIMENTAL=ON -DBUILD_TOOLS=OFF -DBUILD_EXAMPLES=OFF -DCMAKE_POLICY_VERSION_MINIMUM=3.5
 
 ifeq ($(GCC.O),$(filter $(GCC.O),size size-aggressive))
     LIBVPL.CONFIGURE.extra += -DCMAKE_BUILD_TYPE=MinSizeRel
diff -Naupr a/contrib/nvenc/module.defs b/contrib/nvenc/module.defs
--- a/contrib/nvenc/module.defs	2025-02-20 19:37:15.000000000 +0100
+++ b/contrib/nvenc/module.defs	2025-03-31 11:55:35.195885228 +0200
@@ -1,10 +1,9 @@
 $(eval $(call import.MODULE.defs,NVENC,nvenc))
 $(eval $(call import.CONTRIB.defs,NVENC))
 
-NVENC.FETCH.url      = https://github.com/HandBrake/HandBrake-contribs/releases/download/contribs2/nv-codec-headers-12.2.72.0.tar.gz
-NVENC.FETCH.url     += https://github.com/FFmpeg/nv-codec-headers/releases/download/n12.2.72.0/nv-codec-headers-12.2.72.0.tar.gz
-
-NVENC.FETCH.sha256   = c295a2ba8a06434d4bdc5c2208f8a825285210d71d91d572329b2c51fd0d4d03
+NVENC.FETCH.url      = https://github.com/HandBrake/HandBrake-contribs/releases/download/contribs2/nv-codec-headers-13.0.19.0.tar.gz
+NVENC.FETCH.url     += https://github.com/FFmpeg/nv-codec-headers/releases/download/n13.0.19.0/nv-codec-headers-13.0.19.0.tar.gz
+NVENC.FETCH.sha256   = 13da39edb3a40ed9713ae390ca89faa2f1202c9dda869ef306a8d4383e242bee
 
 NVENC.CONFIGURE = $(TOUCH.exe) $@
 NVENC.BUILD.extra = PREFIX="$(NVENC.CONFIGURE.prefix)"
diff -Naupr a/contrib/sse2neon/module.defs b/contrib/sse2neon/module.defs
--- a/contrib/sse2neon/module.defs	2025-02-20 19:37:15.000000000 +0100
+++ b/contrib/sse2neon/module.defs	2025-03-31 11:55:35.195885228 +0200
@@ -1,11 +1,11 @@
 $(eval $(call import.MODULE.defs,SSE2NEON,sse2neon))
 $(eval $(call import.CONTRIB.defs,SSE2NEON))
 
-SSE2NEON.FETCH.url       = https://github.com/HandBrake/HandBrake-contribs/releases/download/contribs/sse2neon-1.7.0.tar.gz
-SSE2NEON.FETCH.url      += https://github.com/DLTcollab/sse2neon/archive/refs/tags/v1.7.0.tar.gz
-SSE2NEON.FETCH.sha256    = cee6d54922dbc9d4fa57749e3e4b46161b7f435a22e592db9da008051806812a
-SSE2NEON.FETCH.basename  = sse2neon-1.7.0.tar.gz
-SSE2NEON.EXTRACT.tarbase = sse2neon-1.7.0
+SSE2NEON.FETCH.url       = https://github.com/HandBrake/HandBrake-contribs/releases/download/contribs2/sse2neon-1.8.0.tar.gz
+SSE2NEON.FETCH.url      += https://github.com/DLTcollab/sse2neon/archive/refs/tags/v1.8.0.tar.gz
+SSE2NEON.FETCH.sha256    = e251746e3b761f3f0de1ad462b1efe53532341b6b0498d394765fceb85ce8a46
+SSE2NEON.FETCH.basename  = sse2neon-1.8.0.tar.gz
+SSE2NEON.EXTRACT.tarbase = sse2neon-1.8.0
 
 SSE2NEON.CONFIGURE = $(TOUCH.exe) $@
 SSE2NEON.BUILD     = $(TOUCH.exe) $@
diff -Naupr a/contrib/svt-av1/A01-Enable-Neon-DotProd-and-I8MM-on-Windows.patch b/contrib/svt-av1/A01-Enable-Neon-DotProd-and-I8MM-on-Windows.patch
--- a/contrib/svt-av1/A01-Enable-Neon-DotProd-and-I8MM-on-Windows.patch	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/svt-av1/A01-Enable-Neon-DotProd-and-I8MM-on-Windows.patch	2025-03-31 11:55:35.195885228 +0200
@@ -0,0 +1,73 @@
+From e9bc4fa0d8229abd46df1ada8a1253ceea60aee1 Mon Sep 17 00:00:00 2001
+From: Dash Santosh <dash.sathyanarayanan@multicorewareinc.com>
+Date: Thu, 19 Dec 2024 03:46:56 -0800
+Subject: [PATCH] Enable Neon DotProd and I8MM in SVT-AV1 for Windows On ARM
+
+---
+ Source/Lib/Codec/common_dsp_rtcd.c | 43 ++++++++++++++++++++++++++++--
+ 1 file changed, 41 insertions(+), 2 deletions(-)
+
+diff --git a/Source/Lib/Codec/common_dsp_rtcd.c b/Source/Lib/Codec/common_dsp_rtcd.c
+index da4070d7..a253630c 100644
+--- a/Source/Lib/Codec/common_dsp_rtcd.c
++++ b/Source/Lib/Codec/common_dsp_rtcd.c
+@@ -219,7 +219,41 @@ EbCpuFlags svt_aom_get_cpu_flags(void) {
+   return flags;
+ }
+ 
+-#elif defined(_MSC_VER)  // end __APPLE__
++#elif (defined(_MSC_VER) || defined(__MINGW64__)) // Windows+Aarch64
++#include <windows.h>
++
++DWORD get_number_of_cores()
++{
++    SYSTEM_INFO sys_info;
++    GetSystemInfo(&sys_info);
++    return sys_info.dwNumberOfProcessors;
++}
++int check_i8mm_regkey()
++{
++    HKEY hKey;
++    DWORD dwSize = (DWORD)sizeof(LONGLONG);
++    LONGLONG value = 0;
++    UINT NumOfCPUs = get_number_of_cores();
++    int i8mmAvailable = 0;
++    WCHAR keyPath[256];
++    for (UINT i = 0; i < NumOfCPUs; i++)
++    {
++        swprintf_s(keyPath, 256, L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\%d", i);
++        long lError = RegOpenKeyExW(HKEY_LOCAL_MACHINE, keyPath, 0, KEY_READ, &hKey);
++        if (lError == ERROR_SUCCESS) 
++        {
++            lError = RegQueryValueExA(hKey, "CP 4031", NULL, NULL, (LPBYTE)&value, &dwSize);
++            i8mmAvailable = (int)((value >> 52) & 0x1);
++            if (!i8mmAvailable) {
++                break;
++            }
++        } 
++        else {
++            return 0;
++        }
++    }
++    return i8mmAvailable;
++}
+ 
+ // IsProcessorFeaturePresent() parameter documentation:
+ // https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-isprocessorfeaturepresent#parameters
+@@ -239,7 +273,12 @@ EbCpuFlags svt_aom_get_cpu_flags(void) {
+   }
+ #endif  // defined(PF_ARM_V82_DP_INSTRUCTIONS_AVAILABLE)
+ #endif  // HAVE_NEON_DOTPROD
+-// No I8MM or SVE feature detection available on Windows at time of writing.
++#if HAVE_NEON_I8MM
++    if (check_i8mm_regkey())
++       {
++            flags |= EB_CPU_FLAGS_NEON_I8MM;
++       }
++#endif  // HAVE_NEON_I8MM
+   return flags;
+ }
+ 
+-- 
+2.34.1
+
diff -Naupr a/contrib/svt-av1/module.defs b/contrib/svt-av1/module.defs
--- a/contrib/svt-av1/module.defs	2025-02-20 19:37:15.000000000 +0100
+++ b/contrib/svt-av1/module.defs	2025-03-31 12:14:12.040574541 +0200
@@ -1,9 +1,11 @@
-$(eval $(call import.MODULE.defs,SVT-AV1,svt-av1))
+__deps__ := CPUINFO
+
+$(eval $(call import.MODULE.defs,SVT-AV1,svt-av1,$(__deps__)))
 $(eval $(call import.CONTRIB.defs,SVT-AV1))
 
-SVT-AV1.FETCH.url     = https://github.com/HandBrake/HandBrake-contribs/releases/download/contribs2/SVT-AV1-v2.3.0.tar.gz
-SVT-AV1.FETCH.url    += https://gitlab.com/AOMediaCodec/SVT-AV1/-/archive/v2.3.0/SVT-AV1-v2.3.0.tar.gz
-SVT-AV1.FETCH.sha256  = ebb0b484ef4a0dc281e94342a9f73ad458496f5d3457eca7465bec943910c6c3
+SVT-AV1.FETCH.url     = https://github.com/HandBrake/HandBrake-contribs/releases/download/contribs2/SVT-AV1-v3.0.2.tar.gz
+SVT-AV1.FETCH.url    += https://gitlab.com/AOMediaCodec/SVT-AV1/-/archive/v3.0.2/SVT-AV1-v3.0.2.tar.gz
+SVT-AV1.FETCH.sha256  = 5af7f4376aa00a4dee32df04be1cdd1983c9940bcc019ee6b29bb8a216bae2f8
 
 SVT-AV1.GCC.args.c_std =
 
@@ -14,7 +16,7 @@ SVT-AV1.CONFIGURE.deps        =
 SVT-AV1.CONFIGURE.static      =
 SVT-AV1.CONFIGURE.shared      = -DBUILD_SHARED_LIBS=OFF
 SVT-AV1.CONFIGURE.extra       = -DBUILD_APPS=OFF -DREPRODUCIBLE_BUILDS=ON
-SVT-AV1.CONFIGURE.extra      += -DCMAKE_INSTALL_LIBDIR=lib
+SVT-AV1.CONFIGURE.extra      += -DCMAKE_INSTALL_LIBDIR=lib -DCMAKE_POLICY_VERSION_MINIMUM=3.5
 
 ifeq ($(GCC.O),$(filter $(GCC.O),size size-aggressive))
     SVT-AV1.CONFIGURE.extra += -DCMAKE_BUILD_TYPE=MinSizeRel -DMINIMAL_BUILD=ON
diff -Naupr a/contrib/x265/A08-cmake.patch b/contrib/x265/A08-cmake.patch
--- a/contrib/x265/A08-cmake.patch	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/x265/A08-cmake.patch	2025-03-31 13:47:23.638616451 +0200
@@ -0,0 +1,19 @@
+diff -Naupr a/source/CMakeLists.txt b/source/CMakeLists.txt
+--- a/source/CMakeLists.txt	2024-11-22 13:07:34.000000000 +0100
++++ b/source/CMakeLists.txt	2025-03-31 13:47:02.835976566 +0200
+@@ -6,15 +6,6 @@ if(NOT CMAKE_BUILD_TYPE)
+         FORCE)
+ endif()
+ message(STATUS "cmake version ${CMAKE_VERSION}")
+-if(POLICY CMP0025)
+-    cmake_policy(SET CMP0025 OLD) # report Apple's Clang as just Clang
+-endif()
+-if(POLICY CMP0042)
+-    cmake_policy(SET CMP0042 NEW) # MACOSX_RPATH
+-endif()
+-if(POLICY CMP0054)
+-    cmake_policy(SET CMP0054 OLD) # Only interpret if() arguments as variables or keywords when unquoted
+-endif()
+ 
+ project (x265)
+ cmake_minimum_required (VERSION 2.8.8) # OBJECT libraries require 2.8.8
diff -Naupr a/contrib/x265_10bit/A08-cmake.patch b/contrib/x265_10bit/A08-cmake.patch
--- a/contrib/x265_10bit/A08-cmake.patch	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/x265_10bit/A08-cmake.patch	2025-03-31 13:47:23.638616451 +0200
@@ -0,0 +1,19 @@
+diff -Naupr a/source/CMakeLists.txt b/source/CMakeLists.txt
+--- a/source/CMakeLists.txt	2024-11-22 13:07:34.000000000 +0100
++++ b/source/CMakeLists.txt	2025-03-31 13:47:02.835976566 +0200
+@@ -6,15 +6,6 @@ if(NOT CMAKE_BUILD_TYPE)
+         FORCE)
+ endif()
+ message(STATUS "cmake version ${CMAKE_VERSION}")
+-if(POLICY CMP0025)
+-    cmake_policy(SET CMP0025 OLD) # report Apple's Clang as just Clang
+-endif()
+-if(POLICY CMP0042)
+-    cmake_policy(SET CMP0042 NEW) # MACOSX_RPATH
+-endif()
+-if(POLICY CMP0054)
+-    cmake_policy(SET CMP0054 OLD) # Only interpret if() arguments as variables or keywords when unquoted
+-endif()
+ 
+ project (x265)
+ cmake_minimum_required (VERSION 2.8.8) # OBJECT libraries require 2.8.8
diff -Naupr a/contrib/x265_10bit/module.defs b/contrib/x265_10bit/module.defs
--- a/contrib/x265_10bit/module.defs	2025-02-20 19:37:15.000000000 +0100
+++ b/contrib/x265_10bit/module.defs	2025-03-31 12:12:54.617913990 +0200
@@ -16,7 +16,7 @@ X265_10.CONFIGURE.args.host   = -DCMAKE_
 X265_10.CONFIGURE.deps        =
 X265_10.CONFIGURE.static      =
 X265_10.CONFIGURE.shared      = -DENABLE_SHARED=OFF
-X265_10.CONFIGURE.extra       = -DENABLE_CLI=OFF -DHIGH_BIT_DEPTH=ON -DEXPORT_C_API=OFF -DCMAKE_ASM_NASM_FLAGS=-w-macro-params-legacy
+X265_10.CONFIGURE.extra       = -DENABLE_CLI=OFF -DHIGH_BIT_DEPTH=ON -DEXPORT_C_API=OFF -DCMAKE_ASM_NASM_FLAGS=-w-macro-params-legacy -DCMAKE_POLICY_VERSION_MINIMUM=3.5
 
 ifneq (1,$(FEATURE.numa))
     X265_10.CONFIGURE.extra  += -DENABLE_LIBNUMA=OFF
diff -Naupr a/contrib/x265_12bit/A08-cmake.patch b/contrib/x265_12bit/A08-cmake.patch
--- a/contrib/x265_12bit/A08-cmake.patch	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/x265_12bit/A08-cmake.patch	2025-03-31 13:47:23.638616451 +0200
@@ -0,0 +1,19 @@
+diff -Naupr a/source/CMakeLists.txt b/source/CMakeLists.txt
+--- a/source/CMakeLists.txt	2024-11-22 13:07:34.000000000 +0100
++++ b/source/CMakeLists.txt	2025-03-31 13:47:02.835976566 +0200
+@@ -6,15 +6,6 @@ if(NOT CMAKE_BUILD_TYPE)
+         FORCE)
+ endif()
+ message(STATUS "cmake version ${CMAKE_VERSION}")
+-if(POLICY CMP0025)
+-    cmake_policy(SET CMP0025 OLD) # report Apple's Clang as just Clang
+-endif()
+-if(POLICY CMP0042)
+-    cmake_policy(SET CMP0042 NEW) # MACOSX_RPATH
+-endif()
+-if(POLICY CMP0054)
+-    cmake_policy(SET CMP0054 OLD) # Only interpret if() arguments as variables or keywords when unquoted
+-endif()
+ 
+ project (x265)
+ cmake_minimum_required (VERSION 2.8.8) # OBJECT libraries require 2.8.8
diff -Naupr a/contrib/x265_12bit/module.defs b/contrib/x265_12bit/module.defs
--- a/contrib/x265_12bit/module.defs	2025-02-20 19:37:15.000000000 +0100
+++ b/contrib/x265_12bit/module.defs	2025-03-31 12:12:47.666034252 +0200
@@ -16,7 +16,7 @@ X265_12.CONFIGURE.args.host   = -DCMAKE_
 X265_12.CONFIGURE.deps        =
 X265_12.CONFIGURE.static      =
 X265_12.CONFIGURE.shared      = -DENABLE_SHARED=OFF
-X265_12.CONFIGURE.extra       = -DENABLE_CLI=OFF -DHIGH_BIT_DEPTH=ON -DEXPORT_C_API=OFF -DMAIN12=ON -DCMAKE_ASM_NASM_FLAGS=-w-macro-params-legacy
+X265_12.CONFIGURE.extra       = -DENABLE_CLI=OFF -DHIGH_BIT_DEPTH=ON -DEXPORT_C_API=OFF -DMAIN12=ON -DCMAKE_ASM_NASM_FLAGS=-w-macro-params-legacy -DCMAKE_POLICY_VERSION_MINIMUM=3.5
 
 ifneq (1,$(FEATURE.numa))
     X265_12.CONFIGURE.extra  += -DENABLE_LIBNUMA=OFF
diff -Naupr a/contrib/x265_8bit/A08-cmake.patch b/contrib/x265_8bit/A08-cmake.patch
--- a/contrib/x265_8bit/A08-cmake.patch	1970-01-01 01:00:00.000000000 +0100
+++ b/contrib/x265_8bit/A08-cmake.patch	2025-03-31 13:47:23.638616451 +0200
@@ -0,0 +1,19 @@
+diff -Naupr a/source/CMakeLists.txt b/source/CMakeLists.txt
+--- a/source/CMakeLists.txt	2024-11-22 13:07:34.000000000 +0100
++++ b/source/CMakeLists.txt	2025-03-31 13:47:02.835976566 +0200
+@@ -6,15 +6,6 @@ if(NOT CMAKE_BUILD_TYPE)
+         FORCE)
+ endif()
+ message(STATUS "cmake version ${CMAKE_VERSION}")
+-if(POLICY CMP0025)
+-    cmake_policy(SET CMP0025 OLD) # report Apple's Clang as just Clang
+-endif()
+-if(POLICY CMP0042)
+-    cmake_policy(SET CMP0042 NEW) # MACOSX_RPATH
+-endif()
+-if(POLICY CMP0054)
+-    cmake_policy(SET CMP0054 OLD) # Only interpret if() arguments as variables or keywords when unquoted
+-endif()
+ 
+ project (x265)
+ cmake_minimum_required (VERSION 2.8.8) # OBJECT libraries require 2.8.8
diff -Naupr a/contrib/x265_8bit/module.defs b/contrib/x265_8bit/module.defs
--- a/contrib/x265_8bit/module.defs	2025-02-20 19:37:15.000000000 +0100
+++ b/contrib/x265_8bit/module.defs	2025-03-31 13:25:49.436883748 +0200
@@ -13,7 +13,7 @@ X265_8.CONFIGURE.args.host   = -DCMAKE_H
 X265_8.CONFIGURE.deps        =
 X265_8.CONFIGURE.static      =
 X265_8.CONFIGURE.shared      = -DENABLE_SHARED=OFF
-X265_8.CONFIGURE.extra       = -DENABLE_CLI=OFF -DHIGH_BIT_DEPTH=OFF -DEXTRA_LIB="x265_main10.a;x265_main12.a" -DEXTRA_LINK_FLAGS=-L. -DLINKED_10BIT=ON -DLINKED_12BIT=ON -DCMAKE_ASM_NASM_FLAGS=-w-macro-params-legacy
+X265_8.CONFIGURE.extra       = -DENABLE_CLI=OFF -DHIGH_BIT_DEPTH=OFF -DEXTRA_LIB="x265_main10.a;x265_main12.a" -DEXTRA_LINK_FLAGS=-L. -DLINKED_10BIT=ON -DLINKED_12BIT=ON -DCMAKE_ASM_NASM_FLAGS=-w-macro-params-legacy -DCMAKE_POLICY_VERSION_MINIMUM=3.5 -DCMAKE_POLICY_DEFAULT_CMP0025=NEW -DCMAKE_POLICY_DEFAULT_CMP0054=NEW -DCMAKE_POLICY_RELAXED=ON
 
 ifneq (1,$(FEATURE.numa))
     X265_8.CONFIGURE.extra  += -DENABLE_LIBNUMA=OFF
diff -Naupr a/gtk/data/fr.handbrake.ghb.metainfo.xml.in.in b/gtk/data/fr.handbrake.ghb.metainfo.xml.in.in
--- a/gtk/data/fr.handbrake.ghb.metainfo.xml.in.in	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/data/fr.handbrake.ghb.metainfo.xml.in.in	2025-03-31 11:55:35.215884882 +0200
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<!-- Copyright 2018-2024 John Stebbins <your@email.com> -->
+<!-- Copyright 2018-2025 John Stebbins <your@email.com> -->
 <component type="desktop-application">
   <id>fr.handbrake.ghb</id>
   <translation type="gettext">ghb</translation>
diff -Naupr a/gtk/data/meson.build b/gtk/data/meson.build
--- a/gtk/data/meson.build	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/data/meson.build	2025-03-31 11:55:35.215884882 +0200
@@ -1,4 +1,4 @@
-# Copyright (C) 2023-2024 HandBrake Team
+# Copyright (C) 2023-2025 HandBrake Team
 # SPDX-License-Identifier: GPL-2.0-or-later
 
 data = gnome.compile_resources('data_res', 'data_res.gresource.xml',
diff -Naupr a/gtk/icons/meson.build b/gtk/icons/meson.build
--- a/gtk/icons/meson.build	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/icons/meson.build	2025-03-31 11:55:35.216884864 +0200
@@ -1,4 +1,4 @@
-# Copyright (C) 2023-2024 HandBrake Team
+# Copyright (C) 2023-2025 HandBrake Team
 # SPDX-License-Identifier: GPL-2.0-or-later
 
 icons = gnome.compile_resources('icon_res', 'icon_res.gresource.xml',
diff -Naupr a/gtk/meson.build b/gtk/meson.build
--- a/gtk/meson.build	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/meson.build	2025-03-31 11:55:35.220884795 +0200
@@ -40,6 +40,7 @@ ghb_deps = [
   dependency('libavformat'),
   dependency('libavutil'),
   dependency('libbluray'),
+  dependency('libcpuinfo'),
   dependency('libswresample'),
   dependency('libswscale'),
   dependency('libturbojpeg'),
diff -Naupr a/gtk/po/af.po b/gtk/po/af.po
--- a/gtk/po/af.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/af.po	2025-03-31 11:55:35.221884778 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/bg.po b/gtk/po/bg.po
--- a/gtk/po/bg.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/bg.po	2025-03-31 11:55:35.222884761 +0200
@@ -1,11 +1,11 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
 # Translators:
-# inncharge, 2024
 # Minona, 2024
+# inncharge, 2025
 # 
 #, fuzzy
 msgid ""
@@ -14,7 +14,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
-"Last-Translator: Minona, 2024\n"
+"Last-Translator: inncharge, 2025\n"
 "Language-Team: Bulgarian (https://app.transifex.com/HandBrakeProject/teams/92423/bg/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
diff -Naupr a/gtk/po/ca.po b/gtk/po/ca.po
--- a/gtk/po/ca.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/ca.po	2025-03-31 11:55:35.222884761 +0200
@@ -1,10 +1,10 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
 # Translators:
-# Pere Orga <pere@orga.cat>, 2024
+# Pere Orga <pere@orga.cat>, 2025
 # 
 #, fuzzy
 msgid ""
@@ -13,7 +13,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
-"Last-Translator: Pere Orga <pere@orga.cat>, 2024\n"
+"Last-Translator: Pere Orga <pere@orga.cat>, 2025\n"
 "Language-Team: Catalan (https://app.transifex.com/HandBrakeProject/teams/92423/ca/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
diff -Naupr a/gtk/po/co.po b/gtk/po/co.po
--- a/gtk/po/co.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/co.po	2025-03-31 11:55:35.222884761 +0200
@@ -1,10 +1,10 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
 # Translators:
-# Patriccollu di Santa Maria  Sich <Patrick.Santa-Maria@laposte.net>, 2024
+# Patriccollu di Santa Maria  Sich <Patrick.Santa-Maria@laposte.net>, 2025
 # 
 #, fuzzy
 msgid ""
@@ -13,7 +13,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
-"Last-Translator: Patriccollu di Santa Maria  Sich <Patrick.Santa-Maria@laposte.net>, 2024\n"
+"Last-Translator: Patriccollu di Santa Maria  Sich <Patrick.Santa-Maria@laposte.net>, 2025\n"
 "Language-Team: Corsican (https://app.transifex.com/HandBrakeProject/teams/92423/co/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
diff -Naupr a/gtk/po/cs.po b/gtk/po/cs.po
--- a/gtk/po/cs.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/cs.po	2025-03-31 11:55:35.222884761 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/de.po b/gtk/po/de.po
--- a/gtk/po/de.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/de.po	2025-03-31 11:55:35.224884726 +0200
@@ -1,10 +1,10 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
 # Translators:
-# Nomis101 <Nomis101@web.de>, 2024
+# Nomis101 <Nomis101@web.de>, 2025
 # 
 #, fuzzy
 msgid ""
@@ -13,7 +13,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
-"Last-Translator: Nomis101 <Nomis101@web.de>, 2024\n"
+"Last-Translator: Nomis101 <Nomis101@web.de>, 2025\n"
 "Language-Team: German (https://app.transifex.com/HandBrakeProject/teams/92423/de/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
diff -Naupr a/gtk/po/es.po b/gtk/po/es.po
--- a/gtk/po/es.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/es.po	2025-03-31 11:55:35.224884726 +0200
@@ -1,11 +1,11 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
 # Translators:
-# Casper, 2024
 # Mihai Pantazi <malexandru_70@hotmail.com>, 2024
+# Casper, 2025
 # 
 #, fuzzy
 msgid ""
@@ -14,7 +14,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
-"Last-Translator: Mihai Pantazi <malexandru_70@hotmail.com>, 2024\n"
+"Last-Translator: Casper, 2025\n"
 "Language-Team: Spanish (https://app.transifex.com/HandBrakeProject/teams/92423/es/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
diff -Naupr a/gtk/po/eu.po b/gtk/po/eu.po
--- a/gtk/po/eu.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/eu.po	2025-03-31 11:55:35.224884726 +0200
@@ -1,10 +1,10 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
 # Translators:
-# arrakala EuskalEncodings, 2024
+# arrakala EuskalEncodings, 2025
 # 
 #, fuzzy
 msgid ""
@@ -13,7 +13,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
-"Last-Translator: arrakala EuskalEncodings, 2024\n"
+"Last-Translator: arrakala EuskalEncodings, 2025\n"
 "Language-Team: Basque (https://app.transifex.com/HandBrakeProject/teams/92423/eu/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
diff -Naupr a/gtk/po/fi.po b/gtk/po/fi.po
--- a/gtk/po/fi.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/fi.po	2025-03-31 11:55:35.224884726 +0200
@@ -1,12 +1,12 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
 # Translators:
 # Jaakko Saarikko <jaakko.saarikko@protonmail.com>, 2022
 # heidi.wenger, 2024
-# Tommi Nieminen <translator@legisign.org>, 2024
+# Tommi Nieminen <translator@legisign.org>, 2025
 # 
 #, fuzzy
 msgid ""
@@ -15,7 +15,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
-"Last-Translator: Tommi Nieminen <translator@legisign.org>, 2024\n"
+"Last-Translator: Tommi Nieminen <translator@legisign.org>, 2025\n"
 "Language-Team: Finnish (https://app.transifex.com/HandBrakeProject/teams/92423/fi/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
diff -Naupr a/gtk/po/fr.po b/gtk/po/fr.po
--- a/gtk/po/fr.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/fr.po	2025-03-31 11:55:35.225884709 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
@@ -11,7 +11,7 @@
 # Nicolas Moignot <nicolas@moignot.net>, 2024
 # DJ Dakta <djdakta@gmail.com>, 2024
 # Baptiste D <baptiste+transifex@darthenay.fr>, 2024
-# Tof Bouf, 2024
+# Tof Bouf, 2025
 # 
 #, fuzzy
 msgid ""
@@ -20,7 +20,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
-"Last-Translator: Tof Bouf, 2024\n"
+"Last-Translator: Tof Bouf, 2025\n"
 "Language-Team: French (https://app.transifex.com/HandBrakeProject/teams/92423/fr/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
diff -Naupr a/gtk/po/ghb.pot b/gtk/po/ghb.pot
--- a/gtk/po/ghb.pot	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/ghb.pot	2025-03-31 11:55:35.225884709 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 #
diff -Naupr a/gtk/po/he.po b/gtk/po/he.po
--- a/gtk/po/he.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/he.po	2025-03-31 11:55:35.225884709 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/hr.po b/gtk/po/hr.po
--- a/gtk/po/hr.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/hr.po	2025-03-31 11:55:35.225884709 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/it.po b/gtk/po/it.po
--- a/gtk/po/it.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/it.po	2025-03-31 11:55:35.226884691 +0200
@@ -1,12 +1,12 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
 # Translators:
 # Francesco Saltori, 2024
-# Vincenzo Reale <vinx.reale@gmail.com>, 2024
 # Damiano Galassi <galad87@icloud.com>, 2024
+# Vincenzo Reale <vinx.reale@gmail.com>, 2025
 # 
 #, fuzzy
 msgid ""
@@ -15,7 +15,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
-"Last-Translator: Damiano Galassi <galad87@icloud.com>, 2024\n"
+"Last-Translator: Vincenzo Reale <vinx.reale@gmail.com>, 2025\n"
 "Language-Team: Italian (https://app.transifex.com/HandBrakeProject/teams/92423/it/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
@@ -70,7 +70,7 @@ msgstr "_Avvia codifica"
 
 #: src/ui/menu.ui:57 src/queuehandler.c:1913
 msgid "_Pause Encoding"
-msgstr "Metti in _pausa la codifica"
+msgstr "Sos_pendi la codifica"
 
 #: src/ui/menu.ui:63 src/ui/menu.ui:182 src/ui/menu.ui:334
 msgid "_Import Queue"
@@ -362,12 +362,12 @@ msgstr "Avvia"
 #: src/ui/ghb.ui:221 src/ui/ghb.ui:1424 src/queuehandler.c:1887
 #: src/queuehandler.c:1900
 msgid "Pause Encoding"
-msgstr "Metti in pausa la codifica"
+msgstr "Sospendi la codifica"
 
 #: src/ui/ghb.ui:222 src/ui/ghb.ui:1425 src/queuehandler.c:1886
 #: src/queuehandler.c:1899
 msgid "Pause"
-msgstr "Metti in pausa"
+msgstr "Pausa"
 
 #: src/ui/ghb.ui:235 src/ui/ghb.ui:1456
 msgid "Queue"
@@ -387,7 +387,7 @@ msgstr "Al termine:"
 
 #: src/ui/ghb.ui:335
 msgid "Show/hide the queue details panel"
-msgstr "Mostra/nasconde il pannello dei dettagli della coda"
+msgstr "Mostra/nascondi il pannello dei dettagli della coda"
 
 #: src/ui/ghb.ui:364 src/ui/ghb.ui:1733
 msgid "Summary"
@@ -398,7 +398,7 @@ msgid ""
 "Mark selected queue entry as pending.\n"
 "Resets the queue job to pending and ready to run again."
 msgstr ""
-"Mette l'elemento della coda selezionato in attesa.\n"
+"Metti l'elemento della coda selezionato in attesa.\n"
 "Reimposta l'operazione in attesa per poterla eseguire di nuovo."
 
 #: src/ui/ghb.ui:397
@@ -2707,7 +2707,7 @@ msgstr "Chiudi Handbrake"
 
 #: src/hb-backend.c:105
 msgid "Put Computer To Sleep"
-msgstr "Metti il computer in stand-by"
+msgstr "Sospendi il computer"
 
 #: src/hb-backend.c:106
 msgid "Shutdown Computer"
@@ -3288,7 +3288,7 @@ msgstr "Sovrascrivi"
 
 #: src/presets.c:2124 src/presets.c:2506
 msgid "Overwrite Preset?"
-msgstr "Sovrascivere la preimpostazione?"
+msgstr "Vuoi sovrascrivere la preimpostazione?"
 
 #: src/presets.c:2125 src/presets.c:2507
 #, c-format
diff -Naupr a/gtk/po/ja.po b/gtk/po/ja.po
--- a/gtk/po/ja.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/ja.po	2025-03-31 11:55:35.226884691 +0200
@@ -1,11 +1,12 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
 # Translators:
+# Nomis101 <Nomis101@web.de>, 2024
 # Yuichiro Naito, 2024
-# AlphaKodi, 2024
+# AlphaKodi, 2025
 # 
 #, fuzzy
 msgid ""
@@ -14,6 +15,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
+"Last-Translator: AlphaKodi, 2025\n"
 "Language-Team: Japanese (https://app.transifex.com/HandBrakeProject/teams/92423/ja/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
@@ -2559,7 +2561,7 @@ msgstr "
 
 #: src/callbacks.c:5514
 msgid "Quitting HandBrake"
-msgstr "HandBrake"
+msgstr "HandBrake"
 
 #: src/callbacks.c:5521
 msgid "Putting computer to sleep"
diff -Naupr a/gtk/po/ka.po b/gtk/po/ka.po
--- a/gtk/po/ka.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/ka.po	2025-03-31 11:55:35.226884691 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/ko.po b/gtk/po/ko.po
--- a/gtk/po/ko.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/ko.po	2025-03-31 11:55:35.226884691 +0200
@@ -1,12 +1,12 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
 # Translators:
 # JinHee Kim <sinnanjini@gmail.com>, 2019
 # nayoon <belloyv@gmail.com>, 2023
-# Junghee Lee <daemul72@gmail.com>, 2024
+# Junghee Lee <daemul72@gmail.com>, 2025
 # 
 #, fuzzy
 msgid ""
@@ -15,7 +15,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
-"Last-Translator: Junghee Lee <daemul72@gmail.com>, 2024\n"
+"Last-Translator: Junghee Lee <daemul72@gmail.com>, 2025\n"
 "Language-Team: Korean (https://app.transifex.com/HandBrakeProject/teams/92423/ko/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
diff -Naupr a/gtk/po/meson.build b/gtk/po/meson.build
--- a/gtk/po/meson.build	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/meson.build	2025-03-31 11:55:35.226884691 +0200
@@ -1,5 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
-# Copyright (c) 2023-2024 HandBrake Team
+# Copyright (c) 2023-2025 HandBrake Team
 
 po_dir = meson.current_source_dir()
 
diff -Naupr a/gtk/po/nl.po b/gtk/po/nl.po
--- a/gtk/po/nl.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/nl.po	2025-03-31 11:55:35.226884691 +0200
@@ -1,11 +1,11 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
 # Translators:
 # Stephan Paternotte <stephan@paternottes.net>, 2024
-# Sigmund Walrerson <riseofthenorse@live.be>, 2024
+# Sigmund Walrerson <riseofthenorse@live.be>, 2025
 # 
 #, fuzzy
 msgid ""
@@ -14,7 +14,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
-"Last-Translator: Sigmund Walrerson <riseofthenorse@live.be>, 2024\n"
+"Last-Translator: Sigmund Walrerson <riseofthenorse@live.be>, 2025\n"
 "Language-Team: Dutch (https://app.transifex.com/HandBrakeProject/teams/92423/nl/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
diff -Naupr a/gtk/po/no.po b/gtk/po/no.po
--- a/gtk/po/no.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/no.po	2025-03-31 11:55:35.226884691 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/pl.po b/gtk/po/pl.po
--- a/gtk/po/pl.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/pl.po	2025-03-31 11:55:35.227884674 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/pt.po b/gtk/po/pt.po
--- a/gtk/po/pt.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/pt.po	2025-03-31 11:55:35.227884674 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/pt_BR.po b/gtk/po/pt_BR.po
--- a/gtk/po/pt_BR.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/pt_BR.po	2025-03-31 11:55:35.227884674 +0200
@@ -1,11 +1,11 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
 # Translators:
 # 1111b07adbf58311a84d4d600482725e_5743f4c <4da7f1e717ffc01dbdfab0c343762106_894646>, 2020
-# Wellington Uemura <wellingtonuemura@gmail.com>, 2024
+# Wellington Uemura <wellingtonuemura@gmail.com>, 2025
 # 
 #, fuzzy
 msgid ""
@@ -14,7 +14,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
-"Last-Translator: Wellington Uemura <wellingtonuemura@gmail.com>, 2024\n"
+"Last-Translator: Wellington Uemura <wellingtonuemura@gmail.com>, 2025\n"
 "Language-Team: Portuguese (Brazil) (https://app.transifex.com/HandBrakeProject/teams/92423/pt_BR/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
diff -Naupr a/gtk/po/ro.po b/gtk/po/ro.po
--- a/gtk/po/ro.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/ro.po	2025-03-31 11:55:35.227884674 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/ru.po b/gtk/po/ru.po
--- a/gtk/po/ru.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/ru.po	2025-03-31 11:55:35.227884674 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/si.po b/gtk/po/si.po
--- a/gtk/po/si.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/si.po	2025-03-31 11:55:35.227884674 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/sk.po b/gtk/po/sk.po
--- a/gtk/po/sk.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/sk.po	2025-03-31 11:55:35.227884674 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/sl_SI.po b/gtk/po/sl_SI.po
--- a/gtk/po/sl_SI.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/sl_SI.po	2025-03-31 11:55:35.227884674 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/sv.po b/gtk/po/sv.po
--- a/gtk/po/sv.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/sv.po	2025-03-31 11:55:35.228884657 +0200
@@ -1,10 +1,11 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
 # Translators:
-# ke Engelbrektson, 2024
+# Daniel Nylander <po@danielnylander.se>, 2024
+# ke Engelbrektson, 2025
 # 
 #, fuzzy
 msgid ""
@@ -13,7 +14,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
-"Last-Translator: ke Engelbrektson, 2024\n"
+"Last-Translator: ke Engelbrektson, 2025\n"
 "Language-Team: Swedish (Sweden) (https://app.transifex.com/HandBrakeProject/teams/92423/sv_SE/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
@@ -27,7 +28,7 @@ msgstr "_Arkiv"
 
 #: src/ui/menu.ui:10 src/ui/menu.ui:456
 msgid "_Open Source"
-msgstr "_ppna kllfil"
+msgstr "_ppna kllfil..."
 
 #: src/ui/menu.ui:14 src/ui/menu.ui:460
 msgid "Open _Directory"
@@ -84,7 +85,7 @@ msgstr "_Visa"
 
 #: src/ui/menu.ui:76
 msgid "Presets _List"
-msgstr "Frvalslista"
+msgstr "Frvals_lista"
 
 #: src/ui/menu.ui:84
 msgid "_Preview"
diff -Naupr a/gtk/po/th.po b/gtk/po/th.po
--- a/gtk/po/th.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/th.po	2025-03-31 11:55:35.228884657 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/tr.po b/gtk/po/tr.po
--- a/gtk/po/tr.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/tr.po	2025-03-31 11:55:35.228884657 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/uk_UA.po b/gtk/po/uk_UA.po
--- a/gtk/po/uk_UA.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/uk_UA.po	2025-03-31 11:55:35.228884657 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/po/zh_CN.po b/gtk/po/zh_CN.po
--- a/gtk/po/zh_CN.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/zh_CN.po	2025-03-31 11:55:35.228884657 +0200
@@ -1,12 +1,12 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
 # Translators:
 #  <yjwork@qq.com>, 2024
 # YFdyh000 <yfdyh000@gmail.com>, 2024
-#  <pluwen@gmail.com>, 2024
+#  <pluwen@gmail.com>, 2025
 # 
 #, fuzzy
 msgid ""
@@ -15,7 +15,7 @@ msgstr ""
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2024-11-16 19:27+0000\n"
 "PO-Revision-Date: 2018-10-10 18:14+0000\n"
-"Last-Translator:  <pluwen@gmail.com>, 2024\n"
+"Last-Translator:  <pluwen@gmail.com>, 2025\n"
 "Language-Team: Chinese (https://app.transifex.com/HandBrakeProject/teams/92423/zh/)\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
diff -Naupr a/gtk/po/zh_TW.po b/gtk/po/zh_TW.po
--- a/gtk/po/zh_TW.po	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/po/zh_TW.po	2025-03-31 11:55:35.228884657 +0200
@@ -1,5 +1,5 @@
 # SOME DESCRIPTIVE TITLE.
-# Copyright (C) 2024 HandBrake Team
+# Copyright (C) 2025 HandBrake Team
 # This file is distributed under the same license as the ghb package.
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 # 
diff -Naupr a/gtk/src/application.c b/gtk/src/application.c
--- a/gtk/src/application.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/application.c	2025-03-31 11:55:35.229884639 +0200
@@ -1,6 +1,6 @@
 /* application.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/application.h b/gtk/src/application.h
--- a/gtk/src/application.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/application.h	2025-03-31 11:55:35.229884639 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2024 HandBrake Team
+/* Copyright (C) 2025 HandBrake Team
  * SPDX-License-Identifier: GPL-2.0-or-later */
 
 #pragma once
diff -Naupr a/gtk/src/audiohandler.c b/gtk/src/audiohandler.c
--- a/gtk/src/audiohandler.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/audiohandler.c	2025-03-31 11:55:35.229884639 +0200
@@ -1,6 +1,6 @@
 /* audiohandler.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/audiohandler.h b/gtk/src/audiohandler.h
--- a/gtk/src/audiohandler.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/audiohandler.h	2025-03-31 11:55:35.229884639 +0200
@@ -1,6 +1,6 @@
 /* audiohandler.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/callbacks.c b/gtk/src/callbacks.c
--- a/gtk/src/callbacks.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/callbacks.c	2025-03-31 11:55:35.230884622 +0200
@@ -1,6 +1,6 @@
 /* callbacks.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
@@ -456,7 +456,8 @@ static GhbBinding widget_bindings[] =
     {"PresetCategory", "active-id", "new", "PresetCategoryName", "visible"},
     {"PresetCategory", "active-id", "new", "PresetCategoryEntryLabel", "visible"},
     {"DiskFreeCheck", "active", NULL, "DiskFreeLimitGB", "sensitive"},
-    {"LimitMaxDuration", "active", NULL, "MaxTitleDuration", "sensitive"}
+    {"LimitMaxDuration", "active", NULL, "MaxTitleDuration", "sensitive"},
+    {"SendFileTo", "active", NULL, "SendFileToTarget", "sensitive"}
 };
 
 void
@@ -4485,6 +4486,57 @@ searching_status_string(signal_user_data
 }
 
 static void
+send_to_external_app(gint index, signal_user_data_t * ud)
+{
+    gboolean send_file_to = ghb_dict_get_bool(ud->prefs, "SendFileTo");
+    const gchar * send_file_to_target = ghb_dict_get_string(ud->prefs, "SendFileToTarget");
+    if (send_file_to && send_file_to_target != NULL && send_file_to_target[0] != '\0')
+    {
+        GhbValue *queueDict, *jobDict, *destDict;
+        queueDict = ghb_array_get(ud->queue, index);
+        jobDict = ghb_dict_get(queueDict, "Job");
+        destDict = ghb_dict_get(jobDict, "Destination");
+
+        gchar * file = g_shell_quote(ghb_dict_get_string(destDict, "File"));
+        gchar * command_str;
+        if (g_access("/.flatpak-info", F_OK) == 0)
+        {
+            command_str = g_strjoin(" ", "flatpak-spawn", "--host", "--", send_file_to_target, file, NULL);
+        }
+        else
+        {
+            command_str = g_strjoin(" ", send_file_to_target, file, NULL);
+        }
+
+        gchar ** command_array = NULL;
+        GError * error = NULL;
+        ghb_log("Running command `%s`", command_str);
+        if (g_shell_parse_argv(command_str, NULL, &command_array, &error))
+        {
+            g_spawn_async(
+                NULL,
+                command_array,
+                NULL,
+                G_SPAWN_SEARCH_PATH | G_SPAWN_STDERR_TO_DEV_NULL | G_SPAWN_STDOUT_TO_DEV_NULL,
+                NULL,
+                NULL,
+                NULL, 
+                &error);
+            g_strfreev(command_array);
+        }
+
+        if (error != NULL)
+        {
+            ghb_log("Failed to run command `%s`: %s", command_str, error->message);
+            g_error_free(error);
+        }
+        
+        g_free(command_str);
+        g_free(file);
+    }
+}
+
+static void
 ghb_backend_events(signal_user_data_t *ud)
 {
     ghb_status_t     status;
@@ -4657,6 +4709,7 @@ ghb_backend_events(signal_user_data_t *u
             case GHB_ERROR_NONE:
                 gtk_label_set_text(work_status, _("Encode Done!"));
                 qstatus = GHB_QUEUE_DONE;
+                send_to_external_app(index, ud);
                 ghb_send_notification (GHB_NOTIFY_ITEM_DONE, index, ud);
                 break;
             case GHB_ERROR_CANCELED:
diff -Naupr a/gtk/src/callbacks.h b/gtk/src/callbacks.h
--- a/gtk/src/callbacks.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/callbacks.h	2025-03-31 11:55:35.230884622 +0200
@@ -1,6 +1,6 @@
 /* callbacks.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/chapters.c b/gtk/src/chapters.c
--- a/gtk/src/chapters.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/chapters.c	2025-03-31 11:55:35.230884622 +0200
@@ -1,6 +1,6 @@
 /* chapters.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/chapters.h b/gtk/src/chapters.h
--- a/gtk/src/chapters.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/chapters.h	2025-03-31 11:55:35.230884622 +0200
@@ -1,6 +1,6 @@
 /* chapters.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/color-scheme.c b/gtk/src/color-scheme.c
--- a/gtk/src/color-scheme.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/color-scheme.c	2025-03-31 11:55:35.230884622 +0200
@@ -1,6 +1,6 @@
 /* color-scheme.c
  *
- * Copyright (C) 2022-2024 HandBrake Team
+ * Copyright (C) 2022-2025 HandBrake Team
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Naupr a/gtk/src/color-scheme.h b/gtk/src/color-scheme.h
--- a/gtk/src/color-scheme.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/color-scheme.h	2025-03-31 11:55:35.230884622 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2022-2024 HandBrake Team
+/* Copyright (C) 2022-2025 HandBrake Team
  * SPDX-License-Identifier: GPL-2.0-or-later */
 
 #pragma once
diff -Naupr a/gtk/src/common.h b/gtk/src/common.h
--- a/gtk/src/common.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/common.h	2025-03-31 11:55:35.230884622 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2024 HandBrake Team
+/* Copyright (C) 2025 HandBrake Team
  * SPDX-License-Identifier: GPL-2.0-or-later */
 
 #pragma once
diff -Naupr a/gtk/src/ghb-button.c b/gtk/src/ghb-button.c
--- a/gtk/src/ghb-button.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/ghb-button.c	2025-03-31 11:55:35.230884622 +0200
@@ -1,6 +1,6 @@
 /* ghb-button.c
  *
- * Copyright (C) 2024 HandBrake Team
+ * Copyright (C) 2025 HandBrake Team
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Naupr a/gtk/src/ghb-button.h b/gtk/src/ghb-button.h
--- a/gtk/src/ghb-button.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/ghb-button.h	2025-03-31 11:55:35.230884622 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2024 HandBrake Team
+/* Copyright (C) 2025 HandBrake Team
  * SPDX-License-Identifier: GPL-2.0-or-later */
 
 #pragma once
diff -Naupr a/gtk/src/ghb-chapter-row.c b/gtk/src/ghb-chapter-row.c
--- a/gtk/src/ghb-chapter-row.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/ghb-chapter-row.c	2025-03-31 11:55:35.230884622 +0200
@@ -1,6 +1,6 @@
 /* ghb-chapter-row.c
  *
- * Copyright (C) 2024 HandBrake Team
+ * Copyright (C) 2025 HandBrake Team
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Naupr a/gtk/src/ghb-chapter-row.h b/gtk/src/ghb-chapter-row.h
--- a/gtk/src/ghb-chapter-row.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/ghb-chapter-row.h	2025-03-31 11:55:35.230884622 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2024 HandBrake Team
+/* Copyright (C) 2025 HandBrake Team
  * SPDX-License-Identifier: GPL-2.0-or-later */
 
 #pragma once
diff -Naupr a/gtk/src/ghb-file-button.c b/gtk/src/ghb-file-button.c
--- a/gtk/src/ghb-file-button.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/ghb-file-button.c	2025-03-31 11:55:35.230884622 +0200
@@ -1,6 +1,6 @@
 /* ghb-file-button.c
  *
- * Copyright (C) 2024 HandBrake Team
+ * Copyright (C) 2025 HandBrake Team
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Naupr a/gtk/src/ghb-file-button.h b/gtk/src/ghb-file-button.h
--- a/gtk/src/ghb-file-button.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/ghb-file-button.h	2025-03-31 11:55:35.230884622 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2024 HandBrake Team
+/* Copyright (C) 2025 HandBrake Team
  * SPDX-License-Identifier: GPL-2.0-or-later */
 
 #pragma once
diff -Naupr a/gtk/src/ghb-queue-row.c b/gtk/src/ghb-queue-row.c
--- a/gtk/src/ghb-queue-row.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/ghb-queue-row.c	2025-03-31 11:55:35.230884622 +0200
@@ -1,6 +1,6 @@
 /* ghb-queue-row.c
  *
- * Copyright (C) 2024 HandBrake Team
+ * Copyright (C) 2025 HandBrake Team
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Naupr a/gtk/src/ghb-queue-row.h b/gtk/src/ghb-queue-row.h
--- a/gtk/src/ghb-queue-row.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/ghb-queue-row.h	2025-03-31 11:55:35.230884622 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2024 HandBrake Team
+/* Copyright (C) 2025 HandBrake Team
  * SPDX-License-Identifier: GPL-2.0-or-later */
 
 #pragma once
diff -Naupr a/gtk/src/ghb-string-list.c b/gtk/src/ghb-string-list.c
--- a/gtk/src/ghb-string-list.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/ghb-string-list.c	2025-03-31 11:55:35.230884622 +0200
@@ -1,6 +1,6 @@
 /* ghb-string-list.c
  *
- * Copyright (C) 2024 HandBrake Team
+ * Copyright (C) 2025 HandBrake Team
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -294,4 +294,4 @@ string_list_remove_action (GSimpleAction
         gtk_list_box_remove(self->list_box, GTK_WIDGET(row));
         g_object_notify_by_pspec(G_OBJECT(self), props[PROP_ITEMS]);
     }
-}
\ Manca newline alla fine del file
+}
diff -Naupr a/gtk/src/ghb-string-list.h b/gtk/src/ghb-string-list.h
--- a/gtk/src/ghb-string-list.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/ghb-string-list.h	2025-03-31 11:55:35.230884622 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2024 HandBrake Team
+/* Copyright (C) 2025 HandBrake Team
  * SPDX-License-Identifier: GPL-2.0-or-later */
 
 #pragma once
diff -Naupr a/gtk/src/hb-backend.c b/gtk/src/hb-backend.c
--- a/gtk/src/hb-backend.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/hb-backend.c	2025-03-31 11:55:35.231884605 +0200
@@ -1,6 +1,6 @@
 /* hb-backend.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
@@ -2542,14 +2542,6 @@ video_tune_opts_set(signal_user_data_t *
     store = GTK_LIST_STORE(gtk_combo_box_get_model (combo));
     gtk_list_store_clear(store);
 
-    gtk_list_store_append(store, &iter);
-    gtk_list_store_set(store, &iter,
-                       0, _("None"),
-                       1, TRUE,
-                       2, "none",
-                       3, (gdouble)0,
-                       -1);
-
     for (ii = 0; ii < count; ii++)
     {
         if (((encoder & (HB_VCODEC_X264_MASK | HB_VCODEC_SVT_AV1_MASK)) &&
diff -Naupr a/gtk/src/hb-backend.h b/gtk/src/hb-backend.h
--- a/gtk/src/hb-backend.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/hb-backend.h	2025-03-31 11:55:35.231884605 +0200
@@ -1,6 +1,6 @@
 /* hb-backend.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/hb-dvd.c b/gtk/src/hb-dvd.c
--- a/gtk/src/hb-dvd.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/hb-dvd.c	2025-03-31 11:55:35.231884605 +0200
@@ -1,6 +1,6 @@
 /* hb-dvd.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/hb-dvd.h b/gtk/src/hb-dvd.h
--- a/gtk/src/hb-dvd.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/hb-dvd.h	2025-03-31 11:55:35.231884605 +0200
@@ -1,6 +1,6 @@
 /* hb-dvd.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/jobdict.c b/gtk/src/jobdict.c
--- a/gtk/src/jobdict.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/jobdict.c	2025-03-31 11:55:35.231884605 +0200
@@ -1,6 +1,6 @@
 /* jobdict.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/jobdict.h b/gtk/src/jobdict.h
--- a/gtk/src/jobdict.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/jobdict.h	2025-03-31 11:55:35.231884605 +0200
@@ -1,6 +1,6 @@
 /* jobdict.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
@@ -42,4 +42,4 @@ GhbValue* ghb_get_job_subtitle_search(Gh
 GhbValue* ghb_get_job_filter_settings(GhbValue *settings);
 GhbValue* ghb_get_job_filter_list(GhbValue *settings);
 
-G_END_DECLS
\ Manca newline alla fine del file
+G_END_DECLS
diff -Naupr a/gtk/src/main.c b/gtk/src/main.c
--- a/gtk/src/main.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/main.c	2025-03-31 11:55:35.231884605 +0200
@@ -1,6 +1,6 @@
 /* main.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/meson.build b/gtk/src/meson.build
--- a/gtk/src/meson.build	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/meson.build	2025-03-31 11:55:35.231884605 +0200
@@ -1,4 +1,4 @@
-# Copyright (C) 2023-2024 HandBrake Team
+# Copyright (C) 2023-2025 HandBrake Team
 # SPDX-License-Identifier: GPL-2.0-or-later
 
 # Project sources
diff -Naupr a/gtk/src/notifications.c b/gtk/src/notifications.c
--- a/gtk/src/notifications.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/notifications.c	2025-03-31 11:55:35.232884587 +0200
@@ -1,6 +1,6 @@
 /* notifications.c
  *
- * Copyright (C) 2023-2024 HandBrake Team
+ * Copyright (C) 2023-2025 HandBrake Team
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Naupr a/gtk/src/notifications.h b/gtk/src/notifications.h
--- a/gtk/src/notifications.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/notifications.h	2025-03-31 11:55:35.232884587 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2023-2024 HandBrake Team
+/* Copyright (C) 2023-2025 HandBrake Team
  * SPDX-License-Identifier: GPL-2.0-or-later */
 
 #pragma once
diff -Naupr a/gtk/src/power-manager.c b/gtk/src/power-manager.c
--- a/gtk/src/power-manager.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/power-manager.c	2025-03-31 11:55:35.232884587 +0200
@@ -1,6 +1,6 @@
 /* notifications.c
  *
- * Copyright (C) 2023-2024 HandBrake Team
+ * Copyright (C) 2023-2025 HandBrake Team
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff -Naupr a/gtk/src/power-manager.h b/gtk/src/power-manager.h
--- a/gtk/src/power-manager.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/power-manager.h	2025-03-31 11:55:35.232884587 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 2023-2024 HandBrake Team
+/* Copyright (C) 2023-2025 HandBrake Team
  * SPDX-License-Identifier: GPL-2.0-or-later */
 
 #pragma once
diff -Naupr a/gtk/src/presets.c b/gtk/src/presets.c
--- a/gtk/src/presets.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/presets.c	2025-03-31 11:55:35.232884587 +0200
@@ -1,6 +1,6 @@
 /* presets.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/presets.h b/gtk/src/presets.h
--- a/gtk/src/presets.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/presets.h	2025-03-31 11:55:35.232884587 +0200
@@ -1,6 +1,6 @@
 /* presets.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/preview.c b/gtk/src/preview.c
--- a/gtk/src/preview.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/preview.c	2025-03-31 11:55:35.232884587 +0200
@@ -1,6 +1,6 @@
 /* preview.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/preview.h b/gtk/src/preview.h
--- a/gtk/src/preview.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/preview.h	2025-03-31 11:55:35.232884587 +0200
@@ -1,6 +1,6 @@
 /* preview.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/queuehandler.c b/gtk/src/queuehandler.c
--- a/gtk/src/queuehandler.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/queuehandler.c	2025-03-31 11:55:35.232884587 +0200
@@ -1,6 +1,6 @@
 /* queuehandler.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/queuehandler.h b/gtk/src/queuehandler.h
--- a/gtk/src/queuehandler.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/queuehandler.h	2025-03-31 11:55:35.232884587 +0200
@@ -1,6 +1,6 @@
 /* queuehandler.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/resources.c b/gtk/src/resources.c
--- a/gtk/src/resources.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/resources.c	2025-03-31 11:55:35.232884587 +0200
@@ -1,6 +1,6 @@
 /* resources.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/resources.h b/gtk/src/resources.h
--- a/gtk/src/resources.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/resources.h	2025-03-31 11:55:35.232884587 +0200
@@ -1,6 +1,6 @@
 /* resources.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/settings.c b/gtk/src/settings.c
--- a/gtk/src/settings.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/settings.c	2025-03-31 11:55:35.233884570 +0200
@@ -1,6 +1,6 @@
 /* settings.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/settings.h b/gtk/src/settings.h
--- a/gtk/src/settings.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/settings.h	2025-03-31 11:55:35.233884570 +0200
@@ -1,6 +1,6 @@
 /* settings.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/subtitlehandler.c b/gtk/src/subtitlehandler.c
--- a/gtk/src/subtitlehandler.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/subtitlehandler.c	2025-03-31 11:55:35.233884570 +0200
@@ -1,6 +1,6 @@
 /* subtitlehandler.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/subtitlehandler.h b/gtk/src/subtitlehandler.h
--- a/gtk/src/subtitlehandler.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/subtitlehandler.h	2025-03-31 11:55:35.233884570 +0200
@@ -1,6 +1,6 @@
 /* subtitlehandler.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/title-add.c b/gtk/src/title-add.c
--- a/gtk/src/title-add.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/title-add.c	2025-03-31 11:55:35.233884570 +0200
@@ -1,6 +1,6 @@
 /* title-add.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
@@ -290,26 +290,32 @@ static PangoAttrList *default_title_attr
 static void
 title_add_set_sensitive (GtkWidget *row, gboolean sensitive)
 {
+    PangoAttrList *pal;
+    PangoAttribute *bg, *alpha;
     GtkWidget *widget;
     widget = find_widget(row, "title_selected");
     gtk_widget_set_sensitive(widget, sensitive);
 
     widget = find_widget(row, "title_label");
+
     if (!sensitive)
     {
-        PangoAttrList *pal;
-        PangoAttribute *bg;
-        bg = pango_attr_background_new(0xFFFF, 0xFFFF, 0xA000);
-        pal = pango_attr_list_new();
-        pango_attr_list_insert(pal, bg);
-        gtk_label_set_attributes(GTK_LABEL(widget), pal);
+        alpha = pango_attr_background_alpha_new(0);
         gtk_widget_set_has_tooltip(widget, TRUE);
     }
     else
     {
+        alpha = pango_attr_background_alpha_new(1);
         gtk_label_set_attributes(GTK_LABEL(widget), default_title_attrs);
         gtk_widget_set_has_tooltip(widget, FALSE);
     }
+
+    pal = pango_attr_list_new();
+    bg = pango_attr_background_new(0xFFFF, 0xFFFF, 0xA000);
+    pango_attr_list_insert(pal, bg);
+    pango_attr_list_insert(pal, alpha);
+
+    gtk_label_set_attributes(GTK_LABEL(widget), pal);
 }
 
 static gboolean
diff -Naupr a/gtk/src/title-add.h b/gtk/src/title-add.h
--- a/gtk/src/title-add.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/title-add.h	2025-03-31 11:55:35.233884570 +0200
@@ -1,6 +1,6 @@
 /* title-add.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/titledict.c b/gtk/src/titledict.c
--- a/gtk/src/titledict.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/titledict.c	2025-03-31 11:55:35.233884570 +0200
@@ -1,6 +1,6 @@
 /* titledict.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/titledict.h b/gtk/src/titledict.h
--- a/gtk/src/titledict.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/titledict.h	2025-03-31 11:55:35.233884570 +0200
@@ -1,6 +1,6 @@
 /* titledict.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/ui/ghb.ui b/gtk/src/ui/ghb.ui
--- a/gtk/src/ui/ghb.ui	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/ui/ghb.ui	2025-03-31 11:55:35.235884535 +0200
@@ -3601,7 +3601,10 @@ to make bitrate allocation decisions.</p
 This establishes your default encoder settings.
 Tunes, profiles, levels and extra options string will be applied to this.
 You should generally set this option to the slowest you can bear since slower
-settings will result in better quality or smaller files.</property>
+settings will result in better quality or smaller files.
+
+Adjust the slider to the right to increase compression efficiency at the expense of encoding speed,
+or to the left to increase encoding speed at the expense of compression efficiency.</property>
                                     <property name="adjustment">VideoPresetRange</property>
                                     <property name="hexpand">1</property>
                                     <signal name="value-changed" handler="video_preset_slider_changed_cb" swapped="no"/>
@@ -5771,6 +5774,28 @@ battery is charged.</property>
                             <signal name="toggled" handler="pref_changed_cb" swapped="no"/>
                           </object>
                         </child>
+                        <child>
+                          <object class="GtkBox">
+                            <property name="spacing">4</property>
+                            <child>
+                              <object class="GtkCheckButton" id="SendFileTo">
+                                <property name="label" translatable="yes">Send file to:</property>
+                                <property name="halign">start</property>
+                                <signal name="toggled" handler="pref_changed_cb" />
+                              </object>
+                            </child>
+                            <child>
+                              <object class="GtkEntry" id="SendFileToTarget">
+                                <property name="width-chars">30</property>
+                                <property name="truncate-multiline">1</property>
+                                <signal name="changed" handler="pref_changed_cb" swapped="no"/>
+                                <accessibility>
+                                  <relation name="labelled-by">SendFileTo</relation>
+                                </accessibility>
+                              </object>
+                            </child>
+                          </object>
+                        </child>
                       </object>
                     </property>
                   </object>
diff -Naupr a/gtk/src/util.c b/gtk/src/util.c
--- a/gtk/src/util.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/util.c	2025-03-31 11:55:35.235884535 +0200
@@ -1,6 +1,6 @@
 /* util.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
@@ -267,4 +267,4 @@ ghb_file_is_subtitle (const char *filena
 {
     return ghb_file_is_ssa_subtitle(filename) ||
            ghb_file_is_srt_subtitle(filename);
-}
\ Manca newline alla fine del file
+}
diff -Naupr a/gtk/src/util.h b/gtk/src/util.h
--- a/gtk/src/util.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/util.h	2025-03-31 11:55:35.235884535 +0200
@@ -1,6 +1,6 @@
 /* util.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/values.c b/gtk/src/values.c
--- a/gtk/src/values.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/values.c	2025-03-31 11:55:35.235884535 +0200
@@ -1,6 +1,6 @@
 /* values.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/values.h b/gtk/src/values.h
--- a/gtk/src/values.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/values.h	2025-03-31 11:55:35.235884535 +0200
@@ -1,6 +1,6 @@
 /* values.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/videohandler.c b/gtk/src/videohandler.c
--- a/gtk/src/videohandler.c	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/videohandler.c	2025-03-31 11:55:35.236884518 +0200
@@ -1,6 +1,6 @@
 /* videohandler.c
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/gtk/src/videohandler.h b/gtk/src/videohandler.h
--- a/gtk/src/videohandler.h	2025-02-20 19:37:15.000000000 +0100
+++ b/gtk/src/videohandler.h	2025-03-31 11:55:35.236884518 +0200
@@ -1,6 +1,6 @@
 /* videohandler.h
  *
- * Copyright (C) 2008-2024 John Stebbins <stebbins@stebbins>
+ * Copyright (C) 2008-2025 John Stebbins <stebbins@stebbins>
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2,
diff -Naupr a/libhb/audio_remap.c b/libhb/audio_remap.c
--- a/libhb/audio_remap.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/audio_remap.c	2025-03-31 11:55:35.236884518 +0200
@@ -1,6 +1,6 @@
 /* audio_remap.c
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code
  * Homepage: <http://handbrake.fr/>
  * It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/audio_resample.c b/libhb/audio_resample.c
--- a/libhb/audio_resample.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/audio_resample.c	2025-03-31 11:55:35.236884518 +0200
@@ -1,6 +1,6 @@
 /* audio_resample.c
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code
  * Homepage: <http://handbrake.fr/>
  * It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/avfilter.c b/libhb/avfilter.c
--- a/libhb/avfilter.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/avfilter.c	2025-03-31 11:55:35.236884518 +0200
@@ -1,6 +1,6 @@
 /* avfilter.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -238,22 +238,6 @@ static hb_buffer_t* filterFrame( hb_filt
     hb_buffer_list_t   list;
     hb_buffer_t      * buf = NULL, * next = NULL;
 
-#if HB_PROJECT_FEATURE_QSV && (defined( _WIN32 ) || defined( __MINGW32__ ))
-    mfxFrameSurface1 *surface = NULL;
-    HBQSVFramesContext *frames_ctx = NULL;
-    if (hb_qsv_hw_filters_via_video_memory_are_enabled(pv->input.job) && buf_in != NULL)
-    {
-        hb_buffer_t *in = *buf_in;
-        AVFrame *frame = (AVFrame *)in->storage;
-        if (frame)
-        {
-            // We need to keep surface pointer because hb_avfilter_add_buf set it to 0 after in ffmpeg call
-            surface = (mfxFrameSurface1 *)frame->data[3];
-            frames_ctx = in->qsv_details.qsv_frames_ctx;
-        }
-    }
-#endif
-
     hb_avfilter_add_buf(pv->graph, buf_in);
     buf = hb_avfilter_get_buf(pv->graph);
 
@@ -262,12 +246,6 @@ static hb_buffer_t* filterFrame( hb_filt
         hb_buffer_list_append(&pv->list, buf);
         buf = hb_avfilter_get_buf(pv->graph);
     }
-#if HB_PROJECT_FEATURE_QSV && (defined( _WIN32 ) || defined( __MINGW32__ ))
-    if (hb_qsv_hw_filters_via_video_memory_are_enabled(pv->input.job) && surface)
-    {
-        hb_qsv_release_surface_from_pool_by_surface_pointer(frames_ctx, surface);
-    }
-#endif
     // Delay one frame so we can set the stop time of the output buffer
     hb_buffer_list_clear(&list);
     while (hb_buffer_list_count(&pv->list) > 1)
diff -Naupr a/libhb/batch.c b/libhb/batch.c
--- a/libhb/batch.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/batch.c	2025-03-31 11:55:35.236884518 +0200
@@ -1,6 +1,6 @@
 /* batch.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/bd.c b/libhb/bd.c
--- a/libhb/bd.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/bd.c	2025-03-31 11:55:35.236884518 +0200
@@ -1,6 +1,6 @@
 /* bd.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/bitstream.c b/libhb/bitstream.c
--- a/libhb/bitstream.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/bitstream.c	2025-03-31 11:55:35.236884518 +0200
@@ -1,6 +1,6 @@
 /* bitstream.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/blend.c b/libhb/blend.c
--- a/libhb/blend.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/blend.c	2025-03-31 11:55:35.236884518 +0200
@@ -1,6 +1,6 @@
 /* blend.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -23,13 +23,17 @@ struct hb_blend_private_s
 };
 
 static int hb_blend_init(hb_blend_object_t *object,
+                         int in_width,
+                         int in_height,
                          int in_pix_fmt,
                          int in_chroma_location,
+                         int in_color_range,
                          int overlay_pix_fmt);
 
 static hb_buffer_t * hb_blend_work(hb_blend_object_t *object,
                                    hb_buffer_t *in,
-                                   hb_buffer_list_t *overlays);
+                                   hb_buffer_list_t *overlays,
+                                   int changed);
 
 static void hb_blend_close(hb_blend_object_t *object);
 
@@ -746,8 +750,11 @@ static void blend8onbi1x(const hb_blend_
 }
 
 static int hb_blend_init(hb_blend_object_t *object,
+                         int in_width,
+                         int in_height,
                          int in_pix_fmt,
                          int in_chroma_location,
+                         int in_color_range,
                          int overlay_pix_fmt)
 {
     object->private_data = calloc(sizeof(struct hb_blend_private_s), 1);
@@ -804,7 +811,8 @@ static int hb_blend_init(hb_blend_object
 
 static hb_buffer_t * hb_blend_work(hb_blend_object_t *object,
                                    hb_buffer_t *in,
-                                   hb_buffer_list_t *overlays)
+                                   hb_buffer_list_t *overlays,
+                                   int changed)
 {
     hb_blend_private_t *pv = object->private_data;
     hb_buffer_t *out = in;
diff -Naupr a/libhb/chroma_smooth.c b/libhb/chroma_smooth.c
--- a/libhb/chroma_smooth.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/chroma_smooth.c	2025-03-31 11:55:35.236884518 +0200
@@ -1,7 +1,7 @@
 /* chroma_smooth.c
 
    Copyright (c) 2002 Rmi Guyomarch <rguyom at pobox.com>
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/colormap.c b/libhb/colormap.c
--- a/libhb/colormap.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/colormap.c	2025-03-31 11:55:35.236884518 +0200
@@ -1,6 +1,6 @@
 /* colormap.c
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/colorspace.c b/libhb/colorspace.c
--- a/libhb/colorspace.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/colorspace.c	2025-03-31 11:55:35.236884518 +0200
@@ -1,6 +1,6 @@
 /* colorspace.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/comb_detect.c b/libhb/comb_detect.c
--- a/libhb/comb_detect.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/comb_detect.c	2025-03-31 11:55:35.237884501 +0200
@@ -1,6 +1,6 @@
 /* comb_detect.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/common.c b/libhb/common.c
--- a/libhb/common.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/common.c	2025-03-31 11:55:35.237884501 +0200
@@ -1,6 +1,6 @@
 /* common.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -285,8 +285,8 @@ hb_encoder_internal_t hb_video_encoders[
     // actual encoders
     { { "AV1 (SVT)",                   "svt_av1",          "AV1 (SVT)",                      HB_VCODEC_SVT_AV1,           HB_MUX_MASK_MP4|HB_MUX_MASK_WEBM|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_AV1_SVT,    },
     { { "AV1 10-bit (SVT)",            "svt_av1_10bit",    "AV1 10-bit (SVT)",               HB_VCODEC_SVT_AV1_10BIT,     HB_MUX_MASK_MP4|HB_MUX_MASK_WEBM|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_AV1_SVT,    },
-    { { "AV1 (Intel QSV)",             "qsv_av1",          "AV1 (Intel Media SDK)",          HB_VCODEC_QSV_AV1,           HB_MUX_MASK_MP4|HB_MUX_MASK_WEBM|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_AV1_QSV,    },
-    { { "AV1 10-bit (Intel QSV)",      "qsv_av1_10bit",    "AV1 10-bit (Intel Media SDK)",   HB_VCODEC_QSV_AV1_10BIT,     HB_MUX_MASK_MP4|HB_MUX_MASK_WEBM|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_AV1_QSV,    },
+    { { "AV1 (Intel QSV)",             "qsv_av1",          "AV1 (Intel QSV)",                HB_VCODEC_FFMPEG_QSV_AV1,    HB_MUX_MASK_MP4|HB_MUX_MASK_WEBM|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_AV1_QSV,    },
+    { { "AV1 10-bit (Intel QSV)",      "qsv_av1_10bit",    "AV1 10-bit (Intel QSV)",         HB_VCODEC_FFMPEG_QSV_AV1_10BIT, HB_MUX_MASK_MP4|HB_MUX_MASK_WEBM|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_AV1_QSV, },
     { { "AV1 (NVEnc)",                 "nvenc_av1",        "AV1 (NVEnc)",                    HB_VCODEC_FFMPEG_NVENC_AV1,  HB_MUX_MASK_MP4|HB_MUX_MASK_WEBM|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_AV1_NVENC,  },
     { { "AV1 10-bit (NVEnc)",          "nvenc_av1_10bit",  "AV1 10-bit (NVEnc)",             HB_VCODEC_FFMPEG_NVENC_AV1_10BIT, HB_MUX_MASK_MP4|HB_MUX_MASK_WEBM|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_AV1_NVENC,  },
     { { "AV1 (AMD VCE)",               "vce_av1",          "AV1 (AMD VCE)",                  HB_VCODEC_FFMPEG_VCE_AV1,    HB_MUX_MASK_MP4|HB_MUX_MASK_WEBM|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_AV1_VCE,    },
@@ -294,7 +294,7 @@ hb_encoder_internal_t hb_video_encoders[
     { { "FFV1",                        "ffv1",             "FFV1 (libavcodec)",              HB_VCODEC_FFMPEG_FFV1,                                        HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_FFV1,       },
     { { "H.264 (x264)",                "x264",             "H.264 (libx264)",                HB_VCODEC_X264_8BIT,                          HB_MUX_MASK_MP4|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_H264_X264,  },
     { { "H.264 10-bit (x264)",         "x264_10bit",       "H.264 10-bit (libx264)",         HB_VCODEC_X264_10BIT,                         HB_MUX_MASK_MP4|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_H264_X264,  },
-    { { "H.264 (Intel QSV)",           "qsv_h264",         "H.264 (Intel Media SDK)",        HB_VCODEC_QSV_H264,                           HB_MUX_MASK_MP4|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_H264_QSV,   },
+    { { "H.264 (Intel QSV)",           "qsv_h264",         "H.264 (Intel QSV)",              HB_VCODEC_FFMPEG_QSV_H264,                    HB_MUX_MASK_MP4|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_H264_QSV,   },
     { { "H.264 (AMD VCE)",             "vce_h264",         "H.264 (AMD VCE)",                HB_VCODEC_FFMPEG_VCE_H264,                    HB_MUX_MASK_MP4|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_H264_VCE,   },
     { { "H.264 (NVEnc)",               "nvenc_h264",       "H.264 (NVEnc)",                  HB_VCODEC_FFMPEG_NVENC_H264,                  HB_MUX_MASK_MP4|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_H264_NVENC, },
     { { "H.264 (MediaFoundation)",     "mf_h264",          "H.264 (MediaFoundation)",        HB_VCODEC_FFMPEG_MF_H264,                     HB_MUX_MASK_MP4|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_H264_MF,    },
@@ -303,8 +303,8 @@ hb_encoder_internal_t hb_video_encoders[
     { { "H.265 10-bit (x265)",         "x265_10bit",       "H.265 10-bit (libx265)",         HB_VCODEC_X265_10BIT,                           HB_MUX_AV_MP4|HB_MUX_AV_MKV,   }, NULL, 0, 1, HB_GID_VCODEC_H265_X265,  },
     { { "H.265 12-bit (x265)",         "x265_12bit",       "H.265 12-bit (libx265)",         HB_VCODEC_X265_12BIT,                           HB_MUX_AV_MP4|HB_MUX_AV_MKV,   }, NULL, 0, 1, HB_GID_VCODEC_H265_X265,  },
     { { "H.265 16-bit (x265)",         "x265_16bit",       "H.265 16-bit (libx265)",         HB_VCODEC_X265_16BIT,                           HB_MUX_AV_MP4|HB_MUX_AV_MKV,   }, NULL, 0, 1, HB_GID_VCODEC_H265_X265,  },
-    { { "H.265 (Intel QSV)",           "qsv_h265",         "H.265 (Intel Media SDK)",        HB_VCODEC_QSV_H265,                           HB_MUX_MASK_MP4|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_H265_QSV,   },
-    { { "H.265 10-bit (Intel QSV)",    "qsv_h265_10bit",   "H.265 10-bit (Intel Media SDK)", HB_VCODEC_QSV_H265_10BIT,                     HB_MUX_MASK_MP4|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_H265_QSV,   },
+    { { "H.265 (Intel QSV)",           "qsv_h265",         "H.265 (Intel QSV)",              HB_VCODEC_FFMPEG_QSV_H265,                           HB_MUX_MASK_MP4|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_H265_QSV, },
+    { { "H.265 10-bit (Intel QSV)",    "qsv_h265_10bit",   "H.265 10-bit (Intel QSV)",       HB_VCODEC_FFMPEG_QSV_H265_10BIT,                     HB_MUX_MASK_MP4|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_H265_QSV, },
     { { "H.265 (AMD VCE)",             "vce_h265",         "H.265 (AMD VCE)",                HB_VCODEC_FFMPEG_VCE_H265,                    HB_MUX_MASK_MP4|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_H265_VCE,   },
     { { "H.265 10-bit (AMD VCE)",      "vce_h265_10bit",   "H.265 10-bit (AMD VCE)",         HB_VCODEC_FFMPEG_VCE_H265_10BIT,              HB_MUX_MASK_MP4|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_H265_VCE,   },
     { { "H.265 (NVEnc)",               "nvenc_h265",       "H.265 (NVEnc)",                  HB_VCODEC_FFMPEG_NVENC_H265,                  HB_MUX_MASK_MP4|HB_MUX_MASK_MKV, }, NULL, 0, 1, HB_GID_VCODEC_H265_NVENC, },
@@ -1690,11 +1690,11 @@ int hb_video_multipass_is_supported(uint
         case HB_VCODEC_FFMPEG_NVENC_H265_10BIT:
         case HB_VCODEC_FFMPEG_NVENC_AV1:
         case HB_VCODEC_FFMPEG_NVENC_AV1_10BIT:
-        case HB_VCODEC_QSV_H264:
-        case HB_VCODEC_QSV_H265:
-        case HB_VCODEC_QSV_H265_10BIT:
-        case HB_VCODEC_QSV_AV1:
-        case HB_VCODEC_QSV_AV1_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_H264:
+        case HB_VCODEC_FFMPEG_QSV_H265:
+        case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_AV1:
+        case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
             return 0;
 
         case HB_VCODEC_FFMPEG_VP9:
@@ -1707,6 +1707,41 @@ int hb_video_multipass_is_supported(uint
     }
 }
 
+int hb_video_hdr_dynamic_metadata_is_supported(uint32_t codec, int hdr_dynamic_metadata, int profile)
+{
+    if (hdr_dynamic_metadata == HB_HDR_DYNAMIC_METADATA_HDR10PLUS)
+    {
+        switch (codec)
+        {
+            case HB_VCODEC_X265_10BIT:
+            case HB_VCODEC_VT_H265_10BIT:
+            case HB_VCODEC_SVT_AV1_10BIT:
+                return 1;
+        }
+    }
+#if HB_PROJECT_FEATURE_LIBDOVI
+    else if (hdr_dynamic_metadata == HB_HDR_DYNAMIC_METADATA_DOVI)
+    {
+        if (profile != 5 &&
+            profile != 7 &&
+            profile != 8 &&
+            profile != 10)
+        {
+            return 0;
+        }
+
+        switch (codec)
+        {
+            case HB_VCODEC_X265_10BIT:
+            case HB_VCODEC_VT_H265_10BIT:
+            case HB_VCODEC_SVT_AV1_10BIT:
+                return 1;
+        }
+    }
+#endif
+    return 0;
+}
+
 int hb_video_encoder_is_supported(int encoder)
 {
     const hb_encoder_t *video_encoder = NULL;
@@ -1748,8 +1783,8 @@ int hb_video_encoder_get_depth(int encod
     switch (encoder)
     {
 #if HB_PROJECT_FEATURE_QSV
-        case HB_VCODEC_QSV_H265_10BIT:
-        case HB_VCODEC_QSV_AV1_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
 #endif
 #ifdef __APPLE__
         case HB_VCODEC_VT_H265_10BIT:
@@ -1773,13 +1808,6 @@ int hb_video_encoder_get_depth(int encod
 
 const char* const* hb_video_encoder_get_presets(int encoder)
 {
-#if HB_PROJECT_FEATURE_QSV
-    if (encoder & HB_VCODEC_QSV_MASK)
-    {
-        return hb_qsv_preset_get_names();
-    }
-#endif
-
     if (encoder & HB_VCODEC_FFMPEG_MASK)
     {
         return hb_av_preset_get_names(encoder);
@@ -1807,13 +1835,19 @@ const char* const* hb_video_encoder_get_
 
         case HB_VCODEC_SVT_AV1:
         case HB_VCODEC_SVT_AV1_10BIT:
-            return av1_svt_preset_names;
+            return hb_av1_svt_preset_names;
 
         default:
             return NULL;
     }
 }
 
+static const char * const hb_empty_tune_names[] =
+{
+    "none", NULL
+};
+
+
 const char* const* hb_video_encoder_get_tunes(int encoder)
 {
     if (encoder & HB_VCODEC_FFMPEG_MASK)
@@ -1825,22 +1859,22 @@ const char* const* hb_video_encoder_get_
     {
         case HB_VCODEC_X264_8BIT:
         case HB_VCODEC_X264_10BIT:
-            return x264_tune_names;
+            return hb_x264_tune_names;
 
 #if HB_PROJECT_FEATURE_X265
         case HB_VCODEC_X265_8BIT:
         case HB_VCODEC_X265_10BIT:
         case HB_VCODEC_X265_12BIT:
         case HB_VCODEC_X265_16BIT:
-            return x265_tune_names;
+            return hb_x265_tune_names;
 #endif
 
         case HB_VCODEC_SVT_AV1:
         case HB_VCODEC_SVT_AV1_10BIT:
-            return av1_svt_tune_names;
+            return hb_av1_svt_tune_names;
 
         default:
-            return NULL;
+            return hb_empty_tune_names;
     }
 }
 
@@ -1895,7 +1929,7 @@ const char* const* hb_video_encoder_get_
 
         case HB_VCODEC_SVT_AV1:
         case HB_VCODEC_SVT_AV1_10BIT:
-            return av1_svt_profile_names;
+            return hb_av1_svt_profile_names;
 
         default:
             return NULL;
@@ -2001,13 +2035,6 @@ static const enum AVPixelFormat standard
 
 const int* hb_video_encoder_get_pix_fmts(int encoder, const char *profile)
 {
-#if HB_PROJECT_FEATURE_QSV
-    if (encoder & HB_VCODEC_QSV_MASK)
-    {
-        return hb_qsv_get_pix_fmts(encoder);
-    }
-#endif
-
     if (encoder & HB_VCODEC_FFMPEG_MASK)
     {
         return hb_av_get_pix_fmts(encoder);
@@ -4290,7 +4317,7 @@ void hb_register_error_handler( hb_error
     error_handler = handler;
 }
 
-static void hb_update_str( char **dst, const char *src )
+void hb_update_str( char **dst, const char *src )
 {
     if ( dst )
     {
@@ -4446,8 +4473,8 @@ static void job_setup(hb_job_t * job, hb
     job->coll           = title->coll;
     job->ambient        = title->ambient;
     job->dovi           = title->dovi;
-    job->passthru_dynamic_hdr_metadata |= title->dovi.dv_profile ? DOVI : NONE;
-    job->passthru_dynamic_hdr_metadata |= title->hdr_10_plus ? HDR_10_PLUS : NONE;
+    job->passthru_dynamic_hdr_metadata |= title->dovi.dv_profile ? HB_HDR_DYNAMIC_METADATA_DOVI : HB_HDR_DYNAMIC_METADATA_NONE;
+    job->passthru_dynamic_hdr_metadata |= title->hdr_10_plus ? HB_HDR_DYNAMIC_METADATA_HDR10PLUS : HB_HDR_DYNAMIC_METADATA_NONE;
 
     job->mux = HB_MUX_MP4;
 
@@ -5535,6 +5562,33 @@ hb_audio_config_t * hb_list_audio_config
 }
 
 /**********************************************************************
+ * hb_subtitle_config_copy
+ **********************************************************************
+ *
+ *********************************************************************/
+void hb_subtitle_config_copy(hb_subtitle_config_t *dst,
+                             const hb_subtitle_config_t *src)
+{
+    if (dst == NULL || src == NULL)
+    {
+        return;
+    }
+    memcpy(dst, src, sizeof(*src));
+    if (src->name != NULL)
+    {
+        dst->name = strdup(src->name);
+    }
+    if (src->src_filename != NULL)
+    {
+        dst->src_filename = strdup(src->src_filename);
+    }
+    if (src->external_filename != NULL)
+    {
+        dst->external_filename = strdup(src->external_filename);
+    }
+}
+
+/**********************************************************************
  * hb_subtitle_copy
  **********************************************************************
  *
@@ -5611,6 +5665,67 @@ void hb_subtitle_close( hb_subtitle_t **
 }
 
 /**********************************************************************
+ * hb_subtitle_extradata_init
+ **********************************************************************
+ * Initializes avcodec format subtitle extradata
+ * Returns:
+ *  0  - no action taken, already set or does not require extradata
+ *  1  - set extradata
+ *  -1 - Error
+ *********************************************************************/
+int hb_subtitle_extradata_init(hb_subtitle_t * subtitle)
+{
+    if (subtitle->extradata != NULL)
+    {
+        // Already initialized
+         return 0;
+     }
+
+    if (subtitle->source == VOBSUB)
+    {
+        uint32_t  rgb[16];
+        char     *sub_idx;
+
+        for (int ii = 0; ii < 16; ii++)
+        {
+            rgb[ii] = hb_yuv2rgb(subtitle->palette[ii]);
+        }
+
+        sub_idx = hb_strdup_printf(
+            "size: %dx%d\n"
+            "org: %d, %d\n"
+            "scale: 100%%, 100%%\n"
+            "alpha: 100%%\n"
+            "smooth: OFF\n"
+            "fadein/out: 50, 50\n"
+            "align: OFF at LEFT TOP\n"
+            "time offset: 0\n"
+            "forced subs: %s\n"
+            "palette: %06x, %06x, %06x, %06x, %06x, %06x, "
+            "%06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x\n"
+            "custom colors: OFF, tridx: 0000, "
+            "colors: 000000, 000000, 000000, 000000\n",
+            subtitle->width, subtitle->height, 0, 0, "OFF",
+            rgb[0],  rgb[1],  rgb[2],  rgb[3],
+            rgb[4],  rgb[5],  rgb[6],  rgb[7],
+            rgb[8],  rgb[9],  rgb[10], rgb[11],
+            rgb[12], rgb[13], rgb[14], rgb[15]);
+        if (sub_idx == NULL)
+        {
+            return -1;
+        }
+
+        hb_set_extradata(&subtitle->extradata,
+                         (const uint8_t *)sub_idx,
+                         strlen(sub_idx));
+        free(sub_idx);
+
+        return 1;
+    }
+    return 0;
+}
+
+/**********************************************************************
  * hb_subtitle_add
  **********************************************************************
  *
@@ -5630,15 +5745,7 @@ int hb_subtitle_add(const hb_job_t * job
     // "track" in title->list_audio is an index into the source's tracks.
     // "track" in job->list_audio is an index into title->list_audio
     subtitle->track = track;
-    subtitle->config = *subtitlecfg;
-    if (subtitlecfg->name != NULL && subtitlecfg->name[0] != 0)
-    {
-        subtitle->config.name = strdup(subtitlecfg->name);
-    }
-    else
-    {
-        subtitle->config.name = NULL;
-    }
+    hb_subtitle_config_copy(&subtitle->config, subtitlecfg);
     subtitle->config.src_filename = NULL;
     subtitle->out_track = hb_list_count(job->list_subtitle) + 1;
     hb_list_add(job->list_subtitle, subtitle);
@@ -5682,16 +5789,7 @@ int hb_import_subtitle_add( const hb_job
              hb_subsource_name(subtitle->source));
     strcpy(subtitle->iso639_2, lang->iso639_2);
 
-    subtitle->config = *subtitlecfg;
-    if (subtitlecfg->name != NULL && subtitlecfg->name[0] != 0)
-    {
-        subtitle->config.name = strdup(subtitlecfg->name);
-    }
-    else
-    {
-        subtitle->config.name = NULL;
-    }
-    subtitle->config.src_filename = strdup(subtitlecfg->src_filename);
+    hb_subtitle_config_copy(&subtitle->config, subtitlecfg);
     hb_list_add(job->list_subtitle, subtitle);
 
     return 1;
@@ -5716,6 +5814,24 @@ int hb_subtitle_can_burn( int source )
            source == IMPORTSRT || source == IMPORTSSA || source == DVBSUB;
 }
 
+int hb_subtitle_can_export( int source )
+{
+    switch (source)
+    {
+        case CC608SUB:
+        case CC708SUB:
+        case UTF8SUB:
+        case TX3GSUB:
+        case SSASUB:
+        case IMPORTSRT:
+        case IMPORTSSA:
+        case PGSSUB:
+            return 1;
+        default:
+            return 0;
+    }
+}
+
 int hb_subtitle_can_pass( int source, int mux )
 {
     switch (mux)
@@ -5767,6 +5883,14 @@ int hb_subtitle_can_pass( int source, in
     }
 }
 
+int hb_subtitle_must_burn(hb_subtitle_t *subtitle, int mux)
+{
+    return (subtitle->config.dest == RENDERSUB ||
+             (!(subtitle->config.external_filename != NULL &&
+                hb_subtitle_can_export(subtitle->source)) &&
+              !hb_subtitle_can_pass(subtitle->source, mux)));
+}
+
 int hb_audio_can_apply_drc(uint32_t codec, uint32_t codec_param, int encoder)
 {
     if (encoder & HB_ACODEC_PASS_FLAG)
@@ -5841,7 +5965,7 @@ hb_metadata_t *hb_metadata_copy( const h
             {
                 hb_coverart_t *art = hb_list_item( src->list_coverart, ii );
                 hb_metadata_add_coverart(
-                        metadata, art->data, art->size, art->type );
+                        metadata, art->data, art->size, art->type, art->name );
             }
         }
     }
@@ -5870,6 +5994,7 @@ void hb_metadata_close( hb_metadata_t **
             while( ( art = hb_list_item( m->list_coverart, 0 ) ) )
             {
                 hb_list_rem( m->list_coverart, art );
+                free( art->name );
                 free( art->data );
                 free( art );
             }
@@ -5898,7 +6023,9 @@ void hb_update_meta_dict(hb_dict_t * dic
     }
 }
 
-void hb_metadata_add_coverart( hb_metadata_t *metadata, const uint8_t *data, int size, int type )
+void hb_metadata_add_coverart( hb_metadata_t *metadata,
+                               const uint8_t *data, int size,
+                               int type, const char *name )
 {
     if ( metadata )
     {
@@ -5907,6 +6034,10 @@ void hb_metadata_add_coverart( hb_metada
             metadata->list_coverart = hb_list_init();
         }
         hb_coverart_t *art = calloc( 1, sizeof(hb_coverart_t) );
+        if (name)
+        {
+            art->name = strdup( name );
+        }
         art->data = malloc( size );
         memcpy( art->data, data, size );
         art->size = size;
@@ -5923,6 +6054,7 @@ void hb_metadata_rem_coverart( hb_metada
         if ( art )
         {
             hb_list_rem( metadata->list_coverart, art );
+            free( art->name );
             free( art->data );
             free( art );
         }
@@ -6255,7 +6387,7 @@ hb_csp_convert_f hb_get_rgb2yuv_function
     return hb_rgb2yuv_bt709;
 }
 
-void hb_compute_chroma_smoothing_coefficient(unsigned chroma_coeffs[2][4], int pix_fmt, int chroma_location)
+void hb_compute_chroma_smoothing_coefficient(uint32_t chroma_coeffs[2][4], int pix_fmt, int chroma_location)
 {
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
 
@@ -6283,7 +6415,7 @@ void hb_compute_chroma_smoothing_coeffic
             break;
     }
 
-    const unsigned base_coefficients[] = {1, 3, 9, 27, 9, 3, 1};
+    const uint32_t base_coefficients[] = {1, 3, 9, 27, 9, 3, 1};
     // If wZ is even, an intermediate value is interpolated for symmetry.
     for (int x = 0; x < 4; x++)
     {
@@ -6741,11 +6873,7 @@ static int pix_fmt_is_supported(hb_job_t
 
     if (planes_count == 2)
     {
-        if (hb_hwaccel_decode_is_enabled(job) == 0
-#if HB_PROJECT_FEATURE_QSV
-            && hb_qsv_full_path_is_enabled(job) == 0
-#endif
-            )
+        if (hb_hwaccel_decode_is_enabled(job) == 0)
         {
             return 0;
         }
diff -Naupr a/libhb/compat.c b/libhb/compat.c
--- a/libhb/compat.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/compat.c	2025-03-31 11:55:35.237884501 +0200
@@ -1,6 +1,6 @@
 /* compat.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/cropscale.c b/libhb/cropscale.c
--- a/libhb/cropscale.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/cropscale.c	2025-03-31 11:55:35.237884501 +0200
@@ -1,6 +1,6 @@
 /* cropscale.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -12,8 +12,6 @@
 #include "handbrake/hbffmpeg.h"
 #if HB_PROJECT_FEATURE_QSV && (defined( _WIN32 ) || defined( __MINGW32__ ))
 #include "handbrake/qsv_common.h"
-#include "libavutil/hwcontext_qsv.h"
-#include "libavutil/hwcontext.h"
 #endif
 
 static int crop_scale_init(hb_filter_object_t * filter,
@@ -99,18 +97,8 @@ static int crop_scale_init(hb_filter_obj
     hb_dict_t * avsettings = hb_dict_init();
 
 #if HB_PROJECT_FEATURE_QSV && (defined( _WIN32 ) || defined( __MINGW32__ ))
-    if (hb_qsv_hw_filters_via_video_memory_are_enabled(init->job) || hb_qsv_hw_filters_via_system_memory_are_enabled(init->job))
+    if (init->hw_pix_fmt == AV_PIX_FMT_QSV)
     {
-        if (hb_qsv_hw_filters_via_video_memory_are_enabled(init->job))
-        {
-            int result = hb_qsv_create_ffmpeg_vpp_pool(init, width, height);
-            if (result < 0)
-            {
-                hb_error("hb_create_ffmpeg_pool vpp allocation failed");
-                return result;
-            }
-        }
-
         if (top > 0 || bottom > 0 || left > 0 || right > 0)
         {
             hb_dict_set_int(avsettings, "cx", left);
diff -Naupr a/libhb/deblock.c b/libhb/deblock.c
--- a/libhb/deblock.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/deblock.c	2025-03-31 11:55:35.238884484 +0200
@@ -1,6 +1,6 @@
 /* deblock.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/decavcodec.c b/libhb/decavcodec.c
--- a/libhb/decavcodec.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/decavcodec.c	2025-03-31 11:55:35.238884484 +0200
@@ -1,6 +1,6 @@
 /* decavcodec.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    Copyright 2022 NVIDIA Corporation
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
@@ -53,7 +53,6 @@
 #include "handbrake/extradata.h"
 
 #if HB_PROJECT_FEATURE_QSV
-#include "libavutil/hwcontext_qsv.h"
 #include "handbrake/qsv_common.h"
 #include "handbrake/qsv_libav.h"
 #endif
@@ -577,23 +576,6 @@ static void closePrivData( hb_work_priva
         }
         if ( pv->context && pv->context->codec )
         {
-#if HB_PROJECT_FEATURE_QSV
-            /*
-             * FIXME: knowingly leaked.
-             *
-             * If we're using our FFmpeg QSV wrapper, qsv_decode_end() will call
-             * MFXClose() on the QSV session. Even if decoding is complete, we
-             * still need that session for QSV filtering and/or encoding, so we
-             * we can't close the context here until we implement a proper fix.
-             *
-             * Interestingly, this may cause crashes even when QSV-accelerated
-             * decoding and encoding sessions are independent (e.g. decoding via
-             * libavcodec, but encoding using libhb, without us requesting any
-             * form of communication between the two libmfx sessions).
-             */
-            //if (!(pv->qsv.decode && pv->job != NULL && (pv->job->vcodec & HB_VCODEC_QSV_MASK)))
-            hb_qsv_uninit_dec(pv->context);
-#endif
             hb_avcodec_free_context(&pv->context);
         }
         if ( pv->context )
@@ -1193,17 +1175,7 @@ static hb_buffer_t *copy_frame( hb_work_
     reordered_data_t * reordered = NULL;
     hb_buffer_t      * out;
 
-#if HB_PROJECT_FEATURE_QSV
-    // no need to copy the frame data when decoding with QSV to opaque memory
-    if (hb_qsv_full_path_is_enabled(pv->job) && hb_qsv_get_memory_type(pv->job) == MFX_IOPATTERN_OUT_VIDEO_MEMORY)
-    {
-        out = hb_qsv_copy_avframe_to_video_buffer(pv->job, pv->frame, (AVRational){1,1}, 0);
-    }
-    else
-#endif
-    {
-        out = hb_avframe_to_video_buffer(pv->frame, (AVRational){1,1});
-    }
+    out = hb_avframe_to_video_buffer(pv->frame, (AVRational){1,1});
 
     if (pv->frame->pts != AV_NOPTS_VALUE)
     {
@@ -1871,7 +1843,8 @@ static int decavcodecvInit( hb_work_obje
     hb_buffer_list_clear(&pv->list);
 
 #if HB_PROJECT_FEATURE_QSV
-    if ((pv->qsv.decode = hb_qsv_decode_is_enabled(job)))
+    pv->qsv.decode = hb_qsv_decode_is_enabled(job);
+    if (pv->qsv.decode)
     {
         pv->qsv.codec_name = hb_qsv_decode_get_codec_name(w->codec_param);
         pv->qsv.config.io_pattern = MFX_IOPATTERN_OUT_SYSTEM_MEMORY;
@@ -1968,18 +1941,6 @@ static int decavcodecvInit( hb_work_obje
         avcodec_parameters_to_context(pv->context,
                                   ic->streams[pv->title->video_id]->codecpar);
 
-#if HB_PROJECT_FEATURE_QSV
-        if (pv->qsv.decode &&
-            pv->qsv.config.io_pattern == MFX_IOPATTERN_OUT_VIDEO_MEMORY)
-        {
-            // assign callbacks and job to have access to qsv context from ffmpeg
-            pv->context->get_format      = hb_qsv_get_format;
-            pv->context->get_buffer2     = hb_qsv_get_buffer;
-            pv->context->opaque          = pv->job;
-            pv->context->hwaccel_context = 0;
-        }
-#endif
-
         // Set decoder opts
         AVDictionary * av_opts = NULL;
         if (pv->title->flags & HBTF_NO_IDR)
@@ -1990,17 +1951,13 @@ static int decavcodecvInit( hb_work_obje
 #if HB_PROJECT_FEATURE_QSV
         if (pv->qsv.decode)
         {
-            if (pv->context->codec_id == AV_CODEC_ID_HEVC)
-                av_dict_set( &av_opts, "load_plugin", "hevc_hw", 0 );
-#if defined(_WIN32) || defined(__MINGW32__)
-            if (hb_qsv_get_memory_type(job) == MFX_IOPATTERN_OUT_SYSTEM_MEMORY)
+            if (hb_hwaccel_is_full_hardware_pipeline_enabled(pv->job))
             {
-                hb_qsv_device_init(job);
-                pv->context->hw_device_ctx = av_buffer_ref(job->qsv.ctx->hb_hw_device_ctx);
-                pv->context->get_format = hb_qsv_get_format;
-                pv->context->opaque = pv->job;
+                hb_hwaccel_hwframes_ctx_init(pv->context, job);
+                job->qsv.ctx->hb_ffmpeg_qsv_hw_frames_ctx = av_buffer_ref(pv->context->hw_frames_ctx);
             }
-#endif
+            if (pv->context->codec_id == AV_CODEC_ID_HEVC)
+                av_dict_set( &av_opts, "load_plugin", "hevc_hw", 0 );
         }
 #endif
 
@@ -2190,15 +2147,6 @@ static int decodePacket( hb_work_object_
             }
         }
 
-#if HB_PROJECT_FEATURE_QSV
-        if (pv->qsv.decode &&
-            pv->qsv.config.io_pattern == MFX_IOPATTERN_OUT_VIDEO_MEMORY)
-        {
-            // set the QSV configuration before opening the decoder
-            pv->context->hwaccel_context = &pv->qsv.config;
-        }
-#endif
-
         AVDictionary * av_opts = NULL;
         if (pv->title->flags & HBTF_NO_IDR)
         {
diff -Naupr a/libhb/decavsub.c b/libhb/decavsub.c
--- a/libhb/decavsub.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/decavsub.c	2025-03-31 11:55:35.238884484 +0200
@@ -1,6 +1,6 @@
 /* decavsub.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -12,7 +12,7 @@
 #include "handbrake/decavsub.h"
 #include "handbrake/extradata.h"
 
-struct hb_avsub_context_s
+struct hb_decavsub_context_s
 {
     AVCodecContext * context;
     AVPacket       * pkt;
@@ -37,15 +37,22 @@ struct hb_avsub_context_s
 
 struct hb_work_private_s
 {
-    hb_avsub_context_t * ctx;
+    hb_decavsub_context_t * ctx;
 };
 
-hb_avsub_context_t * decavsubInit( hb_work_object_t * w, hb_job_t * job )
+/***********************************************************************
+ * decavsubInit
+ ***********************************************************************
+ * Init function for libav subtitle decoding that may be wrapped
+ * by HB subtitle decoder
+ **********************************************************************/
+hb_decavsub_context_t * decavsubInit( hb_work_object_t * w, hb_job_t * job )
 {
-    hb_avsub_context_t * ctx = calloc( 1, sizeof( hb_avsub_context_t ) );
+    hb_decavsub_context_t * ctx = calloc( 1, sizeof( hb_decavsub_context_t ) );
 
     if (ctx == NULL)
     {
+        hb_error("decavsubInit: calloc ctx failed");
         return NULL;
     }
     ctx->seen_forced_sub       = 0;
@@ -54,45 +61,55 @@ hb_avsub_context_t * decavsubInit( hb_wo
     ctx->subtitle              = w->subtitle;
 
     const AVCodec  * codec   = avcodec_find_decoder(ctx->subtitle->codec_param);
+    if (codec == NULL)
+    {
+        hb_error("encavsubInit: avcodec_find_decoder failed");
+        goto fail;
+    }
     AVCodecContext * context = avcodec_alloc_context3(codec);
-    context->codec = codec;
+    if (context == NULL)
+    {
+        hb_error("decavsubInit: avcodec_alloc_context3 failed");
+        goto fail;
+    }
 
-    hb_buffer_list_clear(&ctx->list);
-    hb_buffer_list_clear(&ctx->list_pass);
-    ctx->context               = context;
+    ctx->context              = context;
+    context->codec            = codec;
     context->pkt_timebase.num = ctx->subtitle->timebase.num;
     context->pkt_timebase.den = ctx->subtitle->timebase.den;
 
+    if (ctx->subtitle->extradata && ctx->subtitle->extradata->size)
+    {
+        context->extradata = av_malloc(ctx->subtitle->extradata->size);
+        if (context->extradata == NULL)
+        {
+            hb_error("decavsubInit: av_malloc extradata failed");
+            goto fail;
+        }
+        memcpy(context->extradata,
+               ctx->subtitle->extradata->bytes,
+               ctx->subtitle->extradata->size);
+        context->extradata_size = ctx->subtitle->extradata->size;
+    }
+
     // Set decoder opts...
     AVDictionary * av_opts = NULL;
-    if (ctx->subtitle->source == CC608SUB)
+    if (ctx->subtitle->codec_param == AV_CODEC_ID_EIA_608)
     {
         av_dict_set( &av_opts, "data_field", "first", 0 );
         av_dict_set( &av_opts, "real_time", "1", 0 );
     }
-    if (ctx->subtitle->source == VOBSUB && ctx->subtitle->palette_set)
+    else if (ctx->subtitle->codec_param == AV_CODEC_ID_MOV_TEXT)
+    {
+        char * width = hb_strdup_printf("%d", job->title->geometry.width);
+        char * height = hb_strdup_printf("%d", job->title->geometry.height);
+        av_dict_set( &av_opts, "width", width, 0 );
+        av_dict_set( &av_opts, "height", height, 0 );
+        free(width);
+        free(height);
+    }
+    else if (ctx->subtitle->codec_param == AV_CODEC_ID_DVD_SUBTITLE)
     {
-        char * palette = hb_strdup_printf(
-            "%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x",
-            hb_yuv2rgb(ctx->subtitle->palette[0]),
-            hb_yuv2rgb(ctx->subtitle->palette[1]),
-            hb_yuv2rgb(ctx->subtitle->palette[2]),
-            hb_yuv2rgb(ctx->subtitle->palette[3]),
-            hb_yuv2rgb(ctx->subtitle->palette[4]),
-            hb_yuv2rgb(ctx->subtitle->palette[5]),
-            hb_yuv2rgb(ctx->subtitle->palette[6]),
-            hb_yuv2rgb(ctx->subtitle->palette[7]),
-            hb_yuv2rgb(ctx->subtitle->palette[8]),
-            hb_yuv2rgb(ctx->subtitle->palette[9]),
-            hb_yuv2rgb(ctx->subtitle->palette[10]),
-            hb_yuv2rgb(ctx->subtitle->palette[11]),
-            hb_yuv2rgb(ctx->subtitle->palette[12]),
-            hb_yuv2rgb(ctx->subtitle->palette[13]),
-            hb_yuv2rgb(ctx->subtitle->palette[14]),
-            hb_yuv2rgb(ctx->subtitle->palette[15]));
-        av_dict_set( &av_opts, "palette", palette, 0 );
-        free(palette);
-
         // Make the decoder output empty and fully transparent
         // subtitles, to avoid collecting valid packets together.
         // There is no way to distinguish a partial packet from a zero
@@ -106,45 +123,46 @@ hb_avsub_context_t * decavsubInit( hb_wo
     if (hb_avcodec_open(ctx->context, codec, &av_opts, 0))
     {
         av_dict_free( &av_opts );
-        free(ctx);
-        hb_log("decsubInit: avcodec_open failed");
-        return NULL;
+        hb_error("decavsubInit: avcodec_open failed");
+        goto fail;
     }
     av_dict_free( &av_opts );
 
     ctx->pkt = av_packet_alloc();
     if (ctx->pkt == NULL)
     {
-        hb_log("decsubInit: av_packet_alloc failed");
+        hb_log("decavsubInit: av_packet_alloc failed");
         return NULL;
     }
 
-    if (ctx->subtitle->format == TEXTSUB)
+    // avcodec may create or change subtitle header
+    if (context->subtitle_header != NULL && context->subtitle_header_size > 0)
     {
-        int height = job->title->geometry.height - job->crop[0] - job->crop[1];
-        int width  = job->title->geometry.width -  job->crop[2] - job->crop[3];
-        switch (ctx->subtitle->codec_param)
+        int ret = hb_set_extradata(&ctx->subtitle->extradata,
+                                   context->subtitle_header,
+                                   context->subtitle_header_size);
+        if (ret != 0)
         {
-            case AV_CODEC_ID_ASS:
-            {
-                // Extradata should already be filled in by demux
-            } break;
+            hb_error("decavsubInit: malloc subtitle extradata failed");
+            goto fail;
+        }
+    }
+    hb_buffer_list_clear(&ctx->list);
+    hb_buffer_list_clear(&ctx->list_pass);
 
-            case AV_CODEC_ID_EIA_608:
-            {
-                // Mono font for CC
-                hb_set_ssa_extradata(&ctx->subtitle->extradata,
-                                     HB_FONT_MONO, 20, 384, 288);
-            } break;
+    return ctx;
 
-            default:
-            {
-                hb_set_ssa_extradata(&ctx->subtitle->extradata, HB_FONT_SANS,
-                                     .066 * job->title->geometry.height, width, height);
-            } break;
+fail:
+    if (ctx != NULL)
+    {
+        if (ctx->context != NULL)
+        {
+            avcodec_free_context(&ctx->context);
         }
     }
-    return ctx;
+    free(ctx);
+
+    return NULL;
 }
 
 static int decsubInit( hb_work_object_t * w, hb_job_t * job )
@@ -287,7 +305,7 @@ static const char * ssa_text(const char
     return text;
 }
 
-int decavsubWork( hb_avsub_context_t * ctx,
+int decavsubWork( hb_decavsub_context_t * ctx,
                   hb_buffer_t ** buf_in,
                   hb_buffer_t ** buf_out )
 {
@@ -305,8 +323,7 @@ int decavsubWork( hb_avsub_context_t * c
     }
 
     if (!ctx->job->indepth_scan &&
-        ctx->subtitle->config.dest == PASSTHRUSUB &&
-        hb_subtitle_can_pass(ctx->subtitle->source, ctx->job->mux))
+        !hb_subtitle_must_burn(ctx->subtitle, ctx->job->mux))
     {
         // Append to buffer list.  It will be sent to fifo after we determine
         // if this is a packet we need.
@@ -518,8 +535,7 @@ int decavsubWork( hb_avsub_context_t * c
             }
             hb_buffer_list_close(&ctx->list_pass);
         }
-        else if (ctx->subtitle->config.dest == PASSTHRUSUB &&
-                 hb_subtitle_can_pass(ctx->subtitle->source, ctx->job->mux))
+        else if (!hb_subtitle_must_burn(ctx->subtitle, ctx->job->mux))
         {
             // PICTURESUB && PASSTHRUSUB
 
@@ -688,7 +704,7 @@ static int decsubWork( hb_work_object_t
     return decavsubWork(pv->ctx, buf_in, buf_out );
 }
 
-void decavsubClose( hb_avsub_context_t * ctx )
+void decavsubClose( hb_decavsub_context_t * ctx )
 {
     if (ctx == NULL)
     {
diff -Naupr a/libhb/declpcm.c b/libhb/declpcm.c
--- a/libhb/declpcm.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/declpcm.c	2025-03-31 11:55:35.238884484 +0200
@@ -1,6 +1,6 @@
 /* declpcm.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/decomb.c b/libhb/decomb.c
--- a/libhb/decomb.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/decomb.c	2025-03-31 11:55:35.238884484 +0200
@@ -1,6 +1,6 @@
 /* decomb.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/decsrtsub.c b/libhb/decsrtsub.c
--- a/libhb/decsrtsub.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/decsrtsub.c	2025-03-31 11:55:35.239884466 +0200
@@ -1,6 +1,6 @@
 /* decsrtsub.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -42,7 +42,7 @@ typedef struct srt_entry_s {
  */
 struct hb_work_private_s
 {
-    hb_avsub_context_t * ctx;
+    hb_decavsub_context_t * ctx;
     hb_job_t * job;
     FILE     * file;
     char       buf[1024];
@@ -496,6 +496,11 @@ static int decsrtInit( hb_work_object_t
     {
         goto fail;
     }
+
+    // For SRT files, libav will generate an SSA subtitle header for us.
+    // We will copy it into subtitle extradata after the decoder is
+    // initialized
+
     pv->ctx = decavsubInit(w, job);
     if (pv->ctx == NULL)
     {
@@ -564,12 +569,6 @@ static int decsrtInit( hb_work_object_t
         }
     }
 
-    // Generate generic SSA Script Info.
-    int height = job->title->geometry.height - job->crop[0] - job->crop[1];
-    int width = job->title->geometry.width - job->crop[2] - job->crop[3];
-    hb_set_ssa_extradata(&w->subtitle->extradata, HB_FONT_SANS,
-                         .066 * job->title->geometry.height,
-                         width, height);
     return 0;
 
 fail:
diff -Naupr a/libhb/decssasub.c b/libhb/decssasub.c
--- a/libhb/decssasub.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/decssasub.c	2025-03-31 11:55:35.239884466 +0200
@@ -1,6 +1,6 @@
 /* decssasub.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -31,11 +31,11 @@
 
 struct hb_work_private_s
 {
-    AVFormatContext    * ic;
-    hb_avsub_context_t * ctx;
-    AVPacket           * pkt;
-    hb_job_t           * job;
-    hb_subtitle_t      * subtitle;
+    AVFormatContext       * ic;
+    hb_decavsub_context_t * ctx;
+    AVPacket              * pkt;
+    hb_job_t              * job;
+    hb_subtitle_t         * subtitle;
 
     // Time of first desired subtitle adjusted by reader_pts_offset
     uint64_t start_time;
@@ -58,7 +58,7 @@ static int extradataInit( hb_work_privat
     }
     if (st->codecpar->extradata != NULL)
     {
-        hb_set_text_extradata(&pv->subtitle->extradata, st->codecpar->extradata, st->codecpar->extradata_size);
+        hb_set_extradata(&pv->subtitle->extradata, st->codecpar->extradata, st->codecpar->extradata_size);
     }
     return 0;
 }
@@ -107,6 +107,12 @@ static int decssaInit( hb_work_object_t
     {
         goto fail;
     }
+
+    pv->ctx = decavsubInit(w, job);
+    if (pv->ctx == NULL)
+    {
+        goto fail;
+    }
 
     /*
      * Figure out the start and stop times from the chapters being
diff -Naupr a/libhb/dectx3gsub.c b/libhb/dectx3gsub.c
--- a/libhb/dectx3gsub.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/dectx3gsub.c	2025-03-31 11:55:35.239884466 +0200
@@ -1,6 +1,6 @@
 /* dectx3gsub.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -259,11 +259,22 @@ static int dectx3gInit( hb_work_object_t
     // parse w->subtitle->extradata txg3 sample description into
     // SSA format and replace extradata.
     // For now we just create a generic SSA Script Info.
-    int height = job->title->geometry.height - job->crop[0] - job->crop[1];
-    int width = job->title->geometry.width - job->crop[2] - job->crop[3];
-    hb_set_ssa_extradata(&w->subtitle->extradata, HB_FONT_SANS,
-                         .066 * job->title->geometry.height,
-                         width, height);
+    const char *ssa_header =
+        "[Script Info]\r\n"
+        "ScriptType: v4.00+\r\n"
+        "PlayResX: 384\r\n"
+        "PlayResY: 288\r\n"
+        "ScaledBorderAndShadow: yes\r\n"
+        "YCbCr Matrix: None\r\n"
+        "\r\n"
+        "[V4+ Styles]\r\n"
+        "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\r\n"
+        "Style: Default,Arial,16,&Hffffff,&Hffffff,&H0,&H0,0,0,0,0,100,100,0,0,1,1,0,2,10,10,10,1\r\n"
+        "\r\n"
+        "[Events]\r\n"
+        "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\r\n";
+
+    hb_set_extradata(&w->subtitle->extradata, (const uint8_t *)ssa_header, strlen(ssa_header));
 
     return 0;
 }
diff -Naupr a/libhb/deinterlace.c b/libhb/deinterlace.c
--- a/libhb/deinterlace.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/deinterlace.c	2025-03-31 11:55:35.239884466 +0200
@@ -1,6 +1,6 @@
 /* deinterlace.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/demuxmpeg.c b/libhb/demuxmpeg.c
--- a/libhb/demuxmpeg.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/demuxmpeg.c	2025-03-31 11:55:35.239884466 +0200
@@ -1,6 +1,6 @@
 /* demuxmpeg.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/detelecine.c b/libhb/detelecine.c
--- a/libhb/detelecine.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/detelecine.c	2025-03-31 11:55:35.239884466 +0200
@@ -1,6 +1,6 @@
 /* detelecine.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/dovi_common.c b/libhb/dovi_common.c
--- a/libhb/dovi_common.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/dovi_common.c	2025-03-31 11:55:35.239884466 +0200
@@ -1,6 +1,6 @@
 /* dovi_common.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/dvd.c b/libhb/dvd.c
--- a/libhb/dvd.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/dvd.c	2025-03-31 11:55:35.239884466 +0200
@@ -1,6 +1,6 @@
 /* dvd.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/dvdnav.c b/libhb/dvdnav.c
--- a/libhb/dvdnav.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/dvdnav.c	2025-03-31 11:55:35.240884449 +0200
@@ -1,6 +1,6 @@
 /* dvdnav.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/eedi2.c b/libhb/eedi2.c
--- a/libhb/eedi2.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/eedi2.c	2025-03-31 11:55:35.240884449 +0200
@@ -1,6 +1,6 @@
 /* eedi2.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/enc_qsv.c b/libhb/enc_qsv.c
--- a/libhb/enc_qsv.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/enc_qsv.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2505 +0,0 @@
-
-/* ********************************************************************* *\
-
-Copyright (C) 2013 Intel Corporation.  All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-- Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-- Neither the name of Intel Corporation nor the names of its contributors
-may be used to endorse or promote products derived from this software
-without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY INTEL CORPORATION "AS IS" AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL INTEL CORPORATION BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-\* ********************************************************************* */
-
-#include "handbrake/project.h"
-
-#if HB_PROJECT_FEATURE_QSV
-
-#include "handbrake/handbrake.h"
-#include "handbrake/nal_units.h"
-#include "handbrake/hbffmpeg.h"
-#include "handbrake/qsv_common.h"
-#include "handbrake/qsv_memory.h"
-#include "handbrake/h264_common.h"
-#include "handbrake/h265_common.h"
-#include "handbrake/extradata.h"
-
-#include "libavutil/hwcontext_qsv.h"
-#include "libavutil/hwcontext.h"
-#include "vpl/mfxvideo.h"
-
-/*
- * The frame info struct remembers information about each frame across calls to
- * the encoder. Since frames are uniquely identified by their timestamp, we use
- * some bits of the timestamp as an index. The LSB is chosen so that two
- * successive frames will have different values in the bits over any plausible
- * range of frame rates (starting with bit 8 allows any frame rate slower than
- * 352fps). The MSB determines the size of the array. It is chosen so that two
- * frames can't use the same slot during the encoder's max frame delay so that,
- * up to some minimum frame rate, frames are guaranteed to map to different
- * slots (an MSB of 17 which is 2^(17-8+1) = 1024 slots guarantees no collisions
- * down to a rate of 0.7 fps).
- */
-#define FRAME_INFO_MAX2 (8)  // 2^8  = 256;  90000/256    = 352 frames/sec
-#define FRAME_INFO_MIN2 (17) // 2^17 = 128K; 90000/131072 = 0.7 frames/sec
-#define FRAME_INFO_SIZE (1 << (FRAME_INFO_MIN2 - FRAME_INFO_MAX2 + 1))
-#define FRAME_INFO_MASK (FRAME_INFO_SIZE - 1)
-
-int  encqsvInit (hb_work_object_t*, hb_job_t*);
-int  encqsvWork (hb_work_object_t*, hb_buffer_t**, hb_buffer_t**);
-void encqsvClose(hb_work_object_t*);
-
-hb_work_object_t hb_encqsv =
-{
-    WORK_ENCQSV,
-    "Quick Sync Video encoder (Intel Media SDK)",
-    encqsvInit,
-    encqsvWork,
-    encqsvClose
-};
-
-struct hb_work_private_s
-{
-    hb_job_t           * job;
-    uint32_t             frames_in;
-    uint32_t             frames_out;
-    int64_t              last_start;
-
-    hb_qsv_param_t       param;
-    hb_qsv_space         enc_space;
-    hb_qsv_info_t      * qsv_info;
-
-    hb_chapter_queue_t * chapter_queue;
-
-#define BFRM_DELAY_MAX 16
-    int                * init_delay;
-    int                  bfrm_delay;
-    int64_t              init_pts[BFRM_DELAY_MAX + 1];
-    hb_list_t          * list_dts;
-
-    int64_t              frame_duration[FRAME_INFO_SIZE];
-
-    int                  async_depth;
-    int                  max_async_depth;
-
-    // if encode-only, system memory used
-    int                  is_sys_mem;
-    mfxSession           mfx_session;
-
-    // whether the encoder is initialized
-    int                  init_done;
-
-    hb_list_t          * delayed_processing;
-    hb_buffer_list_t     encoded_frames;
-
-    hb_list_t          * loaded_plugins;
-};
-
-static void hb_qsv_add_new_dts(hb_list_t *list, int64_t new_dts)
-{
-    if (list != NULL)
-    {
-        int64_t *item = malloc(sizeof(int64_t));
-        if (item != NULL)
-        {
-            *item = new_dts;
-            hb_list_add(list, item);
-        }
-    }
-}
-
-static int64_t hb_qsv_pop_next_dts(hb_list_t *list)
-{
-    int64_t next_dts = INT64_MIN;
-    if (list != NULL && hb_list_count(list) > 0)
-    {
-        int64_t *item = hb_list_item(list, 0);
-        if (item != NULL)
-        {
-            next_dts = *item;
-            hb_list_rem(list, item);
-            free(item);
-        }
-    }
-    return next_dts;
-}
-
-static void save_frame_duration(hb_work_private_t *pv, hb_buffer_t *buf)
-{
-    int i = (buf->s.start >> FRAME_INFO_MAX2) & FRAME_INFO_MASK;
-    pv->frame_duration[i] = buf->s.stop - buf->s.start;
-}
-
-static int64_t get_frame_duration(hb_work_private_t *pv, hb_buffer_t *buf)
-{
-    int i = (buf->s.start >> FRAME_INFO_MAX2) & FRAME_INFO_MASK;
-    return pv->frame_duration[i];
-}
-
-static const char* hyper_encode_name(const int hyper_encode_mode)
-{
-    switch (hyper_encode_mode)
-    {
-        case MFX_HYPERMODE_OFF:
-            return "(HyperEncode Off)";
-
-        case MFX_HYPERMODE_ON:
-            return "(HyperEncode On)";
-
-        case MFX_HYPERMODE_ADAPTIVE:
-            return "(HyperEncode Adaptive)";
-
-        default:
-            return NULL;
-    }
-}
-
-static int log_encoder_params(const hb_work_private_t *pv, const mfxVideoParam *videoParam)
-{
-    const mfxExtCodingOption  *option1 = NULL;
-    const mfxExtCodingOption2 *option2 = NULL;
-    const mfxExtAV1ScreenContentTools *extScreenContentCoding = NULL;
-    const mfxExtHyperModeParam *extHyperModeOption = NULL;
-
-    for (int i = 0; i < videoParam->NumExtParam; i++)
-    {
-        mfxExtCodingOption *option = (mfxExtCodingOption*)videoParam->ExtParam[i];
-        if (option->Header.BufferId == MFX_EXTBUFF_CODING_OPTION)
-        {
-            option1 = (mfxExtCodingOption*)videoParam->ExtParam[i];
-        }
-        else if (option->Header.BufferId == MFX_EXTBUFF_CODING_OPTION2)
-        {
-            option2 = (mfxExtCodingOption2*)videoParam->ExtParam[i];
-        }
-        else if (option->Header.BufferId == MFX_EXTBUFF_AV1_SCREEN_CONTENT_TOOLS)
-        {
-            extScreenContentCoding = (mfxExtAV1ScreenContentTools*)videoParam->ExtParam[i];
-        }
-        else if (option->Header.BufferId == MFX_EXTBUFF_HYPER_MODE_PARAM)
-        {
-            extHyperModeOption = (mfxExtHyperModeParam*)videoParam->ExtParam[i];
-        }
-        else if (option->Header.BufferId != MFX_EXTBUFF_VIDEO_SIGNAL_INFO &&
-                 option->Header.BufferId != MFX_EXTBUFF_CHROMA_LOC_INFO &&
-                 option->Header.BufferId != MFX_EXTBUFF_MASTERING_DISPLAY_COLOUR_VOLUME &&
-                 option->Header.BufferId != MFX_EXTBUFF_CONTENT_LIGHT_LEVEL_INFO &&
-                 option->Header.BufferId != MFX_EXTBUFF_AV1_BITSTREAM_PARAM)
-        {
-            hb_log("Unknown Header.BufferId=%d", option->Header.BufferId);
-        }
-    }
-
-    // log code path and main output settings
-    hb_log("encqsvInit: using%s%s%s%s path",
-           hb_qsv_full_path_is_enabled(pv->job) ? " full QSV" : " encode-only",
-           hb_qsv_get_memory_type(pv->job) == MFX_IOPATTERN_OUT_VIDEO_MEMORY ? " via video memory" : " via system memory",
-           videoParam->mfx.LowPower == MFX_CODINGOPTION_ON ? " (LowPower)" : "",
-           extHyperModeOption != NULL ? hyper_encode_name(extHyperModeOption->Mode) : "");
-    hb_log("encqsvInit: %s %s profile @ level %s",
-           hb_qsv_codec_name  (videoParam->mfx.CodecId),
-           hb_qsv_profile_name(videoParam->mfx.CodecId, videoParam->mfx.CodecProfile),
-           hb_qsv_level_name  (videoParam->mfx.CodecId, videoParam->mfx.CodecLevel));
-    hb_log("encqsvInit: TargetUsage %"PRIu16" AsyncDepth %"PRIu16"",
-           videoParam->mfx.TargetUsage, videoParam->AsyncDepth);
-    hb_log("encqsvInit: GopRefDist %"PRIu16" GopPicSize %"PRIu16" NumRefFrame %"PRIu16" IdrInterval %"PRIu16"",
-           videoParam->mfx.GopRefDist, videoParam->mfx.GopPicSize, videoParam->mfx.NumRefFrame, videoParam->mfx.IdrInterval);
-
-    if (extScreenContentCoding && ((extScreenContentCoding->IntraBlockCopy == MFX_CODINGOPTION_ON) || (extScreenContentCoding->Palette == MFX_CODINGOPTION_ON)))
-    {
-        hb_log("encqsvInit: ScreenContentCoding is enabled IBC %s, Palette %s",
-            (extScreenContentCoding->IntraBlockCopy == MFX_CODINGOPTION_ON) ? "on" : "off",
-            (extScreenContentCoding->Palette == MFX_CODINGOPTION_ON) ? "on" : "off");
-    }
-
-    if (pv->qsv_info->capabilities & HB_QSV_CAP_B_REF_PYRAMID)
-    {
-        hb_log("encqsvInit: BFramesMax %d BRefType %s",
-               videoParam->mfx.GopRefDist > 1 ?
-               videoParam->mfx.GopRefDist - 1 : 0,
-               pv->param.gop.b_pyramid ? "pyramid" : "off");
-    }
-    else
-    {
-        hb_log("encqsvInit: BFramesMax %d",
-               videoParam->mfx.GopRefDist > 1 ?
-               videoParam->mfx.GopRefDist - 1 : 0);
-    }
-
-    if (option2 && (option2->AdaptiveI != MFX_CODINGOPTION_OFF ||
-        option2->AdaptiveB != MFX_CODINGOPTION_OFF))
-    {
-        if (videoParam->mfx.GopRefDist > 1)
-        {
-            hb_log("encqsvInit: AdaptiveI %s AdaptiveB %s",
-                hb_qsv_codingoption_get_name(option2->AdaptiveI),
-                hb_qsv_codingoption_get_name(option2->AdaptiveB));
-        }
-        else
-        {
-            hb_log("encqsvInit: AdaptiveI %s",
-                hb_qsv_codingoption_get_name(option2->AdaptiveI));
-        }
-    }
-
-    if (videoParam->mfx.RateControlMethod == MFX_RATECONTROL_CQP)
-    {
-        char qpi[7], qpp[9], qpb[9];
-        snprintf(qpi, sizeof(qpi),  "QPI %"PRIu16"", videoParam->mfx.QPI);
-        snprintf(qpp, sizeof(qpp), " QPP %"PRIu16"", videoParam->mfx.QPP);
-        snprintf(qpb, sizeof(qpb), " QPB %"PRIu16"", videoParam->mfx.QPB);
-        hb_log("encqsvInit: RateControlMethod CQP with %s%s%s", qpi,
-               videoParam->mfx.GopPicSize > 1 ? qpp : "",
-               videoParam->mfx.GopRefDist > 1 ? qpb : "");
-    }
-    else
-    {
-        switch (videoParam->mfx.RateControlMethod)
-        {
-            case MFX_RATECONTROL_LA:
-                hb_log("encqsvInit: RateControlMethod LA TargetKbps %"PRIu16" BRCParamMultiplier %"PRIu16" LookAheadDepth %"PRIu16"",
-                       videoParam->mfx.TargetKbps, videoParam->mfx.BRCParamMultiplier, (option2 != NULL) ? option2->LookAheadDepth : 0);
-                break;
-            case MFX_RATECONTROL_LA_ICQ:
-                hb_log("encqsvInit: RateControlMethod LA_ICQ ICQQuality %"PRIu16" LookAheadDepth %"PRIu16"",
-                       videoParam->mfx.ICQQuality, (option2 != NULL) ? option2->LookAheadDepth : 0);
-                break;
-            case MFX_RATECONTROL_ICQ:
-                hb_log("encqsvInit: RateControlMethod ICQ ICQQuality %"PRIu16"",
-                       videoParam->mfx.ICQQuality);
-                break;
-            case MFX_RATECONTROL_CBR:
-            case MFX_RATECONTROL_VBR:
-                hb_log("encqsvInit: RateControlMethod %s TargetKbps %"PRIu16" MaxKbps %"PRIu16" BufferSizeInKB %"PRIu16" InitialDelayInKB %"PRIu16" BRCParamMultiplier %"PRIu16"",
-                       videoParam->mfx.RateControlMethod == MFX_RATECONTROL_CBR ? "CBR" : "VBR",
-                       videoParam->mfx.TargetKbps,     videoParam->mfx.MaxKbps,
-                       videoParam->mfx.BufferSizeInKB, videoParam->mfx.InitialDelayInKB, videoParam->mfx.BRCParamMultiplier);
-                break;
-            default:
-                hb_log("encqsvInit: invalid rate control method %"PRIu16"",
-                       videoParam->mfx.RateControlMethod);
-                return -1;
-        }
-    }
-
-    if (option2 && (videoParam->mfx.RateControlMethod == MFX_RATECONTROL_LA ||
-        videoParam->mfx.RateControlMethod == MFX_RATECONTROL_LA_ICQ))
-    {
-        switch (option2->LookAheadDS)
-        {
-            case MFX_LOOKAHEAD_DS_UNKNOWN:
-                hb_log("encqsvInit: LookAheadDS unknown (auto)");
-                break;
-            case MFX_LOOKAHEAD_DS_OFF: // default
-                break;
-            case MFX_LOOKAHEAD_DS_2x:
-                hb_log("encqsvInit: LookAheadDS 2x");
-                break;
-            case MFX_LOOKAHEAD_DS_4x:
-                hb_log("encqsvInit: LookAheadDS 4x");
-                break;
-            default:
-                hb_log("encqsvInit: invalid LookAheadDS value 0x%"PRIx16"",
-                       option2->LookAheadDS);
-                break;
-        }
-    }
-
-    switch (videoParam->mfx.FrameInfo.PicStruct)
-    {
-        case MFX_PICSTRUCT_PROGRESSIVE: // default
-            break;
-        case MFX_PICSTRUCT_FIELD_TFF:
-            hb_log("encqsvInit: PicStruct top field first");
-            break;
-        case MFX_PICSTRUCT_FIELD_BFF:
-            hb_log("encqsvInit: PicStruct bottom field first");
-            break;
-        default:
-            hb_error("encqsvInit: invalid PicStruct value 0x%"PRIx16"",
-                     videoParam->mfx.FrameInfo.PicStruct);
-            return -1;
-    }
-
-    if (videoParam->mfx.CodecId == MFX_CODEC_AVC)
-    {
-        if (option1 && (option1->CAVLC != MFX_CODINGOPTION_OFF))
-        {
-            hb_log("encqsvInit: CAVLC %s",
-                hb_qsv_codingoption_get_name(option1->CAVLC));
-        }
-    }
-
-    if (option2 && (option2->ExtBRC != MFX_CODINGOPTION_OFF))
-    {
-        hb_log("encqsvInit: ExtBRC %s",
-            hb_qsv_codingoption_get_name(option2->ExtBRC));
-    }
-
-    if (option2 && (option2->MBBRC != MFX_CODINGOPTION_OFF))
-    {
-        hb_log("encqsvInit: MBBRC %s",
-            hb_qsv_codingoption_get_name(option2->MBBRC));
-    }
-
-    if (option2)
-    {
-        switch (option2->Trellis)
-        {
-            case MFX_TRELLIS_OFF: // default
-                break;
-            case MFX_TRELLIS_UNKNOWN:
-                hb_log("encqsvInit: Trellis unknown (auto)");
-                break;
-            default:
-                hb_log("encqsvInit: Trellis on (%s%s%s)",
-                       (option2->Trellis & MFX_TRELLIS_I) ? "I" : "",
-                       (option2->Trellis & MFX_TRELLIS_P) &&
-                       (videoParam->mfx.GopPicSize > 1)    ? "P" : "",
-                       (option2->Trellis & MFX_TRELLIS_B) &&
-                       (videoParam->mfx.GopRefDist > 1)    ? "B" : "");
-                break;
-        }
-    }
-
-    if (option2 && (option2->RepeatPPS != MFX_CODINGOPTION_OFF))
-    {
-        hb_log("encqsvInit: RepeatPPS %s",
-            hb_qsv_codingoption_get_name(option2->RepeatPPS));
-    }
-    return 0;
-}
-
-static void qsv_handle_breftype(hb_work_private_t *pv)
-{
-    /*
-     * If B-pyramid is not possible (not supported, incompatible profile, etc.)
-     * we don't need to adjust any settings, just sanitize it to off and return.
-     */
-    if (!(pv->qsv_info->capabilities & HB_QSV_CAP_B_REF_PYRAMID))
-    {
-        /* B-pyramid support not implemented */
-        goto unsupported;
-    }
-    else if (pv->param.videoParam->mfx.GopPicSize &&
-             pv->param.videoParam->mfx.GopPicSize <= 3)
-    {
-        /* GOP size must be at least 4 for B-pyramid */
-        goto unsupported;
-    }
-    else if (pv->param.videoParam->mfx.GopRefDist &&
-             pv->param.videoParam->mfx.GopRefDist <= 2)
-    {
-        /* We need 2 consecutive B-frames for B-pyramid (GopRefDist >= 3) */
-        goto unsupported;
-    }
-    else if (pv->param.videoParam->mfx.CodecId == MFX_CODEC_AVC)
-    {
-        switch (pv->param.videoParam->mfx.CodecProfile)
-        {
-            case MFX_PROFILE_AVC_BASELINE:
-            case MFX_PROFILE_AVC_CONSTRAINED_HIGH:
-            case MFX_PROFILE_AVC_CONSTRAINED_BASELINE:
-                goto unsupported; // B-frames not allowed by profile
-            default:
-                break;
-        }
-    }
-    else if (pv->param.videoParam->mfx.CodecId == MFX_CODEC_HEVC)
-    {
-        switch (pv->param.videoParam->mfx.CodecProfile)
-        {
-            case MFX_PROFILE_HEVC_MAINSP:
-                goto unsupported; // B-frames not allowed by profile
-            default:
-                break;
-        }
-    }
-
-    /* Handle B-pyramid auto (on for CQP, off otherwise) */
-    if (pv->param.gop.b_pyramid < 0)
-    {
-        pv->param.gop.b_pyramid = pv->param.videoParam->mfx.RateControlMethod == MFX_RATECONTROL_CQP;
-    }
-
-    if (pv->qsv_info->capabilities & HB_QSV_CAP_OPTION2_BREFTYPE)
-    {
-        /* B-pyramid can be controlled directly */
-        if (pv->param.gop.b_pyramid)
-        {
-            pv->param.codingOption2.BRefType = MFX_B_REF_PYRAMID;
-        }
-        else
-        {
-            pv->param.codingOption2.BRefType = MFX_B_REF_OFF;
-        }
-    }
-    else
-    {
-        /*
-         * We can't control B-pyramid directly, do it indirectly by
-         * adjusting GopRefDist, GopPicSize and NumRefFrame instead.
-         */
-        pv->param.codingOption2.BRefType = MFX_B_REF_UNKNOWN;
-
-        /*
-         * pyramid_ref_dist is the closest B-pyramid compatible
-         * value (multiple of 2, >= 4) to the requested GopRefDist.
-         */
-        int pyramid_ref_dist = 4;
-        while (pv->param.videoParam->mfx.GopRefDist > pyramid_ref_dist)
-        {
-            pyramid_ref_dist *= 2;
-        }
-
-        if (pv->param.gop.b_pyramid)
-        {
-            /* GopRefDist must be B-pyramid compatible */
-            pv->param.videoParam->mfx.GopRefDist = pyramid_ref_dist;
-
-            /*
-             * GopPicSize must be a multiple of GopRefDist.
-             *
-             * Note: GopPicSize == 0 should always result in a value
-             *       that doesn't cause Media SDK to disable B-pyramid.
-             */
-            if (pv->param.videoParam->mfx.GopPicSize)
-            {
-                pv->param.videoParam->mfx.GopPicSize = FFALIGN(pv->param.videoParam->mfx.GopPicSize,
-                                                               pv->param.videoParam->mfx.GopRefDist);
-            }
-
-            /*
-             * NumRefFrame must be greater than 3 and than half of GopRefDist.
-             * Otherwise, Media SDK may sometimes decide to disable B-pyramid
-             * (whereas sometimes it will simply sanitize NumRefFrame instead).
-             *
-             * Note: Media SDK handles the NumRefFrame == 0 case for us.
-             */
-            if (pv->param.videoParam->mfx.NumRefFrame)
-            {
-                pv->param.videoParam->mfx.NumRefFrame = FFMAX(pv->param.videoParam->mfx.NumRefFrame,
-                                                              pv->param.videoParam->mfx.GopRefDist / 2);
-                pv->param.videoParam->mfx.NumRefFrame = FFMAX(pv->param.videoParam->mfx.NumRefFrame, 3);
-            }
-        }
-        else if (pv->param.videoParam->mfx.GopRefDist == 0 ||
-                 pv->param.videoParam->mfx.GopRefDist == pyramid_ref_dist)
-        {
-            /*
-             * GopRefDist is either B-pyramid compatible or unknown (and thus
-             * potentially compatible), so adjust it to force-disable B-pyramid.
-             */
-            pv->param.videoParam->mfx.GopRefDist = pyramid_ref_dist - 1;
-        }
-    }
-
-    return;
-
-unsupported:
-    pv->param.gop.b_pyramid          = 0;
-    pv->param.codingOption2.BRefType = MFX_B_REF_OFF;
-}
-
-static int qsv_hevc_make_header(hb_work_object_t *w, mfxSession session, const mfxVideoParam *videoParam)
-{
-    size_t len;
-    int ret = 0;
-    uint8_t *buf, *end;
-    mfxBitstream bitstream;
-    mfxStatus status;
-    mfxSyncPoint syncPoint;
-    mfxFrameSurface1 frameSurface1;
-    hb_work_private_t *pv = w->private_data;
-
-    memset(&bitstream,     0, sizeof(mfxBitstream));
-    memset(&syncPoint,     0, sizeof(mfxSyncPoint));
-    memset(&frameSurface1, 0, sizeof(mfxFrameSurface1));
-
-    if (videoParam == NULL)
-    {
-        hb_log("qsv_hevc_make_header: videoParam is NULL");
-        ret = -1;
-        goto end;
-    }
-    /* The bitstream buffer should be able to hold any encoded frame */
-    size_t buf_max_size = videoParam->mfx.BufferSizeInKB * 1000 * ( 0 == videoParam->mfx.BRCParamMultiplier ? 1 : videoParam->mfx.BRCParamMultiplier);
-    bitstream.Data      = av_mallocz(sizeof(uint8_t) * buf_max_size);
-    bitstream.MaxLength = buf_max_size;
-    if (bitstream.Data == NULL)
-    {
-        hb_log("qsv_hevc_make_header: bitstream.Data allocation failed");
-        ret = -1;
-        goto end;
-    }
-
-    /* We only need to encode one frame, so we only need one surface */
-    int bpp12                = (pv->param.videoParam->mfx.FrameInfo.FourCC == MFX_FOURCC_P010) ? 6 : 3;
-    mfxU16 Height            = pv->param.videoParam->mfx.FrameInfo.Height;
-    mfxU16 Width             = pv->param.videoParam->mfx.FrameInfo.Width;
-    frameSurface1.Info       = pv->param.videoParam->mfx.FrameInfo;
-    frameSurface1.Data.Y     = av_mallocz(Width * Height * (bpp12 / 2.0));
-    frameSurface1.Data.VU    = frameSurface1.Data.Y + Width * Height * (bpp12 == 6 ? 2 : 1);
-    frameSurface1.Data.Pitch = Width * (bpp12 == 6 ? 2 : 1);
-
-    /* Encode a single blank frame */
-    do
-    {
-        status = MFXVideoENCODE_EncodeFrameAsync(session, NULL,
-                                                 &frameSurface1,
-                                                 &bitstream,
-                                                 &syncPoint);
-
-        if (status == MFX_ERR_MORE_DATA)
-        {
-            break; // more input needed, but we don't have any
-        }
-        if (status < MFX_ERR_NONE)
-        {
-            hb_log("qsv_hevc_make_header: MFXVideoENCODE_EncodeFrameAsync failed (%d)", status);
-            status = log_encoder_params(pv, pv->param.videoParam);
-            if (status < 0)
-            {
-                hb_error("qsv_hevc_make_header: log_encoder_params failed (%d)", status);
-            }
-            ret = -1;
-            goto end;
-        }
-        if (syncPoint)
-        {
-            break; // we have output
-        }
-        if (status == MFX_WRN_DEVICE_BUSY)
-        {
-            hb_qsv_sleep(1);
-        }
-    }
-    while (status >= MFX_ERR_NONE);
-
-    /* If we don't have any output yet, flush the encoder */
-    if (!syncPoint)
-    {
-        do
-        {
-            status = MFXVideoENCODE_EncodeFrameAsync(session, NULL, NULL,
-                                                     &bitstream,
-                                                     &syncPoint);
-
-            if (status == MFX_ERR_MORE_DATA)
-            {
-                break; // done flushing
-            }
-            if (status < MFX_ERR_NONE)
-            {
-                hb_log("qsv_hevc_make_header: MFXVideoENCODE_EncodeFrameAsync failed (%d)", status);
-                ret = -1;
-                goto end;
-            }
-            if (syncPoint)
-            {
-                break; // we have output
-            }
-            if (status == MFX_WRN_DEVICE_BUSY)
-            {
-                hb_qsv_sleep(1);
-            }
-        }
-        while (status >= MFX_ERR_NONE);
-    }
-
-    /* Still no data at this point, we can't proceed */
-    if (!syncPoint)
-    {
-        hb_log("qsv_hevc_make_header: no sync point");
-        ret = -1;
-        goto end;
-    }
-
-    do
-    {
-        status = MFXVideoCORE_SyncOperation(session, syncPoint, 100);
-    }
-    while (status == MFX_WRN_IN_EXECUTION);
-
-    if (status != MFX_ERR_NONE)
-    {
-        hb_log("qsv_hevc_make_header: MFXVideoCORE_SyncOperation failed (%d)", status);
-        ret = -1;
-        goto end;
-    }
-
-    if (!bitstream.DataLength)
-    {
-        hb_log("qsv_hevc_make_header: no bitstream data");
-        ret = -1;
-        goto end;
-    }
-
-    /* Include any parameter sets and SEI NAL units in the headers. */
-    len = bitstream.DataLength;
-    buf = bitstream.Data + bitstream.DataOffset;
-    end = bitstream.Data + bitstream.DataOffset + bitstream.DataLength;
-
-    size_t extradata_size = 0;
-    uint8_t extradata[HB_CONFIG_MAX_SIZE];
-
-    while ((buf = hb_annexb_find_next_nalu(buf, &len)) != NULL)
-    {
-        switch ((buf[0] >> 1) & 0x3f)
-        {
-            case 32: // VPS_NUT
-            case 33: // SPS_NUT
-            case 34: // PPS_NUT
-            case 39: // PREFIX_SEI_NUT
-            case 40: // SUFFIX_SEI_NUT
-                break;
-            default:
-                len = end - buf;
-                continue;
-        }
-
-        size_t size = hb_nal_unit_write_annexb(NULL, buf, len) + extradata_size;
-        if (sizeof(extradata) < size)
-        {
-            /* Will never happen in practice */
-            hb_log("qsv_hevc_make_header: header too large (size: %lu, max: %lu)",
-                   size, sizeof(extradata));
-        }
-
-        extradata_size += hb_nal_unit_write_annexb(extradata + extradata_size, buf, len);
-        len = end - buf;
-    }
-
-    hb_set_extradata(w->extradata, extradata, extradata_size);
-
-end:
-    if (bitstream.Data)
-        av_free(bitstream.Data);
-    av_free(frameSurface1.Data.Y);
-    return ret;
-}
-
-static void mids_buf_free(void *opaque, uint8_t *data)
-{
-    AVBufferRef *hw_frames_ref = opaque;
-    av_buffer_unref(&hw_frames_ref);
-    av_freep(&data);
-}
-
-static enum AVPixelFormat qsv_map_fourcc(uint32_t fourcc)
-{
-    switch (fourcc) {
-    case MFX_FOURCC_NV12: return AV_PIX_FMT_NV12;
-    case MFX_FOURCC_P010: return AV_PIX_FMT_P010;
-    case MFX_FOURCC_P8:   return AV_PIX_FMT_PAL8;
-    }
-    return AV_PIX_FMT_NONE;
-}
-
-AVBufferRef *hb_qsv_create_mids(AVBufferRef *hw_frames_ref)
-{
-    AVHWFramesContext    *frames_ctx = (AVHWFramesContext*)hw_frames_ref->data;
-    AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;
-    int                  nb_surfaces = frames_hwctx->nb_surfaces;
-
-    AVBufferRef *mids_buf, *hw_frames_ref1;
-    QSVMid *mids;
-    int i;
-
-    hw_frames_ref1 = av_buffer_ref(hw_frames_ref);
-    if (!hw_frames_ref1)
-        return NULL;
-
-    mids = av_calloc(nb_surfaces, sizeof(*mids));
-    if (!mids) {
-        av_buffer_unref(&hw_frames_ref1);
-        return NULL;
-    }
-
-    mids_buf = av_buffer_create((uint8_t*)mids, nb_surfaces * sizeof(*mids),
-                                mids_buf_free, hw_frames_ref1, 0);
-    if (!mids_buf) {
-        av_buffer_unref(&hw_frames_ref1);
-        av_freep(&mids);
-        return NULL;
-    }
-
-    for (i = 0; i < nb_surfaces; i++) {
-        QSVMid *mid = &mids[i];
-        mid->handle_pair   = (mfxHDLPair*)frames_hwctx->surfaces[i].Data.MemId;
-        mid->hw_frames_ref = hw_frames_ref1;
-    }
-
-    return mids_buf;
-}
-
-static int qsv_setup_mids(mfxFrameAllocResponse *resp, AVBufferRef *hw_frames_ref,
-                          AVBufferRef *mids_buf)
-{
-    AVHWFramesContext    *frames_ctx = (AVHWFramesContext*)hw_frames_ref->data;
-    AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;
-    QSVMid                     *mids = (QSVMid*)mids_buf->data;
-    int                  nb_surfaces = frames_hwctx->nb_surfaces;
-    int i;
-
-    // the allocated size of the array is two larger than the number of
-    // surfaces, we store the references to the frames context and the
-    // QSVMid array there
-    resp->mids = av_calloc(nb_surfaces + 2, sizeof(*resp->mids));
-    if (!resp->mids)
-        return AVERROR(ENOMEM);
-
-    for (i = 0; i < nb_surfaces; i++)
-        resp->mids[i] = &mids[i];
-    resp->NumFrameActual = nb_surfaces;
-
-    resp->mids[resp->NumFrameActual] = (mfxMemId)av_buffer_ref(hw_frames_ref);
-    if (!resp->mids[resp->NumFrameActual]) {
-        av_freep(&resp->mids);
-        return AVERROR(ENOMEM);
-    }
-
-    resp->mids[resp->NumFrameActual + 1] = av_buffer_ref(mids_buf);
-    if (!resp->mids[resp->NumFrameActual + 1]) {
-        av_buffer_unref((AVBufferRef**)&resp->mids[resp->NumFrameActual]);
-        av_freep(&resp->mids);
-        return AVERROR(ENOMEM);
-    }
-
-    return 0;
-}
-
-static mfxStatus hb_qsv_frame_alloc(mfxHDL pthis, mfxFrameAllocRequest *req,
-                                 mfxFrameAllocResponse *resp)
-{
-    HBQSVFramesContext *ctx = pthis;
-    int ret;
-
-    /* this should only be called from an encoder or decoder and
-     * only allocates video memory frames */
-    if (!(req->Type & (MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET |
-                       MFX_MEMTYPE_VIDEO_MEMORY_PROCESSOR_TARGET))         ||
-        !(req->Type & (MFX_MEMTYPE_FROM_DECODE | MFX_MEMTYPE_FROM_ENCODE)))
-        return MFX_ERR_UNSUPPORTED;
-
-    if (req->Type & MFX_MEMTYPE_EXTERNAL_FRAME) {
-        /* external frames -- fill from the caller-supplied frames context */
-        AVHWFramesContext *frames_ctx = (AVHWFramesContext*)ctx->hw_frames_ctx->data;
-        AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;
-        mfxFrameInfo      *i  = &req->Info;
-        mfxFrameInfo      *i1 = &frames_hwctx->surfaces[0].Info;
-
-        if (i->Width  > i1->Width  || i->Height > i1->Height ||
-            i->FourCC != i1->FourCC || i->ChromaFormat != i1->ChromaFormat) {
-            hb_error("Mismatching surface properties in an "
-                   "allocation request: %dx%d %d %d vs %dx%d %d %d\n",
-                   i->Width,  i->Height,  i->FourCC,  i->ChromaFormat,
-                   i1->Width, i1->Height, i1->FourCC, i1->ChromaFormat);
-            return MFX_ERR_UNSUPPORTED;
-        }
-
-        ret = qsv_setup_mids(resp, ctx->hw_frames_ctx, ctx->mids_buf);
-        if (ret < 0) {
-            hb_error("Error filling an external frame allocation request\n");
-            return MFX_ERR_MEMORY_ALLOC;
-        }
-    } else if (req->Type & MFX_MEMTYPE_INTERNAL_FRAME) {
-        /* internal frames -- allocate a new hw frames context */
-        AVHWFramesContext *ext_frames_ctx = (AVHWFramesContext*)ctx->hw_frames_ctx->data;
-        mfxFrameInfo      *i  = &req->Info;
-
-        AVBufferRef *frames_ref, *mids_buf;
-        AVHWFramesContext *frames_ctx;
-        AVQSVFramesContext *frames_hwctx;
-
-        frames_ref = av_hwframe_ctx_alloc(ext_frames_ctx->device_ref);
-        if (!frames_ref)
-            return MFX_ERR_MEMORY_ALLOC;
-
-        frames_ctx   = (AVHWFramesContext*)frames_ref->data;
-        frames_hwctx = frames_ctx->hwctx;
-
-        frames_ctx->format            = AV_PIX_FMT_QSV;
-        frames_ctx->sw_format         = qsv_map_fourcc(i->FourCC);
-        frames_ctx->width             = i->Width;
-        frames_ctx->height            = i->Height;
-        frames_ctx->initial_pool_size = req->NumFrameSuggested;
-
-        frames_hwctx->frame_type      = req->Type;
-
-        ret = av_hwframe_ctx_init(frames_ref);
-        if (ret < 0) {
-            hb_error("Error initializing a frames context for an internal frame "
-                   "allocation request\n");
-            av_buffer_unref(&frames_ref);
-            return MFX_ERR_MEMORY_ALLOC;
-        }
-
-        mids_buf = hb_qsv_create_mids(frames_ref);
-        if (!mids_buf) {
-            av_buffer_unref(&frames_ref);
-            return MFX_ERR_MEMORY_ALLOC;
-        }
-
-        ret = qsv_setup_mids(resp, frames_ref, mids_buf);
-        av_buffer_unref(&mids_buf);
-        av_buffer_unref(&frames_ref);
-        if (ret < 0) {
-            hb_error("Error filling an internal frame allocation request\n");
-            return MFX_ERR_MEMORY_ALLOC;
-        }
-    } else {
-        return MFX_ERR_UNSUPPORTED;
-    }
-
-    return MFX_ERR_NONE;
-}
-
-static mfxStatus hb_qsv_frame_free(mfxHDL pthis, mfxFrameAllocResponse *resp)
-{
-    av_buffer_unref((AVBufferRef**)&resp->mids[resp->NumFrameActual]);
-    av_buffer_unref((AVBufferRef**)&resp->mids[resp->NumFrameActual + 1]);
-    av_freep(&resp->mids);
-    return MFX_ERR_NONE;
-}
-
-static mfxStatus hb_qsv_frame_lock(mfxHDL pthis, mfxMemId mid, mfxFrameData *ptr)
-{
-    QSVMid *qsv_mid = mid;
-    AVHWFramesContext *hw_frames_ctx = (AVHWFramesContext*)qsv_mid->hw_frames_ref->data;
-    AVQSVFramesContext *hw_frames_hwctx = hw_frames_ctx->hwctx;
-    int ret;
-
-    if (qsv_mid->locked_frame)
-        return MFX_ERR_UNDEFINED_BEHAVIOR;
-
-    /* Allocate a system memory frame that will hold the mapped data. */
-    qsv_mid->locked_frame = av_frame_alloc();
-    if (!qsv_mid->locked_frame)
-        return MFX_ERR_MEMORY_ALLOC;
-    qsv_mid->locked_frame->format  = hw_frames_ctx->sw_format;
-
-    /* wrap the provided handle in a hwaccel AVFrame */
-    qsv_mid->hw_frame = av_frame_alloc();
-    if (!qsv_mid->hw_frame)
-        goto fail;
-
-    qsv_mid->hw_frame->data[3] = (uint8_t*)&qsv_mid->surf;
-    qsv_mid->hw_frame->format  = AV_PIX_FMT_QSV;
-
-    // doesn't really matter what buffer is used here
-    qsv_mid->hw_frame->buf[0]  = av_buffer_alloc(1);
-    if (!qsv_mid->hw_frame->buf[0])
-        goto fail;
-
-    qsv_mid->hw_frame->width   = hw_frames_ctx->width;
-    qsv_mid->hw_frame->height  = hw_frames_ctx->height;
-
-    qsv_mid->hw_frame->hw_frames_ctx = av_buffer_ref(qsv_mid->hw_frames_ref);
-    if (!qsv_mid->hw_frame->hw_frames_ctx)
-        goto fail;
-
-    qsv_mid->surf.Info = hw_frames_hwctx->surfaces[0].Info;
-    qsv_mid->surf.Data.MemId = qsv_mid->handle_pair;
-
-    /* map the data to the system memory */
-    ret = av_hwframe_map(qsv_mid->locked_frame, qsv_mid->hw_frame,
-                         AV_HWFRAME_MAP_DIRECT);
-    if (ret < 0)
-        goto fail;
-
-    ptr->Pitch = qsv_mid->locked_frame->linesize[0];
-    ptr->Y     = qsv_mid->locked_frame->data[0];
-    ptr->U     = qsv_mid->locked_frame->data[1];
-    ptr->V     = qsv_mid->locked_frame->data[1] + 1;
-
-    return MFX_ERR_NONE;
-fail:
-    av_frame_free(&qsv_mid->hw_frame);
-    av_frame_free(&qsv_mid->locked_frame);
-    return MFX_ERR_MEMORY_ALLOC;
-}
-
-static mfxStatus hb_qsv_frame_unlock(mfxHDL pthis, mfxMemId mid, mfxFrameData *ptr)
-{
-    QSVMid *qsv_mid = mid;
-
-    av_frame_free(&qsv_mid->locked_frame);
-    av_frame_free(&qsv_mid->hw_frame);
-
-    return MFX_ERR_NONE;
-}
-
-static mfxStatus hb_qsv_frame_get_hdl(mfxHDL pthis, mfxMemId mid, mfxHDL *hdl)
-{
-    QSVMid *qsv_mid = (QSVMid*)mid;
-    mfxHDLPair *pair_dst = (mfxHDLPair*)hdl;
-    mfxHDLPair *pair_src = (mfxHDLPair*)qsv_mid->handle_pair;
-
-    pair_dst->first = pair_src->first;
-    if (pair_src->second != (mfxMemId)MFX_INFINITE)
-        pair_dst->second = pair_src->second;
-
-    return MFX_ERR_NONE;
-}
-
-#define QSV_RUNTIME_VERSION_ATLEAST(MFX_VERSION, MAJOR, MINOR) \
-    (MFX_VERSION.Major > (MAJOR)) ||                           \
-    (MFX_VERSION.Major == (MAJOR) && MFX_VERSION.Minor >= (MINOR))
-
-int qsv_enc_init(hb_work_private_t *pv)
-{
-    hb_qsv_context *qsv = pv->job->qsv.ctx;
-    hb_job_t       *job = pv->job;
-    mfxVersion version;
-    mfxStatus sts;
-    mfxIMPL impl;
-    int i;
-
-    if (pv->init_done)
-    {
-        return 0;
-    }
-
-    if (qsv == NULL)
-    {
-        hb_error("qsv_enc_init: no context!");
-        return 3;
-    }
-
-    hb_qsv_space *qsv_encode = qsv->enc_space;
-    if (qsv_encode == NULL)
-    {
-        // if only for encode
-        if (pv->is_sys_mem)
-        {
-            // re-use the session from encqsvInit
-            qsv->mfx_session = pv->mfx_session;
-        }
-        else
-        {
-            mfxStatus err;
-
-            mfxVersion    ver;
-            mfxIMPL       impl;
-
-            AVHWDeviceContext    *device_ctx = (AVHWDeviceContext*)qsv->hb_hw_device_ctx->data;
-            AVQSVDeviceContext *device_hwctx = device_ctx->hwctx;
-            mfxSession        parent_session = device_hwctx->session;
-
-            err = MFXQueryIMPL(parent_session, &impl);
-            if (err != MFX_ERR_NONE)
-            {
-                hb_error("Error querying the session attributes");
-                return -1;
-            }
-
-            err = MFXQueryVersion(parent_session, &ver);
-            if (err != MFX_ERR_NONE)
-            {
-                hb_error("Error querying the session attributes");
-                return -1;
-            }
-
-            // reuse parent session
-            qsv->mfx_session = parent_session;
-            mfxFrameAllocator frame_allocator = {
-                .pthis  = pv->job->qsv.ctx->hb_dec_qsv_frames_ctx,
-                .Alloc  = hb_qsv_frame_alloc,
-                .Lock   = hb_qsv_frame_lock,
-                .Unlock = hb_qsv_frame_unlock,
-                .GetHDL = hb_qsv_frame_get_hdl,
-                .Free   = hb_qsv_frame_free,
-            };
-
-            if (hb_qsv_hw_filters_via_video_memory_are_enabled(pv->job) || hb_qsv_hw_filters_via_system_memory_are_enabled(pv->job))
-            {
-                frame_allocator.pthis = pv->job->qsv.ctx->hb_vpp_qsv_frames_ctx;
-            }
-
-            err = MFXVideoCORE_SetFrameAllocator(qsv->mfx_session, &frame_allocator);
-            if (err != MFX_ERR_NONE)
-            {
-                hb_log("encqsvInit: MFXVideoCORE_SetFrameAllocator error %d", err);
-                return -1;
-            }
-        }
-        qsv->enc_space = qsv_encode = &pv->enc_space;
-    }
-
-    if (!pv->is_sys_mem)
-    {
-        hb_qsv_space *dec_space = qsv->dec_space;
-        if (dec_space == NULL || !dec_space->is_init_done)
-        {
-            return 2;
-        }
-    }
-
-    // allocate tasks
-    qsv_encode->p_buf_max_size = pv->param.videoParam->mfx.BufferSizeInKB * 1000 * ( 0 == pv->param.videoParam->mfx.BRCParamMultiplier ? 1 : pv->param.videoParam->mfx.BRCParamMultiplier);
-    qsv_encode->tasks          = hb_qsv_list_init(HAVE_THREADS);
-    for (i = 0; i < pv->max_async_depth; i++)
-    {
-        hb_qsv_task *task    = av_mallocz(sizeof(hb_qsv_task));
-        task->bs             = av_mallocz(sizeof(mfxBitstream));
-        task->bs->Data       = av_mallocz(sizeof(uint8_t) * qsv_encode->p_buf_max_size);
-        task->bs->MaxLength  = qsv_encode->p_buf_max_size;
-        task->bs->DataLength = 0;
-        task->bs->DataOffset = 0;
-        hb_qsv_list_add(qsv_encode->tasks, task);
-    }
-
-    // setup surface allocation
-    pv->param.videoParam->IOPattern = (pv->is_sys_mem                 ?
-                                       MFX_IOPATTERN_IN_SYSTEM_MEMORY :
-                                       MFX_IOPATTERN_IN_VIDEO_MEMORY);
-    memset(&qsv_encode->request, 0, sizeof(mfxFrameAllocRequest) * 2);
-    sts = MFXVideoENCODE_QueryIOSurf(qsv->mfx_session,
-                                     pv->param.videoParam,
-                                     &qsv_encode->request[0]);
-    if (sts < MFX_ERR_NONE) // ignore warnings
-    {
-        hb_error("qsv_enc_init: MFXVideoENCODE_QueryIOSurf failed (%d)", sts);
-        *job->done_error = HB_ERROR_INIT;
-        *job->die = 1;
-        return -1;
-    }
-
-    // allocate surfaces
-    if (pv->is_sys_mem)
-    {
-        qsv_encode->surface_num = FFMIN(qsv_encode->request[0].NumFrameSuggested +
-                                        pv->max_async_depth, HB_QSV_SURFACE_NUM);
-        if (qsv_encode->surface_num <= 0)
-        {
-            qsv_encode->surface_num = HB_QSV_SURFACE_NUM;
-        }
-
-        /* should have 15bpp/AV_PIX_FMT_YUV420P10LE (almost x2) instead of 12bpp/AV_PIX_FMT_NV12 */
-        int bpp12 = (pv->param.videoParam->mfx.CodecProfile == (MFX_PROFILE_HEVC_MAIN10) || (job->vcodec == HB_VCODEC_QSV_AV1_10BIT)) ? 6 : 3;
-        for (i = 0; i < qsv_encode->surface_num; i++)
-        {
-            mfxFrameSurface1 *surface = av_mallocz(sizeof(mfxFrameSurface1));
-            mfxFrameInfo info         = pv->param.videoParam->mfx.FrameInfo;
-            surface->Info             = info;
-            surface->Data.Pitch       = info.Width * (bpp12 == 6 ? 2 : 1);
-            surface->Data.Y           = av_mallocz(info.Width * info.Height * (bpp12 / 2.0));
-            surface->Data.VU          = surface->Data.Y + info.Width * info.Height * (bpp12 == 6 ? 2 : 1);
-            qsv_encode->p_surfaces[i] = surface;
-        }
-    }
-    else
-    {
-        qsv_encode->surface_num = FFMIN(qsv_encode->request[0].NumFrameSuggested +
-                                        pv->max_async_depth, HB_QSV_SURFACE_NUM);
-        if (qsv_encode->surface_num <= 0)
-        {
-            qsv_encode->surface_num = HB_QSV_SURFACE_NUM;
-        }
-    }
-
-    // allocate sync points
-    qsv_encode->sync_num = (qsv_encode->surface_num                         ?
-                            FFMIN(qsv_encode->surface_num, HB_QSV_SYNC_NUM) :
-                            HB_QSV_SYNC_NUM);
-
-    for (i = 0; i < qsv_encode->sync_num; i++)
-    {
-        qsv_encode->p_syncp[i] = av_mallocz(sizeof(hb_qsv_sync));
-        HB_QSV_CHECK_POINTER(qsv_encode->p_syncp[i], MFX_ERR_MEMORY_ALLOC);
-        qsv_encode->p_syncp[i]->p_sync = av_mallocz(sizeof(mfxSyncPoint));
-        HB_QSV_CHECK_POINTER(qsv_encode->p_syncp[i]->p_sync, MFX_ERR_MEMORY_ALLOC);
-    }
-
-    // initialize the encoder
-    sts = MFXVideoENCODE_Init(qsv->mfx_session, pv->param.videoParam);
-    if (sts < MFX_ERR_NONE) // ignore warnings
-    {
-        hb_error("qsv_enc_init: MFXVideoENCODE_Init failed (%d)", sts);
-        *job->done_error = HB_ERROR_INIT;
-        *job->die = 1;
-        return -1;
-    }
-
-    // query and log actual implementation details
-    if ((MFXQueryIMPL   (qsv->mfx_session, &impl)    == MFX_ERR_NONE) &&
-        (MFXQueryVersion(qsv->mfx_session, &version) == MFX_ERR_NONE))
-    {
-        hb_log("qsv_enc_init: using '%s %s' implementation, API: %"PRIu16".%"PRIu16"",
-               hb_qsv_impl_get_name(impl), hb_qsv_impl_get_via_name(impl), version.Major, version.Minor);
-    }
-    else
-    {
-        hb_log("qsv_enc_init: MFXQueryIMPL/MFXQueryVersion failure");
-    }
-
-    qsv_encode->is_init_done = 1;
-    pv->init_done = 1;
-    return 0;
-}
-
-/***********************************************************************
- * encqsvInit
- ***********************************************************************
- *
- **********************************************************************/
-int encqsvInit(hb_work_object_t *w, hb_job_t *job)
-{
-    if (!hb_qsv_available())
-    {
-       hb_error("encqsvInit: qsv is not available on the system");
-       return -1;
-    }
-
-    int brc_param_multiplier;
-    hb_work_private_t *pv = calloc(1, sizeof(hb_work_private_t));
-    w->private_data       = pv;
-
-    pv->is_sys_mem         = (hb_qsv_get_memory_type(job) == MFX_IOPATTERN_OUT_SYSTEM_MEMORY);
-    pv->job                = job;
-    pv->qsv_info           = hb_qsv_encoder_info_get(hb_qsv_get_adapter_index(), job->vcodec);
-    pv->delayed_processing = hb_list_init();
-    pv->last_start         = INT64_MIN;
-    hb_buffer_list_clear(&pv->encoded_frames);
-
-    pv->chapter_queue    = hb_chapter_queue_init();
-
-    if (!pv->qsv_info)
-    {
-        hb_error("encqsvInit: %s codec is not supported by this GPU adapter", hb_video_encoder_get_long_name(job->vcodec));
-        return -1;
-    }
-
-    // default encoding parameters
-    if (hb_qsv_param_default_preset(&pv->param, &pv->enc_space.m_mfxVideoParam,
-                                     pv->qsv_info, job->encoder_preset))
-    {
-        hb_error("encqsvInit: hb_qsv_param_default_preset failed");
-        return -1;
-    }
-
-    // set AsyncDepth to match that of decode and VPP
-    pv->param.videoParam->AsyncDepth = job->qsv.async_depth;
-
-    // set and enable colorimetry (video signal information)
-    pv->param.videoSignalInfo.VideoFullRange = (pv->job->color_range == AVCOL_RANGE_JPEG);
-
-    pv->param.videoSignalInfo.ColourPrimaries          = hb_output_color_prim(job);
-    pv->param.videoSignalInfo.TransferCharacteristics  = hb_output_color_transfer(job);
-    pv->param.videoSignalInfo.MatrixCoefficients       = hb_output_color_matrix(job);
-    pv->param.videoSignalInfo.ColourDescriptionPresent = 1;
-
-    if (job->chroma_location != AVCHROMA_LOC_UNSPECIFIED)
-    {
-        pv->param.chromaLocInfo.ChromaSampleLocTypeBottomField =
-        pv->param.chromaLocInfo.ChromaSampleLocTypeTopField = job->chroma_location - 1;
-        pv->param.chromaLocInfo.ChromaLocInfoPresentFlag = 1;
-    }
-
-    /* HDR10 Static metadata */
-    if (job->color_transfer == HB_COLR_TRA_SMPTEST2084)
-    {
-        if (pv->qsv_info->codec_id == MFX_CODEC_HEVC)
-        {
-            const int masteringChromaDen = 50000;
-            const int masteringLumaDen = 10000;
-
-            /* Mastering display metadata */
-            if (job->mastering.has_primaries && job->mastering.has_luminance)
-            {
-                pv->param.masteringDisplayColourVolume.InsertPayloadToggle = MFX_PAYLOAD_IDR;
-                pv->param.masteringDisplayColourVolume.DisplayPrimariesX[0] = FFMIN(hb_rescale_rational(job->mastering.display_primaries[1][0], masteringChromaDen), masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.DisplayPrimariesY[0] = FFMIN(hb_rescale_rational(job->mastering.display_primaries[1][1], masteringChromaDen), masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.DisplayPrimariesX[1] = FFMIN(hb_rescale_rational(job->mastering.display_primaries[2][0], masteringChromaDen), masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.DisplayPrimariesY[1] = FFMIN(hb_rescale_rational(job->mastering.display_primaries[2][1], masteringChromaDen), masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.DisplayPrimariesX[2] = FFMIN(hb_rescale_rational(job->mastering.display_primaries[0][0], masteringChromaDen), masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.DisplayPrimariesY[2] = FFMIN(hb_rescale_rational(job->mastering.display_primaries[0][1], masteringChromaDen), masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.WhitePointX = FFMIN(hb_rescale_rational(job->mastering.white_point[0], masteringChromaDen), masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.WhitePointY = FFMIN(hb_rescale_rational(job->mastering.white_point[1], masteringChromaDen), masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.MaxDisplayMasteringLuminance = hb_rescale_rational(job->mastering.max_luminance, masteringLumaDen);
-                pv->param.masteringDisplayColourVolume.MinDisplayMasteringLuminance = FFMIN(hb_rescale_rational(job->mastering.min_luminance, masteringLumaDen),
-                    pv->param.masteringDisplayColourVolume.MaxDisplayMasteringLuminance);
-            }
-
-            /*  Content light level */
-            if (job->coll.max_cll && job->coll.max_fall)
-            {
-                pv->param.contentLightLevelInfo.InsertPayloadToggle = MFX_PAYLOAD_IDR;
-                pv->param.contentLightLevelInfo.MaxContentLightLevel  = FFMIN(job->coll.max_cll, 65535);
-                pv->param.contentLightLevelInfo.MaxPicAverageLightLevel = FFMIN(job->coll.max_fall, 65535);
-            }
-        }
-        else if (pv->qsv_info->codec_id == MFX_CODEC_AV1)
-        {
-            const int masteringChromaDen = 1 << 16;
-            const int max_luma_den = 1 << 8;
-            const int min_luma_den = 1 << 14;
-
-            /* Mastering display metadata */
-            if (job->mastering.has_primaries && job->mastering.has_luminance)
-            {
-                pv->param.masteringDisplayColourVolume.InsertPayloadToggle = MFX_PAYLOAD_IDR;
-                pv->param.masteringDisplayColourVolume.DisplayPrimariesX[0] = hb_rescale_rational(job->mastering.display_primaries[0][0], masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.DisplayPrimariesY[0] = hb_rescale_rational(job->mastering.display_primaries[0][1], masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.DisplayPrimariesX[1] = hb_rescale_rational(job->mastering.display_primaries[1][0], masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.DisplayPrimariesY[1] = hb_rescale_rational(job->mastering.display_primaries[1][1], masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.DisplayPrimariesX[2] = hb_rescale_rational(job->mastering.display_primaries[2][0], masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.DisplayPrimariesY[2] = hb_rescale_rational(job->mastering.display_primaries[2][1], masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.WhitePointX = hb_rescale_rational(job->mastering.white_point[0], masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.WhitePointY = hb_rescale_rational(job->mastering.white_point[1], masteringChromaDen);
-                pv->param.masteringDisplayColourVolume.MaxDisplayMasteringLuminance = hb_rescale_rational(job->mastering.max_luminance, max_luma_den);
-                pv->param.masteringDisplayColourVolume.MinDisplayMasteringLuminance = hb_rescale_rational(job->mastering.min_luminance, min_luma_den);
-            }
-
-            /*  Content light level */
-            if (job->coll.max_cll && job->coll.max_fall)
-            {
-                pv->param.contentLightLevelInfo.InsertPayloadToggle = MFX_PAYLOAD_IDR;
-                pv->param.contentLightLevelInfo.MaxContentLightLevel  = job->coll.max_cll;
-                pv->param.contentLightLevelInfo.MaxPicAverageLightLevel = job->coll.max_fall;
-            }
-        }
-    }
-
-    // parse user-specified encoder options, if present
-    if (job->encoder_options != NULL && *job->encoder_options)
-    {
-        hb_dict_t *options_list;
-        options_list = hb_encopts_to_dict(job->encoder_options, job->vcodec);
-
-        hb_dict_iter_t iter;
-        for (iter  = hb_dict_iter_init(options_list);
-             iter != HB_DICT_ITER_DONE;
-             iter  = hb_dict_iter_next(options_list, iter))
-        {
-            const char *key = hb_dict_iter_key(iter);
-            hb_value_t *value = hb_dict_iter_value(iter);
-            char *str = hb_value_get_string_xform(value);
-
-            switch (hb_qsv_param_parse(&pv->param, pv->qsv_info, pv->job, key, str))
-            {
-                case HB_QSV_PARAM_OK:
-                    break;
-
-                case HB_QSV_PARAM_BAD_NAME:
-                    hb_log("encqsvInit: hb_qsv_param_parse: bad key %s", key);
-                    break;
-                case HB_QSV_PARAM_BAD_VALUE:
-                    hb_log("encqsvInit: hb_qsv_param_parse: bad value %s for key %s",
-                           str, key);
-                    break;
-                case HB_QSV_PARAM_UNSUPPORTED:
-                    hb_log("encqsvInit: hb_qsv_param_parse: unsupported option %s",
-                           key);
-                    break;
-
-                case HB_QSV_PARAM_ERROR:
-                default:
-                    hb_log("encqsvInit: hb_qsv_param_parse: unknown error");
-                    break;
-            }
-            free(str);
-        }
-        hb_dict_free(&options_list);
-    }
-#if defined(_WIN32) || defined(__MINGW32__)
-    if (pv->is_sys_mem && hb_qsv_implementation_is_hardware(pv->qsv_info->implementation))
-    {
-        mfxIMPL hw_preference = MFX_IMPL_VIA_D3D11;
-        pv->qsv_info->implementation = hb_qsv_dx_index_to_impl(job->qsv.ctx->dx_index) | hw_preference;
-    }
-#endif
-    // reload colorimetry in case values were set in encoder_options
-    if (pv->param.videoSignalInfo.ColourDescriptionPresent)
-    {
-        job->color_prim_override     = pv->param.videoSignalInfo.ColourPrimaries;
-        job->color_transfer_override = pv->param.videoSignalInfo.TransferCharacteristics;
-        job->color_matrix_override   = pv->param.videoSignalInfo.MatrixCoefficients;
-    }
-
-    // sanitize values that may exceed the Media SDK variable size
-    hb_rational_t par;
-    hb_limit_rational(&par.num, &par.den,
-                      job->par.num, job->par.den, UINT16_MAX);
-
-    // some encoding parameters are used by filters to configure their output
-    int align_width = 0, align_height = 0;
-
-    switch (pv->qsv_info->codec_id)
-    {
-        case MFX_CODEC_HEVC:
-        case MFX_CODEC_AV1:
-            align_width  = HB_QSV_ALIGN32(job->width);
-            align_height = HB_QSV_ALIGN32(job->height);
-            break;
-
-        case MFX_CODEC_AVC:
-        default:
-            align_width  = HB_QSV_ALIGN16(job->width);
-            align_height = HB_QSV_ALIGN16(job->height);
-            break;
-    }
-    if (pv->param.videoParam->mfx.FrameInfo.PicStruct != MFX_PICSTRUCT_PROGRESSIVE)
-    {
-        // additional alignment may be required
-        switch (pv->qsv_info->codec_id)
-        {
-            case MFX_CODEC_AVC:
-                align_height = HB_QSV_ALIGN32(align_height);
-                break;
-
-            default:
-                break;
-        }
-    }
-
-    // set codec, profile/level and FrameInfo
-    pv->param.videoParam->mfx.CodecId                 = pv->qsv_info->codec_id;
-    pv->param.videoParam->mfx.CodecLevel              = MFX_LEVEL_UNKNOWN;
-    pv->param.videoParam->mfx.CodecProfile            = MFX_PROFILE_UNKNOWN;
-    pv->param.videoParam->mfx.FrameInfo.FourCC        = MFX_FOURCC_NV12;
-    pv->param.videoParam->mfx.FrameInfo.ChromaFormat  = MFX_CHROMAFORMAT_YUV420;
-    pv->param.videoParam->mfx.FrameInfo.FrameRateExtN = job->vrate.num;
-    pv->param.videoParam->mfx.FrameInfo.FrameRateExtD = job->vrate.den;
-    pv->param.videoParam->mfx.FrameInfo.AspectRatioW  = par.num;
-    pv->param.videoParam->mfx.FrameInfo.AspectRatioH  = par.den;
-    pv->param.videoParam->mfx.FrameInfo.CropX         = 0;
-    pv->param.videoParam->mfx.FrameInfo.CropY         = 0;
-    pv->param.videoParam->mfx.FrameInfo.CropW         = job->width;
-    pv->param.videoParam->mfx.FrameInfo.CropH         = job->height;
-    pv->param.videoParam->mfx.FrameInfo.Width         = align_width;
-    pv->param.videoParam->mfx.FrameInfo.Height        = align_height;
-
-    // parse user-specified codec profile and level
-    if (hb_qsv_profile_parse(&pv->param, pv->qsv_info, job->encoder_profile, job->vcodec))
-    {
-        hb_error("encqsvInit: bad profile %s", job->encoder_profile);
-        return -1;
-    }
-
-    if (hb_qsv_level_parse(&pv->param, pv->qsv_info, job->encoder_level))
-    {
-        hb_error("encqsvInit: bad level %s", job->encoder_level);
-        return -1;
-    }
-
-    if ((pv->param.videoParam->mfx.CodecProfile == MFX_PROFILE_HEVC_MAIN10) || (job->vcodec == HB_VCODEC_QSV_AV1_10BIT))
-    {
-        pv->param.videoParam->mfx.FrameInfo.FourCC         = MFX_FOURCC_P010;
-        pv->param.videoParam->mfx.FrameInfo.BitDepthLuma   = 10;
-        pv->param.videoParam->mfx.FrameInfo.BitDepthChroma = 10;
-        pv->param.videoParam->mfx.FrameInfo.Shift          = 1;
-    }
-
-    // interlaced encoding is not always possible
-    if (pv->param.videoParam->mfx.CodecId             == MFX_CODEC_AVC &&
-        pv->param.videoParam->mfx.FrameInfo.PicStruct != MFX_PICSTRUCT_PROGRESSIVE)
-    {
-        if (pv->param.videoParam->mfx.CodecProfile == MFX_PROFILE_AVC_CONSTRAINED_BASELINE ||
-            pv->param.videoParam->mfx.CodecProfile == MFX_PROFILE_AVC_BASELINE             ||
-            pv->param.videoParam->mfx.CodecProfile == MFX_PROFILE_AVC_PROGRESSIVE_HIGH)
-        {
-            hb_error("encqsvInit: profile %s doesn't support interlaced encoding",
-                     hb_qsv_profile_name(MFX_CODEC_AVC,
-                                         pv->param.videoParam->mfx.CodecProfile));
-            return -1;
-        }
-        if ((pv->param.videoParam->mfx.CodecLevel >= MFX_LEVEL_AVC_1b &&
-             pv->param.videoParam->mfx.CodecLevel <= MFX_LEVEL_AVC_2) ||
-            (pv->param.videoParam->mfx.CodecLevel >= MFX_LEVEL_AVC_42))
-        {
-            hb_error("encqsvInit: level %s doesn't support interlaced encoding",
-                     hb_qsv_level_name(MFX_CODEC_AVC,
-                                       pv->param.videoParam->mfx.CodecLevel));
-            return -1;
-        }
-    }
-
-    int hw_generation = hb_qsv_hardware_generation(hb_qsv_get_platform(hb_qsv_get_adapter_index()));
-    // sanitize ICQ
-    // workaround for MediaSDK platforms below TGL to disable ICQ if incorrectly detected
-    if (!(pv->qsv_info->capabilities & HB_QSV_CAP_RATECONTROL_ICQ) ||
-        ((pv->param.videoParam->mfx.LowPower == MFX_CODINGOPTION_ON) && (hw_generation < QSV_G8)))
-    {
-        // ICQ not supported
-        pv->param.rc.icq = 0;
-    }
-    else
-    {
-        pv->param.rc.icq = pv->param.rc.icq && job->vquality > HB_INVALID_VIDEO_QUALITY;
-    }
-
-    // sanitize lookahead
-    if (!(pv->qsv_info->capabilities & HB_QSV_CAP_RATECONTROL_LA))
-    {
-        // lookahead not supported
-        pv->param.rc.lookahead = 0;
-    }
-    else if ((pv->param.rc.lookahead)                                       &&
-             (pv->qsv_info->capabilities & HB_QSV_CAP_RATECONTROL_LAi) == 0 &&
-             (pv->param.videoParam->mfx.FrameInfo.PicStruct != MFX_PICSTRUCT_PROGRESSIVE))
-    {
-        // lookahead enabled but we can't use it
-        hb_log("encqsvInit: LookAhead not used (LookAhead is progressive-only)");
-        pv->param.rc.lookahead = 0;
-    }
-    else
-    {
-        pv->param.rc.lookahead = pv->param.rc.lookahead && (pv->param.rc.icq || job->vquality <= HB_INVALID_VIDEO_QUALITY);
-    }
-
-    if (pv->job->qsv.ctx != NULL)
-    {
-        job->qsv.ctx->la_is_enabled = pv->param.rc.lookahead ? 1 : 0;
-    }
-
-    // libmfx BRC parameters are 16 bits thus maybe overflow, then BRCParamMultiplier is needed
-    // Comparison vbitrate in Kbps (kilobit) with vbv_max_bitrate, vbv_buffer_size, vbv_buffer_init in KB (kilobyte)
-    brc_param_multiplier = (FFMAX(FFMAX3(job->vbitrate, pv->param.rc.vbv_max_bitrate, pv->param.rc.vbv_buffer_size),
-                            pv->param.rc.vbv_buffer_init) + 0x10000) / 0x10000;
-    // set VBV here (this will be overridden for CQP and ignored for LA)
-    // only set BufferSizeInKB, InitialDelayInKB and MaxKbps if we have
-    // them - otherwise Media SDK will pick values for us automatically
-    if (pv->param.rc.vbv_buffer_size > 0)
-    {
-        if (pv->param.rc.vbv_buffer_init > 1.0)
-        {
-            pv->param.videoParam->mfx.InitialDelayInKB = (pv->param.rc.vbv_buffer_init / 8) / brc_param_multiplier;
-        }
-        else if (pv->param.rc.vbv_buffer_init > 0.0)
-        {
-            pv->param.videoParam->mfx.InitialDelayInKB = (pv->param.rc.vbv_buffer_size *
-                                                          pv->param.rc.vbv_buffer_init / 8) / brc_param_multiplier;
-        }
-        pv->param.videoParam->mfx.BufferSizeInKB       = (pv->param.rc.vbv_buffer_size / 8) / brc_param_multiplier;
-        pv->param.videoParam->mfx.BRCParamMultiplier   = brc_param_multiplier;
-    }
-    if (pv->param.rc.vbv_max_bitrate > 0)
-    {
-        pv->param.videoParam->mfx.MaxKbps              = pv->param.rc.vbv_max_bitrate / brc_param_multiplier;
-        pv->param.videoParam->mfx.BRCParamMultiplier   = brc_param_multiplier;
-    }
-
-    // set rate control parameters
-    if (job->vquality > HB_INVALID_VIDEO_QUALITY)
-    {
-        unsigned int upper_limit = 51;
-
-        if (pv->param.rc.icq)
-        {
-            // introduced in API 1.8
-            if (pv->param.rc.lookahead)
-            {
-                pv->param.videoParam->mfx.RateControlMethod = MFX_RATECONTROL_LA_ICQ;
-            }
-            else
-            {
-                pv->param.videoParam->mfx.RateControlMethod = MFX_RATECONTROL_ICQ;
-            }
-            pv->param.videoParam->mfx.ICQQuality = HB_QSV_CLIP3(1, upper_limit, job->vquality);
-        }
-        else
-        {
-            // introduced in API 1.1
-            // HEVC 10b has QP range as [-12;51]
-            // with shift +12 needed to be in QSV's U16 range
-            if (pv->param.videoParam->mfx.CodecProfile == MFX_PROFILE_HEVC_MAIN10)
-            {
-                upper_limit = 63;
-            }
-            if (pv->param.videoParam->mfx.CodecId == MFX_CODEC_AV1)
-            {
-                upper_limit = 255;
-            }
-
-            pv->param.videoParam->mfx.RateControlMethod = MFX_RATECONTROL_CQP;
-            pv->param.videoParam->mfx.QPI = HB_QSV_CLIP3(0, upper_limit, job->vquality + pv->param.rc.cqp_offsets[0]);
-            pv->param.videoParam->mfx.QPP = HB_QSV_CLIP3(0, upper_limit, job->vquality + pv->param.rc.cqp_offsets[1]);
-            pv->param.videoParam->mfx.QPB = HB_QSV_CLIP3(0, upper_limit, job->vquality + pv->param.rc.cqp_offsets[2]);
-
-            // CQP + ExtBRC can cause bad output
-            pv->param.codingOption2.ExtBRC = MFX_CODINGOPTION_OFF;
-        }
-    }
-    else if (job->vbitrate > 0)
-    {
-        if (pv->param.rc.lookahead)
-        {
-            // introduced in API 1.7
-            pv->param.videoParam->mfx.RateControlMethod  = MFX_RATECONTROL_LA;
-            pv->param.videoParam->mfx.TargetKbps         = job->vbitrate / brc_param_multiplier;
-            pv->param.videoParam->mfx.BRCParamMultiplier = brc_param_multiplier;
-            // ignored, but some drivers will change AsyncDepth because of it
-            pv->param.codingOption2.ExtBRC = MFX_CODINGOPTION_OFF;
-        }
-        else
-        {
-            // introduced in API 1.0
-            if (job->vbitrate == pv->param.rc.vbv_max_bitrate)
-            {
-                pv->param.videoParam->mfx.RateControlMethod = MFX_RATECONTROL_CBR;
-            }
-            else
-            {
-                pv->param.videoParam->mfx.RateControlMethod = MFX_RATECONTROL_VBR;
-            }
-            pv->param.videoParam->mfx.TargetKbps            = job->vbitrate / brc_param_multiplier;
-            pv->param.videoParam->mfx.BRCParamMultiplier    = brc_param_multiplier;
-        }
-    }
-    else
-    {
-        hb_error("encqsvInit: invalid rate control (%f, %d)",
-                 job->vquality, job->vbitrate);
-        return -1;
-    }
-
-    // if VBV is enabled but ignored, log it
-    if (pv->param.rc.vbv_max_bitrate > 0 || pv->param.rc.vbv_buffer_size > 0)
-    {
-        switch (pv->param.videoParam->mfx.RateControlMethod)
-        {
-            case MFX_RATECONTROL_LA:
-            case MFX_RATECONTROL_LA_ICQ:
-                hb_log("encqsvInit: LookAhead enabled, ignoring VBV");
-                break;
-            case MFX_RATECONTROL_ICQ:
-                hb_log("encqsvInit: ICQ rate control, ignoring VBV");
-                break;
-            default:
-                break;
-        }
-    }
-
-    // set the GOP structure
-    if (pv->param.gop.gop_ref_dist < 0)
-    {
-        if ((hw_generation >= QSV_G8) &&
-            (pv->param.videoParam->mfx.CodecId == MFX_CODEC_HEVC ||
-            pv->param.videoParam->mfx.CodecId == MFX_CODEC_AV1))
-        {
-            pv->param.gop.gop_ref_dist = 8;
-        }
-        else
-        {
-            pv->param.gop.gop_ref_dist = 4;
-        }
-    }
-    pv->param.videoParam->mfx.GopRefDist = pv->param.gop.gop_ref_dist;
-
-    // set the keyframe interval
-    if (pv->param.gop.gop_pic_size < 0)
-    {
-        double rate = (double)job->orig_vrate.num / job->orig_vrate.den + 0.5;
-        // set the keyframe interval based on the framerate
-        pv->param.gop.gop_pic_size = (int)(FFMIN(rate * 2, 120));
-    }
-    pv->param.videoParam->mfx.GopPicSize = pv->param.gop.gop_pic_size;
-
-    // set the Hyper Encode structure
-    if (pv->param.hyperEncodeParam.Mode != MFX_HYPERMODE_OFF)
-    {
-        if (pv->param.videoParam->mfx.CodecId == MFX_CODEC_HEVC)
-        {
-            pv->param.videoParam->mfx.IdrInterval = 1;
-        }
-        else if (pv->param.videoParam->mfx.CodecId == MFX_CODEC_AVC)
-        {
-            pv->param.videoParam->mfx.IdrInterval = 0;
-        }
-        // sanitize some of the encoding parameters
-        pv->param.videoParam->mfx.GopPicSize = (int)(FFMIN(pv->param.gop.gop_pic_size, 60));
-        pv->param.videoParam->AsyncDepth = (int)(FFMAX(pv->param.videoParam->AsyncDepth, 30));
-    }
-    // sanitize some settings that affect memory consumption
-    if (!pv->is_sys_mem)
-    {
-        // limit these to avoid running out of resources (causes hang)
-        pv->param.videoParam->mfx.GopRefDist   = FFMIN(pv->param.videoParam->mfx.GopRefDist,
-                                                       pv->param.rc.lookahead ? 8 : 16);
-        pv->param.codingOption2.LookAheadDepth = FFMIN(pv->param.codingOption2.LookAheadDepth,
-                                                       pv->param.rc.lookahead ? (48 - pv->param.videoParam->mfx.GopRefDist -
-                                                                                 3 * !pv->param.videoParam->mfx.GopRefDist) : 0);
-    }
-    else
-    {
-        // encode-only is a bit less sensitive to memory issues
-        pv->param.videoParam->mfx.GopRefDist   = FFMIN(pv->param.videoParam->mfx.GopRefDist, 16);
-        pv->param.codingOption2.LookAheadDepth = FFMIN(pv->param.codingOption2.LookAheadDepth,
-                                                       pv->param.rc.lookahead ? 100 : 0);
-    }
-    if (pv->param.rc.lookahead)
-    {
-        // LookAheadDepth 10 will cause a hang with some driver versions
-        pv->param.codingOption2.LookAheadDepth = FFMAX(pv->param.codingOption2.LookAheadDepth, 11);
-    }
-    /*
-     * We may need to adjust GopRefDist, GopPicSize and
-     * NumRefFrame to enable or disable B-pyramid, so do it last.
-     */
-    qsv_handle_breftype(pv);
-
-    /*
-     * init a dummy encode-only session to get the SPS/PPS
-     * and the final output settings sanitized by Media SDK
-     * this is fine since the actual encode will use the same
-     * values for all parameters relevant to the output bitstream
-     */
-    int err;
-    mfxStatus sts;
-    mfxVersion version;
-    mfxVideoParam videoParam;
-    mfxExtBuffer *extParamArray[HB_QSV_ENC_NUM_EXT_PARAM_MAX];
-    mfxSession session = (mfxSession)0;
-    mfxExtCodingOption  option1_buf, *option1 = &option1_buf;
-    mfxExtCodingOption2 option2_buf, *option2 = &option2_buf;
-    mfxExtAV1ScreenContentTools screencont_coding_buf, *screencont_coding = &screencont_coding_buf;
-    mfxExtCodingOptionSPSPPS sps_pps_buf, *sps_pps = &sps_pps_buf;
-    mfxExtAV1BitstreamParam av1_bitstream_buf, *av1_bitstream = &av1_bitstream_buf;
-    mfxExtChromaLocInfo chroma_loc_info_buf, *chroma_loc_info = &chroma_loc_info_buf;
-    mfxExtMasteringDisplayColourVolume mastering_display_color_volume_buf, *mastering_display_color_volume = &mastering_display_color_volume_buf;
-    mfxExtContentLightLevelInfo content_light_level_info_buf, *content_light_level_info = &content_light_level_info_buf;
-    mfxExtHyperModeParam hyper_encode_buf, *hyper_encode = &hyper_encode_buf;
-    version.Major = HB_QSV_MINVERSION_MAJOR;
-    version.Minor = HB_QSV_MINVERSION_MINOR;
-    uint32_t render_node = hb_qsv_get_adapter_render_node(hb_qsv_get_adapter_index());
-    sts = hb_qsv_create_mfx_session(pv->qsv_info->implementation, render_node, &version, &session);
-    if (sts != MFX_ERR_NONE)
-    {
-        hb_error("encqsvInit: MFXInit failed (%d) with implementation %d", sts, pv->qsv_info->implementation);
-        return -1;
-    }
-
-    if (pv->qsv_info->implementation & MFX_IMPL_HARDWARE_ANY)
-    {
-        // On linux, the handle to the VA display must be set.
-        // This code is essentially a NOP other platforms.
-        job->qsv.ctx->display = hb_qsv_display_init(render_node);
-        if (job->qsv.ctx->display != NULL)
-        {
-            MFXVideoCORE_SetHandle(session, job->qsv.ctx->display->mfxType,
-                                   (mfxHDL)job->qsv.ctx->display->handle);
-        }
-    }
-
-    /* Query the API version for hb_qsv_load_plugins */
-    sts = MFXQueryVersion(session, &version);
-    if (sts != MFX_ERR_NONE)
-    {
-        hb_error("encqsvInit: MFXQueryVersion failed (%d)", sts);
-        MFXClose(session);
-        return -1;
-    }
-
-    /* MFXVideoENCODE_Init with desired encoding parameters */
-    sts = MFXVideoENCODE_Init(session, pv->param.videoParam);
-    if (sts < MFX_ERR_NONE) // ignore warnings
-    {
-        hb_error("encqsvInit: MFXVideoENCODE_Init failed (%d)", sts);
-        err = log_encoder_params(pv, pv->param.videoParam);
-        if (err < 0)
-        {
-            hb_error("encqsvInit: log_encoder_params failed (%d)", err);
-        }
-        MFXClose(session);
-        return -1;
-    }
-    /* Prepare the structures for query */
-    memset(&videoParam, 0, sizeof(mfxVideoParam));
-    videoParam.ExtParam = extParamArray;
-    videoParam.NumExtParam = 0;
-
-    uint8_t sps[HB_CONFIG_MAX_SIZE];
-    uint8_t pps[HB_CONFIG_MAX_SIZE];
-
-    // introduced in API 1.3
-    memset(sps_pps, 0, sizeof(mfxExtCodingOptionSPSPPS));
-    sps_pps->Header.BufferId = MFX_EXTBUFF_CODING_OPTION_SPSPPS;
-    sps_pps->Header.BufferSz = sizeof(mfxExtCodingOptionSPSPPS);
-    sps_pps->SPSId           = 0;
-    sps_pps->SPSBuffer       = sps;
-    sps_pps->SPSBufSize      = sizeof(sps);
-    sps_pps->PPSId           = 0;
-    sps_pps->PPSBuffer       = pps;
-    sps_pps->PPSBufSize      = sizeof(pps);
-    if (pv->param.videoParam->mfx.CodecId == MFX_CODEC_AVC)
-    {
-        videoParam.ExtParam[videoParam.NumExtParam++] = (mfxExtBuffer*)sps_pps;
-    }
-    // introduced in API 1.0
-    memset(option1, 0, sizeof(mfxExtCodingOption));
-    option1->Header.BufferId = MFX_EXTBUFF_CODING_OPTION;
-    option1->Header.BufferSz = sizeof(mfxExtCodingOption);
-    if (pv->qsv_info->capabilities & HB_QSV_CAP_OPTION1)
-    {
-        videoParam.ExtParam[videoParam.NumExtParam++] = (mfxExtBuffer*)option1;
-    }
-    // introduced in API 1.6
-    memset(option2, 0, sizeof(mfxExtCodingOption2));
-    option2->Header.BufferId = MFX_EXTBUFF_CODING_OPTION2;
-    option2->Header.BufferSz = sizeof(mfxExtCodingOption2);
-    if (pv->qsv_info->capabilities & HB_QSV_CAP_OPTION2)
-    {
-        videoParam.ExtParam[videoParam.NumExtParam++] = (mfxExtBuffer*)option2;
-    }
-    // introduced in API 2.5
-    memset(av1_bitstream, 0, sizeof(mfxExtAV1BitstreamParam));
-    av1_bitstream->Header.BufferId = MFX_EXTBUFF_AV1_BITSTREAM_PARAM;
-    av1_bitstream->Header.BufferSz = sizeof(mfxExtAV1BitstreamParam);
-    if (pv->qsv_info->capabilities & HB_QSV_CAP_AV1_BITSTREAM)
-    {
-        videoParam.ExtParam[videoParam.NumExtParam++] = (mfxExtBuffer*)av1_bitstream;
-    }
-    memset(chroma_loc_info, 0, sizeof(mfxExtChromaLocInfo));
-    chroma_loc_info->Header.BufferId = MFX_EXTBUFF_CHROMA_LOC_INFO;
-    chroma_loc_info->Header.BufferSz = sizeof(mfxExtChromaLocInfo);
-    if (pv->qsv_info->capabilities & HB_QSV_CAP_VUI_CHROMALOCINFO)
-    {
-        videoParam.ExtParam[videoParam.NumExtParam++] = (mfxExtBuffer*)chroma_loc_info;
-    }
-    memset(mastering_display_color_volume, 0, sizeof(mfxExtMasteringDisplayColourVolume));
-    mastering_display_color_volume->Header.BufferId = MFX_EXTBUFF_MASTERING_DISPLAY_COLOUR_VOLUME;
-    mastering_display_color_volume->Header.BufferSz = sizeof(mfxExtMasteringDisplayColourVolume);
-    if (pv->qsv_info->capabilities & HB_QSV_CAP_VUI_MASTERINGINFO)
-    {
-        videoParam.ExtParam[videoParam.NumExtParam++] = (mfxExtBuffer*)mastering_display_color_volume;
-    }
-    memset(content_light_level_info, 0, sizeof(mfxExtContentLightLevelInfo));
-    content_light_level_info->Header.BufferId = MFX_EXTBUFF_CONTENT_LIGHT_LEVEL_INFO;
-    content_light_level_info->Header.BufferSz = sizeof(mfxExtContentLightLevelInfo);
-    if (pv->qsv_info->capabilities & HB_QSV_CAP_VUI_CLLINFO)
-    {
-        videoParam.ExtParam[videoParam.NumExtParam++] = (mfxExtBuffer*)content_light_level_info;
-    }
-    memset(hyper_encode, 0, sizeof(mfxExtHyperModeParam));
-    hyper_encode->Header.BufferId = MFX_EXTBUFF_HYPER_MODE_PARAM;
-    hyper_encode->Header.BufferSz = sizeof(mfxExtHyperModeParam);
-    if (pv->qsv_info->capabilities & HB_QSV_CAP_HYPERENCODE)
-    {
-        videoParam.ExtParam[videoParam.NumExtParam++] = (mfxExtBuffer*)hyper_encode;
-    }
-    memset(screencont_coding, 0, sizeof(mfxExtAV1ScreenContentTools));
-    screencont_coding->Header.BufferId = MFX_EXTBUFF_AV1_SCREEN_CONTENT_TOOLS;
-    screencont_coding->Header.BufferSz = sizeof(mfxExtAV1ScreenContentTools);
-    if (pv->qsv_info->capabilities & HB_QSV_CAP_AV1_SCREENCONTENT)
-    {
-        videoParam.ExtParam[videoParam.NumExtParam++] = (mfxExtBuffer*)screencont_coding;
-    }
-    /* Query actual encoding parameters after MFXVideoENCODE_Init, some of them could be overridden */
-    sts = MFXVideoENCODE_GetVideoParam(session, &videoParam);
-    if (sts != MFX_ERR_NONE)
-    {
-        hb_error("encqsvInit: MFXVideoENCODE_GetVideoParam failed (%d)", sts);
-        MFXClose(session);
-        return -1;
-    }
-
-    /* We have the final encoding parameters, now get the headers for muxing */
-    if (videoParam.mfx.CodecId == MFX_CODEC_AVC)
-    {
-        // remove 4-byte Annex B NAL unit prefix (0x00 0x00 0x00 0x01)
-        hb_set_h264_extradata(w->extradata,
-                              sps + 4, sps_pps->SPSBufSize - 4,
-                              pps + 4, sps_pps->PPSBufSize - 4);
-    }
-    else if (videoParam.mfx.CodecId == MFX_CODEC_HEVC)
-    {
-        if (qsv_hevc_make_header(w, session, &videoParam) < 0)
-        {
-            hb_error("encqsvInit: qsv_hevc_make_header failed");
-            MFXVideoENCODE_Close(session);
-            MFXClose(session);
-            return -1;
-        }
-    }
-
-    /* We don't need this encode session once we have the header */
-    MFXVideoENCODE_Close(session);
-
-    // when using system memory, we re-use this same session
-    if (pv->is_sys_mem)
-    {
-        pv->mfx_session = session;
-    }
-    else
-    {
-        MFXClose(session);
-    }
-
-    /* B-frame related setup */
-    if (videoParam.mfx.GopRefDist > 1)
-    {
-        /* the muxer needs to know to the init_delay */
-        switch (videoParam.mfx.CodecId)
-        {
-            case MFX_CODEC_AVC:
-            case MFX_CODEC_HEVC:
-                pv->init_delay = w->init_delay;
-                break;
-            default:
-                break;
-        }
-
-        /* let the muxer know that it should expect B-frames */
-        job->areBframes = 1;
-
-        /* holds the PTS sequence in display order, used to generate DTS */
-        pv->list_dts = hb_list_init();
-    }
-
-    err = log_encoder_params(pv, &videoParam);
-    if (err < 0)
-    {
-        hb_error("encqsvInit: log_encoder_params failed (%d)", err);
-        return -1;
-    }
-    pv->param.videoParam->mfx = videoParam.mfx;
-    // AsyncDepth has now been set and/or modified by Media SDK
-    // fall back to default if zero
-    pv->max_async_depth = videoParam.AsyncDepth ? videoParam.AsyncDepth : hb_qsv_param_default_async_depth();
-    pv->async_depth     = 0;
-
-    return 0;
-}
-
-void encqsvClose(hb_work_object_t *w)
-{
-    hb_work_private_t *pv = w->private_data;
-    int i;
-
-    if (pv != NULL && pv->job != NULL && pv->job->qsv.ctx != NULL &&
-        pv->job->qsv.ctx->is_context_active)
-    {
-
-        hb_qsv_context *qsv_ctx       = pv->job->qsv.ctx;
-        hb_qsv_space   *qsv_enc_space = pv->job->qsv.ctx->enc_space;
-
-        if (qsv_ctx != NULL)
-        {
-            hb_qsv_uninit_enc(pv->job);
-            if (qsv_enc_space != NULL)
-            {
-                if (qsv_enc_space->is_init_done)
-                {
-                    for (i = hb_qsv_list_count(qsv_enc_space->tasks); i >= 1; i--)
-                    {
-                        hb_qsv_task *task = hb_qsv_list_item(qsv_enc_space->tasks,
-                                                             i - 1);
-                        if (task != NULL)
-                        {
-                            if (task->bs != NULL)
-                            {
-                                av_freep(&task->bs->Data);
-                            }
-                            hb_qsv_list_rem(qsv_enc_space->tasks, task);
-                            av_freep(&task->bs);
-                            av_freep(&task);
-                        }
-                    }
-                    hb_qsv_list_close(&qsv_enc_space->tasks);
-
-                    for (i = 0; i < qsv_enc_space->surface_num; i++)
-                    {
-                        if (pv->is_sys_mem)
-                        {
-                            av_freep(&qsv_enc_space->p_surfaces[i]->Data.Y);
-                        }
-                        av_freep(&qsv_enc_space->p_surfaces[i]);
-                    }
-                    qsv_enc_space->surface_num = 0;
-
-                    for (i = 0; i < qsv_enc_space->sync_num; i++)
-                    {
-                        av_freep(&qsv_enc_space->p_syncp[i]->p_sync);
-                        av_freep(&qsv_enc_space->p_syncp[i]);
-                    }
-                    qsv_enc_space->sync_num = 0;
-                }
-                qsv_enc_space->is_init_done = 0;
-            }
-        }
-    }
-
-    if (pv != NULL)
-    {
-        hb_chapter_queue_close(&pv->chapter_queue);
-        if (pv->delayed_processing != NULL)
-        {
-            /* the list is already empty */
-            hb_list_close(&pv->delayed_processing);
-        }
-        if (pv->list_dts != NULL)
-        {
-            int64_t *item;
-            while ((item = hb_list_item(pv->list_dts, 0)) != NULL)
-            {
-                hb_list_rem(pv->list_dts, item);
-                free(item);
-            }
-            hb_list_close(&pv->list_dts);
-        }
-        hb_buffer_list_close(&pv->encoded_frames);
-    }
-
-    free(pv);
-    w->private_data = NULL;
-}
-
-static void compute_init_delay(hb_work_private_t *pv, mfxBitstream *bs)
-{
-    if (pv->init_delay == NULL)
-    {
-        return; // not needed or already set
-    }
-
-    /*
-     * In the MP4 container, DT(0) = STTS(0) = 0.
-     *
-     * Which gives us:
-     * CT(0) = CTTS(0) + STTS(0) = CTTS(0) = PTS(0) - DTS(0)
-     * When DTS(0) < PTS(0), we then have:
-     * CT(0) > 0 for video, but not audio (breaks A/V sync).
-     *
-     * This is typically solved by writing an edit list shifting
-     * video samples by the initial delay, PTS(0) - DTS(0).
-     *
-     * See:
-     * ISO/IEC 14496-12:2008(E), ISO base media file format
-     *  - 8.6.1.2 Decoding Time to Sample Box
-     */
-    if (pv->qsv_info->capabilities & HB_QSV_CAP_MSDK_API_1_6)
-    {
-        /* compute init_delay (in ticks) based on the DTS provided by MSDK. */
-        int64_t init_delay = bs->TimeStamp - bs->DecodeTimeStamp;
-
-        /*
-         * we also need to know the delay in frames to generate DTS.
-         *
-         * compute it based on the init_delay and average frame duration,
-         * and account for potential rounding errors due to the timebase.
-         */
-        double avg_frame_dur = ((double)pv->job->vrate.den /
-                                (double)pv->job->vrate.num * 90000.);
-
-        pv->bfrm_delay = (init_delay + (avg_frame_dur / 2)) / avg_frame_dur;
-
-        if (pv->bfrm_delay < 1 || pv->bfrm_delay > BFRM_DELAY_MAX)
-        {
-            hb_log("compute_init_delay: "
-                   "invalid delay %d (PTS: %llu, DTS: %lld)",
-                   pv->bfrm_delay, bs->TimeStamp, bs->DecodeTimeStamp);
-
-            /* we have B-frames, the frame delay should be at least 1 */
-            if (pv->bfrm_delay < 1)
-            {
-                mfxStatus sts;
-                mfxVideoParam videoParam;
-                mfxSession session = pv->job->qsv.ctx->mfx_session;
-
-                memset(&videoParam, 0, sizeof(mfxVideoParam));
-
-                sts = MFXVideoENCODE_GetVideoParam(session, &videoParam);
-                if (sts != MFX_ERR_NONE)
-                {
-                    hb_log("compute_init_delay: "
-                           "MFXVideoENCODE_GetVideoParam failed (%d)", sts);
-                    pv->bfrm_delay = 1;
-                }
-                else
-                {
-                    /* usually too large, but should cover all cases */
-                    pv->bfrm_delay = FFMIN(pv->frames_in             - 1,
-                                           videoParam.mfx.GopRefDist - 1);
-                }
-            }
-
-            pv->bfrm_delay = FFMIN(BFRM_DELAY_MAX, pv->bfrm_delay);
-        }
-
-        pv->init_delay[0] = pv->init_pts[pv->bfrm_delay] - pv->init_pts[0];
-    }
-    else
-    {
-        /*
-         * we can't get the DTS from MSDK, so we need to generate our own.
-         *
-         * B-pyramid not possible here, so the delay in frames is always 1.
-         */
-        pv->bfrm_delay    = 1;
-        pv->init_delay[0] = pv->init_pts[1] - pv->init_pts[0];
-    }
-
-    /* This can come in handy */
-    hb_deep_log(2, "compute_init_delay: %d (%d frames)", pv->init_delay[0], pv->bfrm_delay);
-
-    /* The delay only needs to be set once. */
-    pv->init_delay = NULL;
-}
-
-static void qsv_bitstream_slurp(hb_work_private_t *pv, mfxBitstream *bs)
-{
-    hb_buffer_t *buf;
-
-    if (pv->param.videoParam->mfx.CodecId == MFX_CODEC_AVC)
-    {
-        /*
-         * We provided the muxer with the parameter sets in an MP4-compatible
-         * format (ISO/IEC 14496-15). We need to convert the bitstream to the
-         * same format to match the extradata.
-         */
-        if ((buf = hb_nal_bitstream_annexb_to_mp4(bs->Data + bs->DataOffset,
-                                                  bs->DataLength)) == NULL)
-        {
-            hb_error("encqsv: hb_nal_bitstream_annexb_to_mp4 failed");
-            goto fail;
-        }
-    }
-    else
-    {
-        /* Both extradata and bitstream are in Annex B format. */
-        if ((buf = hb_buffer_init(bs->DataLength)) == NULL)
-        {
-            hb_error("encqsv: hb_buffer_init failed");
-            goto fail;
-        }
-        memcpy(buf->data, bs->Data + bs->DataOffset, bs->DataLength);
-    }
-    bs->DataLength = bs->DataOffset = 0;
-    bs->MaxLength  = pv->job->qsv.ctx->enc_space->p_buf_max_size;
-
-    buf->s.frametype = hb_qsv_frametype_xlat(bs->FrameType, &buf->s.flags);
-    if (pv->param.videoParam->mfx.CodecId == MFX_CODEC_HEVC)
-    {
-        size_t   len = buf->size;
-        uint8_t *pos = buf->data;
-        uint8_t *end = pos + len;
-        while ((pos = hb_annexb_find_next_nalu(pos, &len)) != NULL)
-        {
-            if (HB_HEVC_NALU_KEYFRAME((pos[0] >> 1) & 0x3f))
-            {
-                buf->s.flags |= HB_FLAG_FRAMETYPE_KEY;
-                break;
-            }
-            len = end - pos;
-            continue;
-        }
-    }
-    buf->s.start     = buf->s.renderOffset = bs->TimeStamp;
-    buf->s.stop      = buf->s.start + get_frame_duration(pv, buf);
-    buf->s.duration  = buf->s.stop  - buf->s.start;
-
-    /* compute the init_delay before setting the DTS */
-    compute_init_delay(pv, bs);
-
-    /*
-     * Generate VFR-compatible output DTS based on input PTS.
-     *
-     * Depends on the B-frame delay:
-     *
-     * 0: ipts0,  ipts1, ipts2...
-     * 1: ipts0 - ipts1, ipts1 - ipts1, ipts1,  ipts2...
-     * 2: ipts0 - ipts2, ipts1 - ipts2, ipts2 - ipts2, ipts1...
-     * ...and so on.
-     */
-    if (pv->bfrm_delay)
-    {
-        if (pv->frames_out <= pv->bfrm_delay)
-        {
-            buf->s.renderOffset = (pv->init_pts[pv->frames_out] -
-                                   pv->init_pts[pv->bfrm_delay]);
-        }
-        else
-        {
-            buf->s.renderOffset = hb_qsv_pop_next_dts(pv->list_dts);
-        }
-    }
-
-    /* check if B-pyramid is used even though it's disabled */
-    if ((pv->param.gop.b_pyramid == 0)    &&
-        (bs->FrameType & MFX_FRAMETYPE_B) &&
-        (bs->FrameType & MFX_FRAMETYPE_REF))
-    {
-        hb_log("encqsv: BPyramid off not respected (delay: %d)", pv->bfrm_delay);
-
-        /* don't pollute the log unnecessarily */
-        pv->param.gop.b_pyramid = 1;
-    }
-
-    /* check for PTS < DTS */
-    if (buf->s.start < buf->s.renderOffset)
-    {
-        hb_log("encqsv: PTS %"PRId64" < DTS %"PRId64" for frame %d with type '%s'",
-               buf->s.start, buf->s.renderOffset, pv->frames_out + 1,
-               hb_qsv_frametype_name(bs->FrameType));
-    }
-
-    /*
-     * If we have a chapter marker pending and this frame's PTS
-     * is at or after the marker's PTS, use it as the chapter start.
-     */
-    if (buf->s.flags & HB_FLAG_FRAMETYPE_KEY)
-    {
-        hb_chapter_dequeue(pv->chapter_queue, buf);
-    }
-
-    hb_buffer_list_append(&pv->encoded_frames, buf);
-    pv->frames_out++;
-    return;
-
-fail:
-    *pv->job->done_error = HB_ERROR_UNKNOWN;
-    *pv->job->die        = 1;
-}
-
-static int qsv_enc_work(hb_work_private_t *pv,
-                        hb_qsv_list *qsv_atom,
-                        mfxFrameSurface1 *surface,
-                        HBQSVFramesContext *frames_ctx)
-{
-    int err;
-    mfxStatus sts;
-    hb_qsv_context *qsv_ctx       = pv->job->qsv.ctx;
-    hb_qsv_space   *qsv_enc_space = pv->job->qsv.ctx->enc_space;
-
-    do
-    {
-        int sync_idx = hb_qsv_get_free_sync(qsv_enc_space, qsv_ctx);
-        if (sync_idx == -1)
-        {
-            hb_error("encqsv: hb_qsv_get_free_sync failed");
-            return -1;
-        }
-        hb_qsv_task *task = hb_qsv_list_item(qsv_enc_space->tasks,
-                                             pv->async_depth);
-
-        do
-        {
-            sts = MFXVideoENCODE_EncodeFrameAsync(qsv_ctx->mfx_session,
-                                                  NULL, surface, task->bs,
-                                                  qsv_enc_space->p_syncp[sync_idx]->p_sync);
-
-            if (sts == MFX_ERR_MORE_DATA)
-            {
-                if(!pv->is_sys_mem && surface)
-                {
-                    hb_qsv_release_surface_from_pool_by_surface_pointer(frames_ctx, surface);
-                }
-
-                if (qsv_atom != NULL)
-                {
-                    hb_list_add(pv->delayed_processing, qsv_atom);
-                }
-                ff_qsv_atomic_dec(&qsv_enc_space->p_syncp[sync_idx]->in_use);
-                break;
-            }
-            else if (sts < MFX_ERR_NONE)
-            {
-                hb_error("encqsv: MFXVideoENCODE_EncodeFrameAsync failed (%d)", sts);
-                return -1;
-            }
-            else if (sts == MFX_WRN_DEVICE_BUSY)
-            {
-                hb_qsv_sleep(10); // device is busy, wait then repeat the call
-                continue;
-            }
-            else
-            {
-                hb_qsv_stage *new_stage        = hb_qsv_stage_init();
-                new_stage->type                = HB_QSV_ENCODE;
-                new_stage->in.p_surface        = surface;
-                new_stage->in.p_frames_ctx     = frames_ctx;
-                new_stage->out.sync            = qsv_enc_space->p_syncp[sync_idx];
-                new_stage->out.p_bs            = task->bs;
-                task->stage                    = new_stage;
-                pv->async_depth++;
-
-                if(!pv->is_sys_mem && surface)
-                {
-                    hb_qsv_release_surface_from_pool_by_surface_pointer(frames_ctx, surface);
-                }
-
-                if (qsv_atom != NULL)
-                {
-                    hb_qsv_add_stagee(&qsv_atom, new_stage, HAVE_THREADS);
-                }
-                else
-                {
-                    /* encode-only or flushing */
-                    hb_qsv_list *new_qsv_atom = hb_qsv_list_init(HAVE_THREADS);
-                    hb_qsv_add_stagee(&new_qsv_atom,  new_stage, HAVE_THREADS);
-                    hb_qsv_list_add  (qsv_ctx->pipes, new_qsv_atom);
-                }
-
-                int i = hb_list_count(pv->delayed_processing);
-                while (--i >= 0)
-                {
-                    hb_qsv_list *item = hb_list_item(pv->delayed_processing, i);
-
-                    if (item != NULL)
-                    {
-                        hb_list_rem(pv->delayed_processing,  item);
-                        hb_qsv_flush_stages(qsv_ctx->pipes, &item, 1);
-                    }
-                }
-                break;
-            }
-
-            ff_qsv_atomic_dec(&qsv_enc_space->p_syncp[sync_idx]->in_use);
-            break;
-        }
-        while (sts >= MFX_ERR_NONE);
-
-        do
-        {
-            if (pv->async_depth == 0) break;
-
-            /* we've done enough asynchronous operations or we're flushing */
-            if (pv->async_depth >= pv->max_async_depth || surface == NULL)
-            {
-                hb_qsv_task *task = hb_qsv_list_item(qsv_enc_space->tasks, 0);
-                pv->async_depth--;
-
-                /* perform a sync operation to get the output bitstream */
-                err = hb_qsv_wait_on_sync(qsv_ctx, task->stage);
-                if (err < 0)
-                {
-                    hb_error("encqsv: hb_qsv_wait_on_sync failed (%d)", err);
-                    return err;
-                }
-
-                if (task->bs->DataLength > 0)
-                {
-                    hb_qsv_list *pipe = hb_qsv_pipe_by_stage(qsv_ctx->pipes,
-                                                             task->stage);
-                    hb_qsv_flush_stages(qsv_ctx->pipes, &pipe, 1);
-
-                    /* get the encoded frame from the bitstream */
-                    qsv_bitstream_slurp(pv, task->bs);
-
-                    /* shift for fifo */
-                    if (pv->async_depth)
-                    {
-                        hb_qsv_list_rem(qsv_enc_space->tasks, task);
-                        hb_qsv_list_add(qsv_enc_space->tasks, task);
-                    }
-                    task->stage = NULL;
-                }
-            }
-        }
-        while (surface == NULL);
-    }
-    while (surface == NULL && sts != MFX_ERR_MORE_DATA);
-
-    return 0;
-}
-
-int encqsvWork(hb_work_object_t *w, hb_buffer_t **buf_in, hb_buffer_t **buf_out)
-{
-    int err;
-    hb_work_private_t *pv = w->private_data;
-    hb_buffer_t *in       = *buf_in;
-    hb_job_t *job         = pv->job;
-    while (qsv_enc_init(pv) >= 2)
-    {
-        hb_qsv_sleep(1); // encoding not initialized, wait and repeat the call
-    }
-
-    if (*job->die)
-    {
-        goto fail; // unrecoverable error, don't attempt to encode
-    }
-
-    /*
-     * EOF on input. Flush the decoder, then send the
-     * EOF downstream to let the muxer know we're done.
-     */
-    if (in->s.flags & HB_BUF_FLAG_EOF)
-    {
-        err = qsv_enc_work(pv, NULL, NULL, NULL);
-        if (err < 0)
-        {
-            hb_error("encqsvWork: EOF qsv_enc_work failed %d", err);
-            goto fail;
-        }
-        hb_buffer_list_append(&pv->encoded_frames, in);
-        *buf_out = hb_buffer_list_clear(&pv->encoded_frames);
-        *buf_in = NULL; // don't let 'work_loop' close this buffer
-        return HB_WORK_DONE;
-    }
-
-    mfxFrameSurface1   *surface     = NULL;
-    HBQSVFramesContext *frames_ctx  = NULL;
-    hb_qsv_list      *qsv_atom      = NULL;
-    hb_qsv_context   *qsv_ctx       = job->qsv.ctx;
-    hb_qsv_space     *qsv_enc_space = job->qsv.ctx->enc_space;
-
-    if (pv->is_sys_mem)
-    {
-        mfxFrameInfo *info = &pv->param.videoParam->mfx.FrameInfo;
-        int surface_index  = hb_qsv_get_free_surface(qsv_enc_space, qsv_ctx, info,
-                                                     QSV_PART_ANY);
-        if (surface_index == -1)
-        {
-            hb_error("encqsv: hb_qsv_get_free_surface failed");
-            goto fail;
-        }
-
-        surface = qsv_enc_space->p_surfaces[surface_index];
-        qsv_copy_buffer_to_surface(surface, in);
-    }
-    else
-    {
-        QSVMid *mid = NULL;
-        AVFrame *frame = (AVFrame *)in->storage;
-        if (frame && frame->data[3])
-        {
-            surface = ((mfxFrameSurface1*)frame->data[3]);
-            frames_ctx = in->qsv_details.qsv_frames_ctx;
-            hb_qsv_get_mid_by_surface_from_pool(frames_ctx, surface, &mid);
-            hb_qsv_replace_surface_mid(frames_ctx, mid, surface);
-        }
-        else
-        {
-            hb_error("encqsv: in->qsv_details no surface available");
-            goto fail;
-        }
-
-        // At this point, enc_qsv takes ownership of the QSV resources
-        // in the 'in' buffer.
-        in->qsv_details.qsv_atom = NULL;
-
-        /*
-         * QSV decoding fills the QSV context's dts_seq list, we need to
-         * pop this surface's DTS so dts_seq doesn't grow unnecessarily.
-         */
-        hb_qsv_dts_pop(qsv_ctx);
-    }
-
-    /*
-     * Debugging code to check that the upstream modules have generated
-     * a continuous, self-consistent frame stream.
-     */
-    if (pv->last_start > in->s.start)
-    {
-        hb_log("encqsv: input continuity error, "
-               "last start %"PRId64" start %"PRId64"",
-               pv->last_start, in->s.start);
-    }
-    pv->last_start = in->s.start;
-
-    /* for DTS generation */
-    if (pv->frames_in <= BFRM_DELAY_MAX)
-    {
-        pv->init_pts[pv->frames_in] = in->s.start;
-    }
-    if (pv->frames_in)
-    {
-        hb_qsv_add_new_dts(pv->list_dts, in->s.start);
-    }
-    pv->frames_in++;
-
-    /*
-     * Chapters have to start with a keyframe, so request one here.
-     *
-     * Using an mfxEncodeCtrl structure to force key frame generation is not
-     * possible when using a lookahead and frame reordering, so instead do
-     * the following before encoding the frame attached to the chapter:
-     *
-     * - flush the encoder to encode and retrieve any buffered frames
-     *
-     * - do a hard reset (MFXVideoENCODE_Close, then Init) of
-     *   the encoder to make sure the next frame is a keyframe
-     *
-     * The hard reset ensures encoding resumes with a clean state, avoiding
-     * miscellaneous hard-to-diagnose issues that may occur when resuming
-     * an encode after flushing the encoder or using MFXVideoENCODE_Reset.
-     */
-    if (in->s.new_chap > 0 && job->chapter_markers)
-    {
-        mfxStatus sts;
-
-        err = qsv_enc_work(pv, NULL, NULL, NULL);
-        if (err < 0)
-        {
-            hb_error("encqsvWork: new_chap qsv_enc_work failed %d", err);
-            goto fail;
-        }
-
-        sts = MFXVideoENCODE_Close(qsv_ctx->mfx_session);
-        if (sts != MFX_ERR_NONE)
-        {
-            hb_error("encqsv: MFXVideoENCODE_Close failed (%d)", sts);
-            goto fail;
-        }
-
-        sts = MFXVideoENCODE_Init(qsv_ctx->mfx_session, pv->param.videoParam);
-        if (sts < MFX_ERR_NONE)
-        {
-            hb_error("encqsv: MFXVideoENCODE_Init failed (%d)", sts);
-            goto fail;
-        }
-
-        hb_chapter_enqueue(pv->chapter_queue, in);
-    }
-
-    /*
-     * If interlaced encoding is requested during encoder initialization,
-     * but the input mfxFrameSurface1 is flagged as progressive here,
-     * the output bitstream will be progressive (according to MediaInfo).
-     *
-     * Assume the user knows what he's doing (say he is e.g. encoding a
-     * progressive-flagged source using interlaced compression - he may
-     * well have a good reason to do so; mis-flagged sources do exist).
-     */
-    surface->Info.PicStruct = pv->param.videoParam->mfx.FrameInfo.PicStruct;
-    surface->Data.TimeStamp = in->s.start;
-    save_frame_duration(pv, in);
-
-    /*
-     * Now that the input surface is setup, we can encode it.
-     */
-    err = qsv_enc_work(pv, qsv_atom, surface, frames_ctx);
-    if (err < 0)
-    {
-        hb_error("encqsvWork: qsv_enc_work failed %d", err);
-        goto fail;
-    }
-
-    if (in->storage)
-    {
-        // FIXME: This looks weird
-        AVFrame *frame = (AVFrame *)in->storage;
-        frame->data[3] = 0;
-    }
-
-    *buf_out = hb_buffer_list_clear(&pv->encoded_frames);
-    return HB_WORK_OK;
-
-fail:
-    if (*job->done_error == HB_ERROR_NONE)
-    {
-        *job->done_error  = HB_ERROR_UNKNOWN;
-    }
-    *job->die = 1;
-    *buf_out  = NULL;
-    return HB_WORK_ERROR;
-}
-
-#endif // HB_PROJECT_FEATURE_QSV
diff -Naupr a/libhb/encavcodec.c b/libhb/encavcodec.c
--- a/libhb/encavcodec.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/encavcodec.c	2025-03-31 11:55:35.240884449 +0200
@@ -1,6 +1,6 @@
 /* encavcodec.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    Copyright 2022 NVIDIA Corporation
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
@@ -19,6 +19,7 @@
 #include "handbrake/nvenc_common.h"
 #include "handbrake/vce_common.h"
 #include "handbrake/extradata.h"
+#include "handbrake/qsv_common.h"
 
 /*
  * The frame info struct remembers information about each frame across calls
@@ -46,6 +47,10 @@ struct hb_work_private_s
 
     int64_t              dts_delay;
 
+#if HB_PROJECT_FEATURE_QSV
+    qsv_data_t         qsv_data;
+#endif
+
     struct {
         int64_t          start;
         int64_t          duration;
@@ -79,6 +84,11 @@ hb_work_object_t hb_encavcodec =
     encavcodecClose
 };
 
+static const char * const empty_tune_names[] =
+{
+    "none", NULL
+};
+
 static const char * const vpx_preset_names[] =
 {
     "veryfast", "faster", "fast", "medium", "slow", "slower", "veryslow", NULL
@@ -86,7 +96,17 @@ static const char * const vpx_preset_nam
 
 static const char * const vp9_tune_names[] = 
 {
-    "screen", "film", NULL 
+    "none", "screen", "film", NULL
+};
+
+static const char * const h264_qsv_profile_name[] =
+{
+    "auto", "high", "main", "baseline", NULL
+};
+
+static const char * const h265_qsv_profile_name[] =
+{
+    "auto", "main", "main10", "mainsp",  NULL
 };
 
 static const char * const h26x_nvenc_preset_names[] =
@@ -157,6 +177,16 @@ static const enum AVPixelFormat standard
     AV_PIX_FMT_YUV420P10, AV_PIX_FMT_NONE
 };
 
+static const enum AVPixelFormat qsv_pix_formats[] =
+{
+    AV_PIX_FMT_NV12, AV_PIX_FMT_NONE
+};
+
+static const enum AVPixelFormat qsv_10bit_pix_formats[] =
+{
+    AV_PIX_FMT_P010LE, AV_PIX_FMT_NONE
+};
+
 static const enum AVPixelFormat h26x_mf_pix_fmts[] =
 {
     AV_PIX_FMT_NV12, AV_PIX_FMT_NONE
@@ -251,6 +281,10 @@ int encavcodecInit( hb_work_object_t * w
                     hb_log("encavcodecInit: H.264 (MediaFoundation)");
                     codec_name = "h264_mf";
                     break;
+                case HB_VCODEC_FFMPEG_QSV_H264:
+                    hb_log("encavcodecInit: H.264 (Intel Quick Sync Video)");
+                    codec_name = "h264_qsv";
+                    break;
             }
         }break;
         case AV_CODEC_ID_HEVC:
@@ -270,6 +304,11 @@ int encavcodecInit( hb_work_object_t * w
                     hb_log("encavcodecInit: H.265 (MediaFoundation)");
                     codec_name = "hevc_mf";
                     break;
+                case HB_VCODEC_FFMPEG_QSV_H265:
+                case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+                    hb_log("encavcodecInit: H.265 (Intel Quick Sync Video)");
+                    codec_name = "hevc_qsv";
+                    break;
             }
         }break;
         case AV_CODEC_ID_AV1:
@@ -284,6 +323,11 @@ int encavcodecInit( hb_work_object_t * w
                     hb_log("encavcodecInit: AV1 (AMD VCE)");
                     codec_name = "av1_amf";
                     break;
+                case HB_VCODEC_FFMPEG_QSV_AV1:
+                case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
+                    hb_log("encavcodecInit: AV1 (Intel Quick Sync Video)");
+                    codec_name = "av1_qsv";
+                    break;
                 case HB_VCODEC_FFMPEG_MF_AV1:
                     hb_log("encavcodecInit: AV1 (MediaFoundation)");
                     codec_name = "av1_mf";
@@ -410,6 +454,13 @@ int encavcodecInit( hb_work_object_t * w
         goto done;
     }
 
+#if HB_PROJECT_FEATURE_QSV
+    if (hb_qsv_is_ffmpeg_supported_codec(job->vcodec))
+    {
+        hb_qsv_apply_encoder_options(&pv->qsv_data, job, &av_opts);
+    }
+#endif
+
     // Now set the things in context that we don't want to allow
     // the user to override.
     if (job->vquality <= HB_INVALID_VIDEO_QUALITY)
@@ -426,6 +477,24 @@ int encavcodecInit( hb_work_object_t * w
             hb_log( "encavcodec: encoding at rc=vbr, Bitrate %d", job->vbitrate );
         }
 
+#if HB_PROJECT_FEATURE_QSV
+        if (hb_qsv_is_ffmpeg_supported_codec(job->vcodec))
+        {
+            if (pv->qsv_data.param.rc.lookahead)
+            {
+                // introduced in API 1.7
+                av_dict_set( &av_opts, "look_ahead", "1", 0 );
+            }
+
+            if (job->vbitrate == pv->qsv_data.param.rc.vbv_max_bitrate)
+            {
+                char maxrate[7];
+                snprintf(maxrate, 7, "%d", context->bit_rate);
+                av_dict_set( &av_opts, "maxrate", maxrate, 0 );
+            }
+        }
+#endif
+
         if ((job->vcodec == HB_VCODEC_FFMPEG_VCE_H264)
             || (job->vcodec == HB_VCODEC_FFMPEG_VCE_H265)
             || (job->vcodec == HB_VCODEC_FFMPEG_VCE_H265_10BIT)
@@ -527,6 +596,20 @@ int encavcodecInit( hb_work_object_t * w
             av_dict_set( &av_opts, "init_qpI", qualityI, 0 );
             hb_log( "encavcodec: encoding at rc=vbr, %.2f", job->vquality );
         }
+#if HB_PROJECT_FEATURE_QSV
+        else if (hb_qsv_is_ffmpeg_supported_codec(job->vcodec))
+        {
+            context->bit_rate = 0;
+            if (pv->qsv_data.param.rc.icq)
+            {
+                char global_quality[7];
+                int upper_limit = 51;
+                snprintf(global_quality, 7, "%d", HB_QSV_CLIP3(1, upper_limit, (int)job->vquality));
+                av_dict_set(&av_opts, "global_quality", global_quality, 0);
+                hb_log("encavcodec: encoding with brc ICQ %s", global_quality);
+            }
+        }
+#endif
         else if ( job->vcodec == HB_VCODEC_FFMPEG_VCE_H264 ||
                   job->vcodec == HB_VCODEC_FFMPEG_VCE_H265 ||
                   job->vcodec == HB_VCODEC_FFMPEG_VCE_H265_10BIT ||
@@ -603,6 +686,10 @@ int encavcodecInit( hb_work_object_t * w
             snprintf(quality, 7, "%d", (int)job->vquality);
             av_dict_set(&av_opts, "rate_control", "quality", 0);
             av_dict_set(&av_opts, "quality", quality, 0);
+            if (!av_dict_get(av_opts, "scenario", NULL, 0))
+            {
+                av_dict_set(&av_opts, "scenario", "archive", 0);
+            }
         }
         else
         {
@@ -621,11 +708,23 @@ int encavcodecInit( hb_work_object_t * w
     if (hb_hwaccel_is_full_hardware_pipeline_enabled(pv->job))
     {
         context->hw_device_ctx = av_buffer_ref(pv->job->hw_device_ctx);
-        hb_hwaccel_hwframes_ctx_init(context, job);
+#if HB_PROJECT_FEATURE_QSV
+        if (!hb_qsv_is_ffmpeg_supported_codec(job->vcodec))
+#endif
+        {
+            hb_hwaccel_hwframes_ctx_init(context, job);
+        }
         context->pix_fmt = job->hw_pix_fmt;
     }
     else
     {
+#if HB_PROJECT_FEATURE_QSV
+        if (hb_qsv_is_ffmpeg_supported_codec(job->vcodec) && !job->hw_device_ctx)
+        {
+            hb_qsv_device_init(job, &job->hw_device_ctx);
+            context->hw_device_ctx = av_buffer_ref(job->hw_device_ctx);
+        }
+#endif
         context->pix_fmt = job->output_pix_fmt;
     }
 
@@ -838,6 +937,17 @@ int encavcodecInit( hb_work_object_t * w
         free(filename);
     }
 
+#if HB_PROJECT_FEATURE_QSV
+    if (hb_hwaccel_is_full_hardware_pipeline_enabled(pv->job) &&
+            hb_qsv_decode_is_enabled(job))
+    {
+        pv->context = context;
+        pv->qsv_data.codec = codec;
+        pv->qsv_data.av_opts = av_opts;
+        return 0;
+    }
+#endif
+
     if (hb_avcodec_open(context, codec, &av_opts, HB_FFMPEG_THREADS_AUTO))
     {
         hb_log( "encavcodecInit: avcodec_open failed" );
@@ -1006,6 +1116,49 @@ static hb_buffer_t * process_delay_list(
     return NULL;
 }
 
+static uint8_t convert_pict_type(const AVPacket *pkt, uint16_t *sflags)
+{
+    const uint8_t *sd = av_packet_get_side_data(pkt, AV_PKT_DATA_QUALITY_STATS, NULL);
+
+    enum AVPictureType pict_type = sd ? sd[4] : AV_PICTURE_TYPE_NONE;
+
+    uint16_t flags = HB_FLAG_FRAMETYPE_REF;
+    uint8_t retval = 0;
+
+    switch (pict_type)
+    {
+        case AV_PICTURE_TYPE_B:
+            retval = HB_FRAME_B;
+            break;
+
+        case AV_PICTURE_TYPE_S:
+        case AV_PICTURE_TYPE_P:
+        case AV_PICTURE_TYPE_SP:
+            retval = HB_FRAME_P;
+            break;
+
+        case AV_PICTURE_TYPE_BI:
+        case AV_PICTURE_TYPE_SI:
+        case AV_PICTURE_TYPE_I:
+        default:
+            retval = HB_FRAME_I;
+            break;
+    }
+
+    if (pkt->flags & AV_PKT_FLAG_KEY)
+    {
+        flags |= HB_FLAG_FRAMETYPE_KEY;
+    }
+
+    if (pkt->flags & AV_PKT_FLAG_DISPOSABLE)
+    {
+        flags &= ~HB_FLAG_FRAMETYPE_REF;
+    }
+
+    *sflags = flags;
+    return retval;
+}
+
 static void get_packets( hb_work_object_t * w, hb_buffer_list_t * list )
 {
     hb_work_private_t * pv = w->private_data;
@@ -1033,17 +1186,13 @@ static void get_packets( hb_work_object_
         out->s.start    = get_frame_start(pv, frameno);
         out->s.duration = get_frame_duration(pv, frameno);
         out->s.stop     = out->s.stop + out->s.duration;
-        // libav 12 deprecated context->coded_frame, so we can't determine
-        // the exact frame type any more. So until I can completely
-        // wire up ffmpeg with AV_PKT_DISPOSABLE_FRAME, all frames
-        // must be considered to potentially be reference frames
-        out->s.flags     = HB_FLAG_FRAMETYPE_REF;
-        out->s.frametype = 0;
-        if (pv->pkt->flags & AV_PKT_FLAG_KEY)
+        out->s.frametype = convert_pict_type(pv->pkt, &out->s.flags);
+
+        if (out->s.flags & HB_FLAG_FRAMETYPE_KEY)
         {
-            out->s.flags |= HB_FLAG_FRAMETYPE_KEY;
             hb_chapter_dequeue(pv->chapter_queue, out);
         }
+
         out = process_delay_list(pv, out);
 
         hb_buffer_list_append(list, out);
@@ -1164,6 +1313,50 @@ int encavcodecWork( hb_work_object_t * w
         return HB_WORK_DONE;
     }
 
+#if HB_PROJECT_FEATURE_QSV
+    // postponed encoder initialization, reused code from encavcodecInit()
+    if (hb_hwaccel_is_full_hardware_pipeline_enabled(pv->job) &&
+        hb_qsv_decode_is_enabled(pv->job) && pv->context->hw_frames_ctx == NULL && pv->job->qsv.ctx->hb_ffmpeg_qsv_hw_frames_ctx != NULL)
+    {
+        // use the same hw frames context as for decoder or filter graph hw frames context
+        pv->context->hw_frames_ctx = pv->job->qsv.ctx->hb_ffmpeg_qsv_hw_frames_ctx;
+        int open_ret = 0;
+        if ((open_ret = hb_avcodec_open(pv->context, pv->qsv_data.codec, &pv->qsv_data.av_opts, HB_FFMPEG_THREADS_AUTO)))
+        {
+            hb_log( "encavcodecWork: avcodec_open failed: %s", av_err2str(open_ret) );
+            return HB_WORK_ERROR;
+        }
+
+        /*
+        * Reload colorimetry settings in case custom
+        * values were set in the encoder_options string.
+        */
+        pv->job->color_prim_override     = pv->context->color_primaries;
+        pv->job->color_transfer_override = pv->context->color_trc;
+        pv->job->color_matrix_override   = pv->context->colorspace;
+
+        // avcodec_open populates the opts dictionary with the
+        // things it didn't recognize.
+        AVDictionaryEntry *t = NULL;
+        while( ( t = av_dict_get( pv->qsv_data.av_opts, "", t, AV_DICT_IGNORE_SUFFIX ) ) )
+        {
+            hb_log( "encavcodecWork: Unknown avcodec option %s", t->key );
+        }
+        
+        pv->job->areBframes = 0;
+        if (pv->context->has_b_frames > 0)
+        {
+            pv->job->areBframes = pv->context->has_b_frames;
+        }
+
+        if (pv->context->extradata != NULL)
+        {
+            hb_set_extradata(w->extradata, pv->context->extradata, pv->context->extradata_size);
+        }
+        av_dict_free(&pv->qsv_data.av_opts);
+    }
+#endif
+
     hb_buffer_list_clear(&list);
     if (in->s.flags & HB_BUF_FLAG_EOF)
     {
@@ -1205,6 +1398,13 @@ static int apply_options(hb_job_t *job,
 
 static int apply_encoder_options(hb_job_t *job, AVCodecContext *context, AVDictionary **av_opts)
 {
+#if HB_PROJECT_FEATURE_QSV
+    if (hb_qsv_is_ffmpeg_supported_codec(job->vcodec))
+    {
+        // options applied separately via hb_qsv_apply_encoder_options() call
+        return 0;
+    }
+#endif
     /* place job->encoder_options in an hb_dict_t for convenience */
     hb_dict_t *lavc_opts = NULL;
     if (job->encoder_options != NULL && *job->encoder_options)
@@ -1358,6 +1558,18 @@ static int apply_encoder_preset(int vcod
             break;
 #endif
 
+#if HB_PROJECT_FEATURE_QSV
+        case HB_VCODEC_FFMPEG_QSV_H264:
+        case HB_VCODEC_FFMPEG_QSV_H265:
+        case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_AV1:
+        case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
+            preset = hb_map_qsv_preset_name(preset);
+            av_dict_set( av_opts, "preset", preset, 0);
+            hb_log("encavcodec: encoding with preset %s", preset);
+            break;
+#endif
+
         case HB_VCODEC_FFMPEG_FFV1:
             return apply_ffv1_preset(context, av_opts, preset);
         default:
@@ -1402,6 +1614,13 @@ static int apply_encoder_level(AVCodecCo
             level_values = hb_h264_level_values;
             break;
 
+#if HB_PROJECT_FEATURE_QSV
+        case HB_VCODEC_FFMPEG_QSV_H264:
+            level_names = hb_qsv_h264_level_names;
+            level_values = hb_qsv_h264_levels;
+            break;
+#endif
+
         case HB_VCODEC_FFMPEG_VCE_H265:
         case HB_VCODEC_FFMPEG_VCE_H265_10BIT:
         case HB_VCODEC_FFMPEG_NVENC_H265:
@@ -1411,6 +1630,14 @@ static int apply_encoder_level(AVCodecCo
             level_values = hb_h265_level_values;
             break;
 
+#if HB_PROJECT_FEATURE_QSV
+        case HB_VCODEC_FFMPEG_QSV_H265:
+        case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+            level_names = hb_qsv_h265_level_names;
+            level_values = hb_qsv_h265_levels;
+            break;
+#endif
+
         case HB_VCODEC_FFMPEG_VCE_AV1:
         case HB_VCODEC_FFMPEG_NVENC_AV1:
         case HB_VCODEC_FFMPEG_NVENC_AV1_10BIT:
@@ -1419,6 +1646,14 @@ static int apply_encoder_level(AVCodecCo
             level_values = hb_av1_level_values;
             break;
 
+#if HB_PROJECT_FEATURE_QSV
+        case HB_VCODEC_FFMPEG_QSV_AV1:
+        case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
+            level_names = hb_qsv_av1_level_names;
+            level_values = hb_qsv_av1_levels;
+            break;
+#endif
+
         case HB_VCODEC_FFMPEG_FFV1:
             level_names = hb_ffv1_level_names;
             level_values = hb_ffv1_level_values;
@@ -1489,6 +1724,15 @@ const char* const* hb_av_preset_get_name
         case HB_VCODEC_FFMPEG_FFV1:
             return ffv1_preset_names;
 
+#if HB_PROJECT_FEATURE_QSV
+        case HB_VCODEC_FFMPEG_QSV_H264:
+        case HB_VCODEC_FFMPEG_QSV_H265:
+        case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_AV1:
+        case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
+            return hb_qsv_preset_get_names();
+#endif
+
         default:
             return NULL;
     }
@@ -1502,7 +1746,7 @@ const char* const* hb_av_tune_get_names(
         case HB_VCODEC_FFMPEG_VP9_10BIT:
             return vp9_tune_names;
         default:
-            return NULL;
+            return empty_tune_names;
     }
 }
 
@@ -1524,7 +1768,11 @@ const char* const* hb_av_profile_get_nam
             return av1_mf_profile_name;
         case HB_VCODEC_FFMPEG_FFV1:
             return ffv1_profile_names;
-
+        case HB_VCODEC_FFMPEG_QSV_H264:
+            return h264_qsv_profile_name;
+        case HB_VCODEC_FFMPEG_QSV_H265:
+        case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+            return h265_qsv_profile_name;
          default:
              return NULL;
      }
@@ -1538,19 +1786,23 @@ const char* const* hb_av_level_get_names
         case HB_VCODEC_FFMPEG_MF_H264:
             return hb_h264_level_names;
 
-     case HB_VCODEC_FFMPEG_VCE_H264:
+        case HB_VCODEC_FFMPEG_VCE_H264:
             return hb_vce_h264_level_names; // Not quite the same as x264
 
         case HB_VCODEC_FFMPEG_NVENC_H265:
         case HB_VCODEC_FFMPEG_NVENC_H265_10BIT:
         case HB_VCODEC_FFMPEG_VCE_H265:
         case HB_VCODEC_FFMPEG_VCE_H265_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_H265:
+        case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
         case HB_VCODEC_FFMPEG_MF_H265:
             return hb_h265_level_names;
 
         case HB_VCODEC_FFMPEG_VCE_AV1:
         case HB_VCODEC_FFMPEG_NVENC_AV1:
         case HB_VCODEC_FFMPEG_NVENC_AV1_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_AV1:
+        case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
         case HB_VCODEC_FFMPEG_MF_AV1:
             return hb_av1_level_names;
 
@@ -1589,6 +1841,15 @@ const int* hb_av_get_pix_fmts(int encode
         case HB_VCODEC_FFMPEG_FFV1:
             return ffv1_pix_formats;
 
+        case HB_VCODEC_FFMPEG_QSV_H264:
+        case HB_VCODEC_FFMPEG_QSV_H265:
+        case HB_VCODEC_FFMPEG_QSV_AV1:
+            return qsv_pix_formats;
+
+        case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
+            return qsv_10bit_pix_formats;
+
          default:
              return standard_pix_fmts;
      }
diff -Naupr a/libhb/encavcodecaudio.c b/libhb/encavcodecaudio.c
--- a/libhb/encavcodecaudio.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/encavcodecaudio.c	2025-03-31 11:55:35.240884449 +0200
@@ -1,6 +1,6 @@
 /* encavcodecaudio.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/encavsub.c b/libhb/encavsub.c
--- a/libhb/encavsub.c	1970-01-01 01:00:00.000000000 +0100
+++ b/libhb/encavsub.c	2025-03-31 11:55:35.240884449 +0200
@@ -0,0 +1,406 @@
+/* encavsub.c
+
+   Copyright (c) 2003-2025 HandBrake Team
+   This file is part of the HandBrake source code
+   Homepage: <http://handbrake.fr/>.
+   It may be used under the terms of the GNU General Public License v2.
+   For full terms see the file COPYING file or visit http://www.gnu.org/licenses/gpl-2.0.html
+ */
+
+#include "handbrake/handbrake.h"
+#include "handbrake/hbffmpeg.h"
+#include "handbrake/encavsub.h"
+#include "handbrake/extradata.h"
+
+#define ENC_BUF_DEFAULT_SZ (4 * 1024)
+#define ENC_BUF_MAX_SZ     (1024 * 1024)
+
+struct hb_encavsub_context_s
+{
+    AVCodecContext *context;
+    hb_job_t       *job;
+    hb_subtitle_t  *subtitle;
+
+    // List of subtitle packets to be output by this encoder.
+    hb_buffer_list_t list;
+
+    // avcodec_encode_subtitle encodes to a raw buffer
+    // that we must provide.  *Most* libav subtitle encoders
+    // will return an error (of various sorts: -1, EINVAL,
+    // AVERROR_BUFFER_TOO_SMALL) when the buffer is too small.
+    // Some just overrun the buffer :( DVB )
+    //
+    // TODO: sanitize libav return codes and fix DVB
+    uint8_t        *buffer;
+    int             buffer_size;
+};
+
+struct hb_work_private_s
+{
+    hb_encavsub_context_t *ctx;
+};
+
+static int realloc_enc_buffer(hb_encavsub_context_t * ctx)
+{
+    if (ctx->buffer_size == 0)
+    {
+        ctx->buffer_size = ENC_BUF_DEFAULT_SZ;
+    }
+    else if (ctx->buffer_size * 2 < ENC_BUF_MAX_SZ)
+    {
+        ctx->buffer_size *= 2;
+    }
+    else
+    {
+        return 0;
+    }
+    ctx->buffer = av_realloc(ctx->buffer, ctx->buffer_size);
+    if (ctx->buffer == NULL)
+    {
+        return 0;
+    }
+    return 1;
+}
+
+/***********************************************************************
+ * encavsubInit
+ ***********************************************************************
+ * Init function for libav subtitle encoding that may be wrapped
+ * by HB subtitle encoder
+ **********************************************************************/
+hb_encavsub_context_t * encavsubInit(hb_work_object_t *w, hb_job_t *job)
+{
+    const AVCodec         *codec;
+    AVCodecContext        *context;
+    hb_encavsub_context_t *ctx = calloc(1, sizeof(hb_encavsub_context_t));
+
+    if (ctx == NULL)
+    {
+        hb_error("encavsubInit: calloc ctx failed");
+        return NULL;
+    }
+    ctx->job      = job;
+    ctx->subtitle = w->subtitle;
+
+    codec   = avcodec_find_encoder(w->codec_param);
+    if (codec == NULL)
+    {
+        hb_error("encavsubInit: avcodec_find_encoder failed");
+        goto fail;
+    }
+    context = avcodec_alloc_context3(codec);
+    if (context == NULL)
+    {
+        hb_error("encavsubInit: avcodec_alloc_context3 failed");
+        goto fail;
+    }
+    ctx->context   = context;
+    context->codec = codec;
+
+    // TEXT subtitle encoders require SSA header
+    context->subtitle_header = av_malloc(ctx->subtitle->extradata->size + 1);
+    if (context->subtitle_header == NULL)
+    {
+        hb_error("encavsubInit: av_malloc subtitle_header failed");
+        goto fail;
+    }
+    memcpy(context->subtitle_header, ctx->subtitle->extradata->bytes,
+                                     ctx->subtitle->extradata->size);
+    context->subtitle_header[ctx->subtitle->extradata->size] = '\0';
+    context->subtitle_header_size  = ctx->subtitle->extradata->size + 1;
+    context->time_base             = AV_TIME_BASE_Q;
+
+    // Set encoder opts...
+    AVDictionary *av_opts = NULL;
+    if (w->codec_param == AV_CODEC_ID_MOV_TEXT)
+    {
+        char *height = hb_strdup_printf("%d", job->height);
+        av_dict_set( &av_opts, "height", height, 0 );
+        free(height);
+    }
+    if (hb_avcodec_open(ctx->context, codec, &av_opts, 0))
+    {
+        av_dict_free( &av_opts );
+        hb_error("encavsubInit: avcodec_open failed");
+        goto fail;
+    }
+    av_dict_free( &av_opts );
+
+    // avcodec encoder may create subtitle extradata
+    hb_data_close(&ctx->subtitle->extradata);
+
+    if (context->extradata != NULL && context->extradata_size > 0)
+    {
+        int ret = hb_set_extradata(&ctx->subtitle->extradata,
+                                   context->extradata,
+                                   context->extradata_size);
+        if (ret != 0)
+        {
+            hb_error("encavsubInit: malloc subtitle extradata failed");
+            goto fail;
+        }
+    }
+
+    if (!realloc_enc_buffer(ctx))
+    {
+        hb_error("encavsubInit: realloc buffer failed");
+        goto fail;
+    }
+    hb_buffer_list_clear(&ctx->list);
+
+    return ctx;
+
+
+fail:
+    if (ctx != NULL)
+    {
+        if (ctx->context != NULL)
+        {
+            avcodec_free_context(&ctx->context);
+        }
+    }
+    free(ctx);
+
+    return NULL;
+}
+
+/***********************************************************************
+ * encavsubClose
+ ***********************************************************************
+ * Close function for libav subtitle encoding that may be wrapped
+ * by HB subtitle encoder
+ **********************************************************************/
+void encavsubClose(hb_encavsub_context_t *ctx)
+{
+    if (ctx == NULL)
+    {
+        return;
+    }
+    avcodec_free_context(&ctx->context);
+    av_free(ctx->buffer);
+    free(ctx);
+}
+
+/***********************************************************************
+ * encavsubWork
+ ***********************************************************************
+ * Work function for libav subtitle encoding that may be wrapped
+ * by HB subtitle encoder
+ **********************************************************************/
+int encavsubWork(hb_encavsub_context_t *ctx,
+                 hb_buffer_t **buf_in,
+                 hb_buffer_t **buf_out)
+{
+    hb_buffer_t *in = *buf_in;
+    AVSubtitle   subtitle;
+    int          num_rects = 1;
+    int64_t      duration;
+
+    if (in->s.flags & HB_BUF_FLAG_EOF)
+    {
+        /* EOF on input stream - send it downstream & say that we're done */
+        *buf_in = NULL;
+
+        *buf_out = in;
+        return HB_WORK_DONE;
+    }
+
+    // Create an AVSubtitle from the input buffer
+    memset(&subtitle, 0, sizeof(subtitle));
+    subtitle.rects = av_mallocz(num_rects * sizeof(subtitle.rects));
+    if (subtitle.rects == NULL)
+    {
+        *buf_out = hb_buffer_eof_init();
+        hb_error("encavsubInit: av_mallocz_array failed");
+        return HB_WORK_DONE;
+    }
+
+    for (int ii = 0; ii < num_rects; ii++)
+    {
+        subtitle.rects[ii]  = av_mallocz(sizeof(*subtitle.rects[0]));
+        if (!subtitle.rects[ii]) {
+            avsubtitle_free(&subtitle);
+            *buf_out = hb_buffer_eof_init();
+            hb_error("encavsubInit: av_mallocz failed");
+            return HB_WORK_DONE;
+        }
+        subtitle.num_rects++;
+    }
+
+    if (ctx->subtitle->format == TEXTSUB)
+    {
+        subtitle.rects[0]->type = SUBTITLE_ASS;
+        subtitle.rects[0]->ass  = av_strdup((char *)in->data);
+        if (subtitle.rects[0]->ass == NULL)
+        {
+            avsubtitle_free(&subtitle);
+            *buf_out = hb_buffer_eof_init();
+            hb_error("encavsubInit: av_strdup failed");
+            return HB_WORK_DONE;
+        }
+    }
+    else
+    {
+        // TODO: bitmap subtitles
+        // Must simplify format of hb_buffer_t bitmap representation
+        for (int ii = 0; ii < num_rects; ii++)
+        {
+            subtitle.rects[0]->type = SUBTITLE_BITMAP;
+        }
+    }
+
+    subtitle.pts = av_rescale(in->s.start, AV_TIME_BASE, 90000);
+    if (in->s.stop != AV_NOPTS_VALUE)
+    {
+        duration = in->s.stop - in->s.start;
+        subtitle.end_display_time = av_rescale(duration, 1000, 90000);
+    }
+
+    int size;
+    do
+    {
+        size = avcodec_encode_subtitle(ctx->context,
+                                       ctx->buffer, ctx->buffer_size, &subtitle);
+        if (size < 0)
+        {
+            if (!realloc_enc_buffer(ctx))
+            {
+                avsubtitle_free(&subtitle);
+                *buf_out = hb_buffer_eof_init();
+                hb_error("encavsubInit: realloc failed");
+                return HB_WORK_DONE;
+            }
+        }
+        else if (size > 0)
+        {
+            // Next iteration, flush additional subtitle packets that
+            // the encoder might generate
+            subtitle.num_rects = 0;
+
+            hb_buffer_t *out = hb_buffer_init(size);
+            memcpy(out->data, ctx->buffer, size);
+            out->s.start = av_rescale(subtitle.pts, 90000, AV_TIME_BASE);
+            out->s.duration = (int64_t)AV_NOPTS_VALUE;
+            if (subtitle.end_display_time > 0)
+            {
+                duration = av_rescale(subtitle.end_display_time, 90000, 1000);
+                out->s.stop = out->s.start + duration;
+                out->s.duration = duration;
+            }
+            hb_buffer_list_append(&ctx->list, out);
+        }
+    } while (size < 0);
+
+    subtitle.num_rects = num_rects;
+    avsubtitle_free(&subtitle);
+
+    *buf_out = hb_buffer_list_clear(&ctx->list);
+    return HB_WORK_OK;
+}
+
+/***********************************************************************
+ * Init
+ ***********************************************************************
+ * Initialize hb_work_private_t data
+ **********************************************************************/
+static int Init(hb_work_object_t *w, hb_job_t *job)
+{
+    hb_work_private_t *pv;
+
+    pv = calloc(1, sizeof(hb_work_private_t));
+    if (pv == NULL)
+    {
+        hb_error("encsubInit: calloc private data failed");
+        return 1;
+    }
+
+    pv->ctx = encavsubInit(w, job);
+    if (pv->ctx == NULL)
+    {
+        free(pv);
+        return 1;
+    }
+    w->private_data = pv;
+
+    return 0;
+}
+
+/***********************************************************************
+ * Close
+ ***********************************************************************
+ * Free any allocation in hb_work_private_t
+ **********************************************************************/
+static void Close(hb_work_object_t *w)
+{
+    hb_work_private_t * pv = w->private_data;
+    if (pv == NULL)
+    {
+        return;
+    }
+    encavsubClose(pv->ctx);
+    free(pv);
+    w->private_data = NULL;
+}
+
+/***********************************************************************
+ * Work
+ ***********************************************************************
+ * Take an input buffer, send an output buffer
+ **********************************************************************/
+static int Work(hb_work_object_t *w, hb_buffer_t **buf_in,
+                hb_buffer_t **buf_out)
+{
+    hb_work_private_t *pv = w->private_data;
+
+    return encavsubWork(pv->ctx, buf_in, buf_out);
+}
+
+/***********************************************************************
+ * Info
+ ***********************************************************************
+ * Retrieve current info about context initialized during Init
+ **********************************************************************/
+static int Info(hb_work_object_t *w, hb_work_info_t *info)
+{
+    memset(info, 0, sizeof(*info));
+
+    // Indicate no info is returned
+    return 0;
+}
+
+/***********************************************************************
+ * BSInfo
+ ***********************************************************************
+ * Retrieve info, does not require Init(), but uses current context
+ * if Init has already been called.
+ * buf contains stream data to extract info from.
+ **********************************************************************/
+static int BSInfo(hb_work_object_t *w, const hb_buffer_t *buf,
+                  hb_work_info_t *info)
+{
+    memset(info, 0, sizeof(*info));
+
+    // Indicate no info is returned
+    return 0;
+}
+
+/***********************************************************************
+ * Flush
+ ***********************************************************************
+ * Reset context without closing, kind of poorly named :(
+ **********************************************************************/
+static void Flush(hb_work_object_t *w)
+{
+}
+
+hb_work_object_t hb_encavsub =
+{
+    .id     = WORK_ENCAVSUB,
+    .name   = "Subtitle encoder (libavcodec)",
+    .init   = Init,
+    .work   = Work,
+    .close  = Close,
+    .info   = Info,
+    .bsinfo = BSInfo,
+    .flush  = Flush,
+};
diff -Naupr a/libhb/encsvtav1.c b/libhb/encsvtav1.c
--- a/libhb/encsvtav1.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/encsvtav1.c	2025-03-31 11:55:35.240884449 +0200
@@ -1,6 +1,6 @@
 /* encsvtav1.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    partially based on FFmpeg libsvtav1.c
    Homepage: <http://handbrake.fr/>.
@@ -99,7 +99,7 @@ int encsvtInit(hb_work_object_t *w, hb_j
     EbErrorType svt_ret;
     int ret;
 
-    svt_ret = svt_av1_enc_init_handle(&pv->svt_handle, pv, &pv->enc_params);
+    svt_ret = svt_av1_enc_init_handle(&pv->svt_handle, &pv->enc_params);
     if (svt_ret != EB_ErrorNone)
     {
         hb_error("encsvtav1: error initializing encoder handle");
@@ -329,7 +329,7 @@ int encsvtInit(hb_work_object_t *w, hb_j
     }
 
     // Update and set Dolby Vision level
-    if (job->passthru_dynamic_hdr_metadata & DOVI)
+    if (job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_DOVI)
     {
         int level_idx, high_tier;
         hb_parse_av1_extradata(*w->extradata, &level_idx, &high_tier);
@@ -486,7 +486,7 @@ static int send(hb_work_object_t *w, hb_
         for (int i = 0; i < in->nb_side_data; i++)
         {
             const AVFrameSideData *side_data = in->side_data[i];
-            if (job->passthru_dynamic_hdr_metadata & HDR_10_PLUS &&
+            if (job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_HDR10PLUS &&
                 side_data->type == AV_FRAME_DATA_DYNAMIC_HDR_PLUS)
             {
                 uint8_t *payload = NULL;
@@ -501,7 +501,7 @@ static int send(hb_work_object_t *w, hb_
                 svt_add_metadata(headerPtr, EB_AV1_METADATA_TYPE_ITUT_T35, payload, playload_size);
                 av_freep(&payload);
             }
-            else if (job->passthru_dynamic_hdr_metadata & DOVI &&
+            else if (job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_DOVI &&
                      side_data->type == AV_FRAME_DATA_DOVI_RPU_BUFFER_T35)
             {
                 svt_add_metadata(headerPtr, EB_AV1_METADATA_TYPE_ITUT_T35, side_data->data, side_data->size);
diff -Naupr a/libhb/enctheora.c b/libhb/enctheora.c
--- a/libhb/enctheora.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/enctheora.c	2025-03-31 11:55:35.241884432 +0200
@@ -1,6 +1,6 @@
 /* enctheora.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/enctx3gsub.c b/libhb/enctx3gsub.c
--- a/libhb/enctx3gsub.c	1970-01-01 01:00:00.000000000 +0100
+++ b/libhb/enctx3gsub.c	2025-03-31 11:55:35.241884432 +0200
@@ -0,0 +1,195 @@
+/* enctx3gsub.c
+
+   Copyright (c) 2003-2025 HandBrake Team
+   This file is part of the HandBrake source code
+   Homepage: <http://handbrake.fr/>.
+   It may be used under the terms of the GNU General Public License v2.
+   For full terms see the file COPYING file or visit http://www.gnu.org/licenses/gpl-2.0.html
+ */
+
+#include "handbrake/handbrake.h"
+#include "handbrake/extradata.h"
+#include "handbrake/ssautil.h"
+
+struct hb_work_private_s
+{
+    hb_job_t       *job;
+    hb_subtitle_t  *subtitle;
+
+    hb_tx3g_style_context_t *tx3g;
+};
+
+static int Init(hb_work_object_t *w, hb_job_t *job)
+{
+    hb_work_private_t *pv = calloc(1, sizeof(hb_work_private_t));
+
+    if (pv == NULL)
+    {
+        hb_error("enctx3gsubInit: calloc private data failed");
+        return 1;
+    }
+
+    w->private_data = pv;
+
+    pv->job      = job;
+    pv->subtitle = w->subtitle;
+    pv->tx3g = hb_tx3g_style_init(job->height,
+                                  pv->subtitle->extradata->bytes,
+                                  pv->subtitle->extradata->size);
+
+    if (pv->tx3g == NULL)
+    {
+        hb_error("enctx3gsubInit: hb_tx3g_style_init failed");
+        goto fail;
+    }
+
+    // Build codec extradata for tx3g
+    uint8_t properties[] = {
+        0x00, 0x00, 0x00, 0x00,     // Display Flags
+        0x01,                       // Horiz. Justification
+        0xff,                       // Vert. Justification
+        0x00, 0x00, 0x00, 0xff,     // Bg color
+        0x00, 0x00, 0x00, 0x00,     // Default text box
+        0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00,     // Reserved
+        0x00, 0x01,                 // Font ID
+        0x00,                       // Font face
+        0x18,                       // Font size
+        0xff, 0xff, 0xff, 0xff,     // Fg color
+        // Font table:
+        0x00, 0x00, 0x00, 0x12,     // Font table size
+        'f','t','a','b',            // Tag
+        0x00, 0x01,                 // Count
+        0x00, 0x01,                 // Font ID
+        0x05,                       // Font name length
+        'A','r','i','a','l'         // Font name
+    };
+
+    int width, height, font_size;
+    width     = job->width * job->par.num / job->par.den;
+    font_size = 0.05 * job->height;
+    if (font_size < 12)
+    {
+        font_size = 12;
+    }
+    else if (font_size > 255)
+    {
+        font_size = 255;
+    }
+    properties[25] = font_size;
+    height = 3 * font_size;
+    properties[14] = height >> 8;
+    properties[15] = height & 0xff;
+    properties[16] = width >> 8;
+    properties[17] = width & 0xff;
+
+    pv->subtitle->width  = width;
+    pv->subtitle->height = height;
+
+    int ret = hb_set_extradata(&pv->subtitle->extradata,
+                               properties,
+                               sizeof(properties));
+    if (ret != 0)
+    {
+        hb_error("enctx3gsubInit: set subtitle extradata failed");
+        goto fail;
+    }
+
+    return 0;
+
+fail:
+    return 1;
+}
+
+static void Close(hb_work_object_t *w)
+{
+    hb_work_private_t *pv = w->private_data;
+    if (pv == NULL)
+    {
+        return;
+    }
+    hb_tx3g_style_close(&pv->tx3g);
+    free(pv);
+    w->private_data = NULL;
+}
+
+static int Work(hb_work_object_t *w,
+                hb_buffer_t **buf_in,
+                hb_buffer_t **buf_out)
+{
+    hb_work_private_t *pv = w->private_data;
+    hb_buffer_t *in = *buf_in;
+    hb_buffer_t *out = NULL;
+
+    if (in->s.flags & HB_BUF_FLAG_EOF)
+    {
+        // EOF on input stream - send it downstream & say that we're done
+        *buf_in = NULL;
+        *buf_out = in;
+        return HB_WORK_DONE;
+    }
+
+    uint8_t  *styleatom;
+    uint16_t  stylesize = 0;
+    uint8_t  *buffer;
+    uint16_t  buffersize = 0;
+
+    // Copy the subtitle into buffer stripping markup and
+    // creating style atoms for them.
+    hb_muxmp4_process_subtitle_style(pv->tx3g, in->data, &buffer,
+                                     &styleatom, &stylesize);
+
+    if (buffer != NULL)
+    {
+        buffersize = strlen((char *)buffer);
+        if (styleatom == NULL)
+        {
+            stylesize = 0;
+        }
+        out = hb_buffer_init(2 + buffersize + stylesize);
+        out->s = in->s;
+
+        // Write the subtitle sample
+        memcpy(out->data + 2, buffer, buffersize);
+        memcpy(out->data + 2 + buffersize, styleatom, stylesize);
+        out->data[0] = (buffersize >> 8) & 0xff;
+        out->data[1] = buffersize & 0xff;
+    }
+    free(buffer);
+    free(styleatom);
+
+    *buf_out = out;
+
+    return HB_WORK_OK;
+}
+
+static int Info(hb_work_object_t *w, hb_work_info_t *info)
+{
+    memset(info, 0, sizeof(*info));
+
+    // Indicate no info is returned
+    return 0;
+}
+
+static int BSInfo(hb_work_object_t *w, const hb_buffer_t *buf,
+                  hb_work_info_t *info)
+{
+    memset(info, 0, sizeof(*info));
+
+    // Indicate no info is returned
+    return 0;
+}
+
+static void Flush(hb_work_object_t *w) {}
+
+hb_work_object_t hb_enctx3gsub =
+{
+    .id     = WORK_ENCTX3GSUB,
+    .name   = "TX3G encoder",
+    .init   = Init,
+    .work   = Work,
+    .close  = Close,
+    .info   = Info,
+    .bsinfo = BSInfo,
+    .flush  = Flush,
+};
diff -Naupr a/libhb/encvorbis.c b/libhb/encvorbis.c
--- a/libhb/encvorbis.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/encvorbis.c	2025-03-31 11:55:35.241884432 +0200
@@ -1,6 +1,6 @@
 /* encvorbis.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/encx264.c b/libhb/encx264.c
--- a/libhb/encx264.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/encx264.c	2025-03-31 11:55:35.241884432 +0200
@@ -1,6 +1,6 @@
 /* encx264.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/encx265.c b/libhb/encx265.c
--- a/libhb/encx265.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/encx265.c	2025-03-31 11:55:35.241884432 +0200
@@ -1,6 +1,6 @@
 /* encx265.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -493,7 +493,7 @@ int encx265Init(hb_work_object_t *w, hb_
     /*
      * Update and set Dolby Vision level
      */
-    if (job->passthru_dynamic_hdr_metadata & DOVI)
+    if (job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_DOVI)
     {
         char dolbyVisionProfile[256];
         snprintf(dolbyVisionProfile, sizeof(dolbyVisionProfile),
@@ -713,7 +713,7 @@ static hb_buffer_t* x265_encode(hb_work_
         for (int i = 0; i < in->nb_side_data; i++)
         {
             const AVFrameSideData *side_data = in->side_data[i];
-            if (job->passthru_dynamic_hdr_metadata & HDR_10_PLUS &&
+            if (job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_HDR10PLUS &&
                 side_data->type == AV_FRAME_DATA_DYNAMIC_HDR_PLUS)
             {
                 uint8_t *payload = NULL;
@@ -743,7 +743,7 @@ static hb_buffer_t* x265_encode(hb_work_
                 sei_payload->payloadType = USER_DATA_REGISTERED_ITU_T_T35;
                 sei->numPayloads++;
             }
-            if (job->passthru_dynamic_hdr_metadata & DOVI &&
+            if (job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_DOVI &&
                 side_data->type == AV_FRAME_DATA_DOVI_RPU_BUFFER)
             {
                 x265_dolby_vision_rpu *rpu = &pic_in.rpu;
diff -Naupr a/libhb/extradata.c b/libhb/extradata.c
--- a/libhb/extradata.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/extradata.c	2025-03-31 11:55:35.241884432 +0200
@@ -1,6 +1,6 @@
 /* extradata.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -29,88 +29,6 @@ int hb_set_extradata(hb_data_t **extrada
     return 0;
 }
 
-int hb_set_text_extradata(hb_data_t **extradata, const uint8_t *bytes, size_t length)
-{
-    hb_data_close(extradata);
-
-    if (length > 0)
-    {
-        *extradata = hb_data_init(length + 1);
-        if (*extradata == NULL)
-        {
-            hb_error("extradata: malloc failure");
-            return 1;
-        }
-        memcpy((*extradata)->bytes, bytes, length);
-        (*extradata)->bytes[length] = 0;
-    }
-    return 0;
-}
-
-int hb_set_ssa_extradata(hb_data_t **extradata, const char *font, int fs, int w, int h)
-{
-    hb_data_close(extradata);
-
-    char *header = NULL;
-    float shadow_size = fs / 36.0;
-    float outline_size = fs / 30.0;
-
-    char *shadow_size_string = hb_strdup_printf("%.2f", shadow_size);
-    hb_str_from_locale(shadow_size_string);
-
-    char *outline_size_string = hb_strdup_printf("%.2f", outline_size);
-    hb_str_from_locale(outline_size_string);
-
-    if (shadow_size_string == NULL || outline_size_string == NULL)
-    {
-        goto fail;
-    }
-
-    // SRT subtitles are represented internally as SSA
-    // Create an SSA header
-    const char * ssa_header =
-        "[Script Info]\r\n"
-        "ScriptType: v4.00+\r\n"
-        "Collisions: Normal\r\n"
-        "PlayResX: %d\r\n"
-        "PlayResY: %d\r\n"
-        "Timer: 100.0\r\n"
-        "WrapStyle: 0\r\n"
-        "ScaledBorderAndShadow: yes\r\n"
-        "\r\n"
-        "[V4+ Styles]\r\n"
-        "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\r\n"
-        "Style: Default,%s,%d,&H00FFFFFF,&H00FFFFFF,&H000F0F0F,&H000F0F0F,0,0,0,0,100,100,0,0.00,1,%s,%s,2,20,20,20,0\r\n";
-
-    header = hb_strdup_printf(ssa_header, w, h, font, fs, outline_size_string, shadow_size_string);
-    if (header == NULL)
-    {
-        goto fail;
-    }
-
-    size_t size = strlen(header) + 1;
-    *extradata = hb_data_init(size);
-    if (*extradata == NULL)
-    {
-        goto fail;
-    }
-
-    memcpy((*extradata)->bytes, header, size);
-    free(header);
-    free(shadow_size_string);
-    free(outline_size_string);
-
-    return 0;
-
-fail:
-    hb_error("ssa extradata: malloc failure");
-    free(header);
-    free(shadow_size_string);
-    free(outline_size_string);
-
-    return 1;
-}
-
 int hb_set_h264_extradata(hb_data_t **extradata, uint8_t *sps, size_t sps_length, uint8_t *pps, size_t pps_length)
 {
     hb_data_close(extradata);
diff -Naupr a/libhb/fifo.c b/libhb/fifo.c
--- a/libhb/fifo.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/fifo.c	2025-03-31 11:55:35.241884432 +0200
@@ -1,6 +1,6 @@
 /* fifo.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    Copyright 2022 NVIDIA Corporation
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
@@ -11,14 +11,11 @@
 #include "libavcodec/avcodec.h"
 
 #include "handbrake/handbrake.h"
-#if HB_PROJECT_FEATURE_QSV
-#include "handbrake/qsv_libav.h"
-#include "handbrake/qsv_common.h"
-#endif
 
 #ifdef __APPLE__
 #include <CoreMedia/CoreMedia.h>
 #include "platform/macosx/vt_common.h"
+#include "platform/macosx/cv_utils.h"
 #endif
 
 #ifndef SYS_DARWIN
@@ -634,7 +631,7 @@ int hb_buffer_is_writable(const hb_buffe
             return 1;
 #ifdef __APPLE__
         case COREMEDIA:
-            return CFGetRetainCount(buf->storage);
+            return hb_cv_get_io_surface_usage_count(buf) == 1;
 #endif
         default:
             return 0;
@@ -1036,43 +1033,6 @@ void hb_buffer_swap_copy( hb_buffer_t *s
     src->alloc = alloc;
 }
 
-#if HB_PROJECT_FEATURE_QSV
-static void free_qsv_resources(hb_buffer_t *b)
-{
-    // Reclaim QSV resources before dropping the buffer.
-    // when decoding without QSV, the QSV atom will be NULL.
-    if (b->storage != NULL && b->qsv_details.ctx != NULL)
-    {
-        AVFrame *frame = (AVFrame *)b->storage;
-        mfxFrameSurface1 *surface = (mfxFrameSurface1 *)frame->data[3];
-        if (surface)
-        {
-            hb_qsv_release_surface_from_pool_by_surface_pointer(b->qsv_details.qsv_frames_ctx, surface);
-            frame->data[3] = 0;
-        }
-    }
-    if (b->qsv_details.qsv_atom != NULL && b->qsv_details.ctx != NULL)
-    {
-        hb_qsv_stage *stage = hb_qsv_get_last_stage(b->qsv_details.qsv_atom);
-        if (stage != NULL)
-        {
-            hb_qsv_wait_on_sync(b->qsv_details.ctx, stage);
-            if (stage->out.sync->in_use > 0)
-            {
-                ff_qsv_atomic_dec(&stage->out.sync->in_use);
-            }
-            if (stage->out.p_surface->Data.Locked > 0)
-            {
-                ff_qsv_atomic_dec(&stage->out.p_surface->Data.Locked);
-            }
-        }
-        hb_qsv_flush_stages(b->qsv_details.ctx->pipes,
-                            (hb_qsv_list**)&b->qsv_details.qsv_atom, 1);
-    }
-}
-#endif
-
-
 static void free_buffer_resources(hb_buffer_t *b)
 {
     if (b->storage_type == AVFRAME)
@@ -1111,9 +1071,6 @@ void hb_buffer_close( hb_buffer_t ** _b
         hb_unlock(buffers.lock);
 #endif
 
-#if HB_PROJECT_FEATURE_QSV
-        free_qsv_resources(b);
-#endif
         free_buffer_resources(b);
 
         if (buffer_pool && !hb_fifo_is_full(buffer_pool))
diff -Naupr a/libhb/format.c b/libhb/format.c
--- a/libhb/format.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/format.c	2025-03-31 11:55:35.241884432 +0200
@@ -1,6 +1,6 @@
 /* format.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -11,8 +11,6 @@
 #include "handbrake/avfilter_priv.h"
 #if HB_PROJECT_FEATURE_QSV && (defined( _WIN32 ) || defined( __MINGW32__ ))
 #include "handbrake/qsv_common.h"
-#include "libavutil/hwcontext_qsv.h"
-#include "libavutil/hwcontext.h"
 #endif
 
 static int format_init(hb_filter_object_t *filter,
@@ -71,15 +69,6 @@ static int format_init(hb_filter_object_
         if (init->job->qsv.ctx->out_range != AVCOL_RANGE_UNSPECIFIED)
             hb_dict_set_string(avsettings, "out_range", (init->job->qsv.ctx->out_range == AVCOL_RANGE_JPEG) ? "full" : "limited");
 
-        if (hb_qsv_hw_filters_via_video_memory_are_enabled(init->job))
-        {
-            int result = hb_qsv_create_ffmpeg_vpp_pool(init, init->geometry.width, init->geometry.height);
-            if (result < 0)
-            {
-                hb_error("hb_create_ffmpeg_pool vpp allocation failed");
-                return result;
-            }
-        }
         hb_dict_set(avfilter, "vpp_qsv", avsettings);
     }
     else
diff -Naupr a/libhb/grayscale.c b/libhb/grayscale.c
--- a/libhb/grayscale.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/grayscale.c	2025-03-31 11:55:35.241884432 +0200
@@ -1,6 +1,6 @@
 /* grayscale.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/audio_remap.h b/libhb/handbrake/audio_remap.h
--- a/libhb/handbrake/audio_remap.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/audio_remap.h	2025-03-31 11:55:35.241884432 +0200
@@ -1,6 +1,6 @@
 /* audio_remap.h
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code
  * Homepage: <http://handbrake.fr/>
  * It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/audio_resample.h b/libhb/handbrake/audio_resample.h
--- a/libhb/handbrake/audio_resample.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/audio_resample.h	2025-03-31 11:55:35.241884432 +0200
@@ -1,6 +1,6 @@
 /* audio_resample.h
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code
  * Homepage: <http://handbrake.fr/>
  * It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/av1_common.h b/libhb/handbrake/av1_common.h
--- a/libhb/handbrake/av1_common.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/av1_common.h	2025-03-31 11:55:35.241884432 +0200
@@ -1,6 +1,6 @@
 /* av1_common.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -24,17 +24,17 @@ static const int          hb_av1_level_v
      -1,  20,  21,  22,  23,  30,  31,  32,  33,  40,  41,  42,
      43,  50,  51,  52,  53,  60,  61,  62,  63,  0 };
 
-static const char * const av1_svt_preset_names[] =
+static const char * const hb_av1_svt_preset_names[] =
 {
-    "13", "12", "11", "10", "9", "8", "7", "6", "5", "4", "3", "2", "1", "0", "-1", NULL
+    "10", "9", "8", "7", "6", "5", "4", "3", "2", "1", "0", "-1", NULL
 };
 
-static const char * const av1_svt_tune_names[] =
+static const char * const hb_av1_svt_tune_names[] =
 {
-    "psnr", "ssim", "fastdecode", NULL
+    "vq", "psnr", "ssim", "fastdecode", NULL
 };
 
-static const char * const av1_svt_profile_names[] =
+static const char * const hb_av1_svt_profile_names[] =
 {
     "auto", "main", NULL // "high", "profesional"
 };
diff -Naupr a/libhb/handbrake/avfilter_priv.h b/libhb/handbrake/avfilter_priv.h
--- a/libhb/handbrake/avfilter_priv.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/avfilter_priv.h	2025-03-31 11:55:35.241884432 +0200
@@ -1,6 +1,6 @@
 /* avfilter_priv.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/bitstream.h b/libhb/handbrake/bitstream.h
--- a/libhb/handbrake/bitstream.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/bitstream.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* bitstream.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/colormap.h b/libhb/handbrake/colormap.h
--- a/libhb/handbrake/colormap.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/colormap.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* colormap.h
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/common.h b/libhb/handbrake/common.h
--- a/libhb/handbrake/common.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/common.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* common.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -146,6 +146,8 @@ void hb_limit_rational( int *x, int *y,
 void hb_reduce64( int64_t *x, int64_t *y, int64_t num, int64_t den );
 void hb_limit_rational64( int64_t *x, int64_t *y, int64_t num, int64_t den, int64_t limit );
 
+void hb_update_str( char **dst, const char *src );
+
 void hb_job_set_encoder_preset (hb_job_t *job, const char *preset);
 void hb_job_set_encoder_tune   (hb_job_t *job, const char *tune);
 void hb_job_set_encoder_options(hb_job_t *job, const char *options);
@@ -160,6 +162,7 @@ void hb_audio_config_init(hb_audio_confi
 int hb_audio_add(const hb_job_t * job, const hb_audio_config_t * audiocfg);
 hb_audio_config_t * hb_list_audio_config_item(hb_list_t * list, int i);
 
+void hb_subtitle_config_copy(hb_subtitle_config_t *dst, const hb_subtitle_config_t *src);
 hb_subtitle_t *hb_subtitle_copy(const hb_subtitle_t *src);
 hb_list_t *hb_subtitle_list_copy(const hb_list_t *src);
 void hb_subtitle_close( hb_subtitle_t **sub );
@@ -170,8 +173,11 @@ int hb_import_subtitle_add( const hb_job
 int hb_srt_add(const hb_job_t * job, const hb_subtitle_config_t * subtitlecfg,
                const char *lang);
 int hb_subtitle_can_force( int source );
+int hb_subtitle_can_export( int source );
 int hb_subtitle_can_burn( int source );
 int hb_subtitle_can_pass( int source, int mux );
+int hb_subtitle_must_burn(hb_subtitle_t * subtitle, int mux);
+int hb_subtitle_extradata_init(hb_subtitle_t * subtitle);
 
 int hb_audio_can_apply_drc(uint32_t codec, uint32_t codec_param, int encoder);
 int hb_audio_can_apply_drc2(hb_handle_t *h, int title_idx,
@@ -187,7 +193,9 @@ hb_metadata_t * hb_metadata_copy(const h
 void hb_metadata_close(hb_metadata_t **metadata);
 void hb_update_meta_dict(hb_dict_t * dict, const char * key, const char * value);
 const char * hb_lookup_meta_key(const char * mux_key);
-void hb_metadata_add_coverart( hb_metadata_t *metadata, const uint8_t *data, int size, int type );
+void hb_metadata_add_coverart( hb_metadata_t *metadata,
+                               const uint8_t *data, int size,
+                               int type, const char *name );
 void hb_metadata_rem_coverart( hb_metadata_t *metadata, int ii );
 
 hb_chapter_t *hb_chapter_copy(const hb_chapter_t *src);
@@ -329,6 +337,17 @@ struct hb_subtitle_config_s
     int          force;
     int          default_track;
     const char * name;
+    char       * external_filename;
+    enum subtitle_output_codec {
+        HB_SCODEC_PASS = 0,
+        HB_SCODEC_SSA,
+        HB_SCODEC_SRT,
+        HB_SCODEC_TX3G,
+        HB_SCODEC_PGS,
+        HB_SCODEC_DVD,
+        HB_SCODEC_VTT
+    } codec;
+    uint32_t     codec_param;    /* Per-codec config info */
 
     /* SRT subtitle tracks only */
     const char * src_filename;
@@ -371,6 +390,14 @@ struct hb_dovi_conf_s
     unsigned dv_bl_signal_compatibility_id;
 };
 
+typedef enum
+{
+    HB_HDR_DYNAMIC_METADATA_NONE      = 0,
+    HB_HDR_DYNAMIC_METADATA_HDR10PLUS = 1 << 1,
+    HB_HDR_DYNAMIC_METADATA_DOVI      = 1 << 2,
+    HB_HDR_DYNAMIC_METADATA_ALL       = HB_HDR_DYNAMIC_METADATA_HDR10PLUS | HB_HDR_DYNAMIC_METADATA_DOVI
+} hb_hdr_dynamic_metadata_mode_t;
+
 int hb_str_ends_with(const char *base, const char *str);
 
 /*******************************************************************************
@@ -437,6 +464,11 @@ int         hb_video_quality_is_supporte
 int         hb_video_bitrate_is_supported(uint32_t codec);
 int         hb_video_multipass_is_supported(uint32_t codec, int constant_quality);
 
+int                hb_video_hdr_dynamic_metadata_is_supported(uint32_t codec, int hdr_dynamic_metadata, int profile);
+
+int                hb_hdr_dynamic_metadata_get_from_name(const char *name);
+const char*        hb_hdr_dynamic_metadata_get_name(int hdr_dynamic_metadata);
+
 int                hb_video_encoder_is_supported(int encoder);
 int                hb_video_encoder_get_count_of_analysis_passes(int encoder);
 int                hb_video_encoder_pix_fmt_is_supported(int encoder, int pix_fmt, const char *profile);
@@ -642,14 +674,14 @@ struct hb_job_s
 #define HB_VCODEC_VT_H265           (0x00000051 | HB_VCODEC_VT_MASK | HB_VCODEC_H265_MASK)
 #define HB_VCODEC_VT_H265_10BIT     (0x00000052 | HB_VCODEC_VT_MASK | HB_VCODEC_H265_MASK)
 
-#define HB_VCODEC_QSV_H264          (0x00000060 | HB_VCODEC_QSV_MASK | HB_VCODEC_H264_MASK)
-#define HB_VCODEC_QSV_H265_8BIT     (0x00000061 | HB_VCODEC_QSV_MASK | HB_VCODEC_H265_MASK)
-#define HB_VCODEC_QSV_H265_10BIT    (0x00000062 | HB_VCODEC_QSV_MASK | HB_VCODEC_H265_MASK)
-#define HB_VCODEC_QSV_H265          HB_VCODEC_QSV_H265_8BIT
-
-#define HB_VCODEC_QSV_AV1_8BIT      (0x00000070 | HB_VCODEC_QSV_MASK | HB_VCODEC_AV1_MASK)
-#define HB_VCODEC_QSV_AV1_10BIT     (0x00000071 | HB_VCODEC_QSV_MASK | HB_VCODEC_AV1_MASK)
-#define HB_VCODEC_QSV_AV1           HB_VCODEC_QSV_AV1_8BIT
+#define HB_VCODEC_FFMPEG_QSV_H264          (0x00000060 | HB_VCODEC_FFMPEG_MASK | HB_VCODEC_QSV_MASK | HB_VCODEC_H264_MASK)
+#define HB_VCODEC_FFMPEG_QSV_H265_8BIT     (0x00000061 | HB_VCODEC_FFMPEG_MASK | HB_VCODEC_QSV_MASK | HB_VCODEC_H265_MASK)
+#define HB_VCODEC_FFMPEG_QSV_H265_10BIT    (0x00000062 | HB_VCODEC_FFMPEG_MASK | HB_VCODEC_QSV_MASK | HB_VCODEC_H265_MASK)
+#define HB_VCODEC_FFMPEG_QSV_H265          HB_VCODEC_FFMPEG_QSV_H265_8BIT
+
+#define HB_VCODEC_FFMPEG_QSV_AV1_8BIT      (0x00000070 | HB_VCODEC_FFMPEG_MASK | HB_VCODEC_QSV_MASK | HB_VCODEC_AV1_MASK)
+#define HB_VCODEC_FFMPEG_QSV_AV1_10BIT     (0x00000071 | HB_VCODEC_FFMPEG_MASK | HB_VCODEC_QSV_MASK | HB_VCODEC_AV1_MASK)
+#define HB_VCODEC_FFMPEG_QSV_AV1           HB_VCODEC_FFMPEG_QSV_AV1_8BIT
 
 /* define an invalid CQ value compatible with all CQ-capable codecs */
 #define HB_INVALID_VIDEO_QUALITY (-1000.)
@@ -750,7 +782,7 @@ struct hb_job_s
     hb_ambient_viewing_environment_metadata_t ambient;
     hb_dovi_conf_t dovi;
 
-    enum {NONE = 0x0, ALL = 0x3, DOVI = 0x1, HDR_10_PLUS = 0x2} passthru_dynamic_hdr_metadata;
+    hb_hdr_dynamic_metadata_mode_t passthru_dynamic_hdr_metadata;
 
 
     hb_list_t     * list_chapter;
@@ -850,11 +882,11 @@ struct hb_job_s
     int             init_delay;
     hb_data_t     * extradata;
 
-    hb_fifo_t     * fifo_mpeg2;   /* MPEG-2 video ES */
+    hb_fifo_t     * fifo_in;      /* Input to video decoder */
     hb_fifo_t     * fifo_raw;     /* Raw pictures */
     hb_fifo_t     * fifo_sync;    /* Raw pictures, framerate corrected */
     hb_fifo_t     * fifo_render;  /* Raw pictures, scaled */
-    hb_fifo_t     * fifo_mpeg4;   /* MPEG-4 video ES */
+    hb_fifo_t     * fifo_out;     /* Encoder video output, input to mux */
 
     hb_list_t     * list_work;
 
@@ -1152,9 +1184,10 @@ struct hb_subtitle_s
     // Codec private data for subtitles originating from FFMPEG sources
     hb_data_t   * extradata;
 
-    hb_fifo_t     * fifo_in;        /* SPU ES */
-    hb_fifo_t     * fifo_raw;       /* Decoded SPU */
-    hb_fifo_t     * fifo_out;       /* Correct Timestamps, ready to be muxed */
+    hb_fifo_t     * fifo_in;   /* Input to decoder */
+    hb_fifo_t     * fifo_raw;  /* Decoder output, input to sync */
+    hb_fifo_t     * fifo_sync; /* Sync output, input to encoder */
+    hb_fifo_t     * fifo_out;  /* Encoder output, input to mux */
     hb_mux_data_t * mux_data;
 #endif
 };
@@ -1174,6 +1207,7 @@ struct hb_attachment_s
 
 struct hb_coverart_s
 {
+    char    *name;
     uint8_t *data;
     uint32_t size;
     enum arttype {
@@ -1260,7 +1294,7 @@ struct hb_title_s
 #define HB_DECODE_SUPPORT_VIDEOTOOLBOX   0x08
 #define HB_DECODE_SUPPORT_MF             0x10 // Windows Media Foundation
 
-#define HB_DECODE_SUPPORT_HWACCEL        (HB_DECODE_SUPPORT_NVDEC | HB_DECODE_SUPPORT_VIDEOTOOLBOX | HB_DECODE_SUPPORT_MF)
+#define HB_DECODE_SUPPORT_HWACCEL        (HB_DECODE_SUPPORT_NVDEC | HB_DECODE_SUPPORT_VIDEOTOOLBOX | HB_DECODE_SUPPORT_QSV | HB_DECODE_SUPPORT_MF)
 #define HB_DECODE_SUPPORT_FORCE_HW       0x80000000
 
     hb_metadata_t * metadata;
@@ -1419,6 +1453,7 @@ struct hb_work_object_s
 #endif
 };
 
+extern hb_work_object_t hb_workpass;
 extern hb_work_object_t hb_sync_video;
 extern hb_work_object_t hb_sync_audio;
 extern hb_work_object_t hb_sync_subtitle;
@@ -1426,8 +1461,10 @@ extern hb_work_object_t hb_decvobsub;
 extern hb_work_object_t hb_decsrtsub;
 extern hb_work_object_t hb_decutf8sub;
 extern hb_work_object_t hb_dectx3gsub;
+extern hb_work_object_t hb_enctx3gsub;
 extern hb_work_object_t hb_decssasub;
 extern hb_work_object_t hb_decavsub;
+extern hb_work_object_t hb_encavsub;
 extern hb_work_object_t hb_encavcodec;
 extern hb_work_object_t hb_encqsv;
 extern hb_work_object_t hb_encvt;
@@ -1603,9 +1640,12 @@ struct hb_blend_object_s
     char                * name;
 
 #ifdef __LIBHB__
-    int                (* init)       ( hb_blend_object_t *, int in_pix_fmt, int in_chroma_location, int sub_pix_fmt );
+    int                (* init)       ( hb_blend_object_t *, int in_width, int in_height,
+                                        int in_pix_fmt, int in_chroma_location,
+                                        int in_color_range, int overlay_pix_fmt );
     hb_buffer_t *      (* work)       ( hb_blend_object_t *,
-                                        hb_buffer_t *, hb_buffer_list_t * );
+                                        hb_buffer_t *, hb_buffer_list_t *,
+                                        int changed );
     void               (* close)      ( hb_blend_object_t * );
 
     hb_blend_private_t * private_data;
diff -Naupr a/libhb/handbrake/compat.h b/libhb/handbrake/compat.h
--- a/libhb/handbrake/compat.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/compat.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* compat.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/decavsub.h b/libhb/handbrake/decavsub.h
--- a/libhb/handbrake/decavsub.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/decavsub.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* decavsub.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -12,11 +12,11 @@
 
 #include "handbrake/handbrake.h"
 
-typedef struct hb_avsub_context_s hb_avsub_context_t;
+typedef struct hb_decavsub_context_s hb_decavsub_context_t;
 
-hb_avsub_context_t * decavsubInit( hb_work_object_t * w, hb_job_t * job );
-int                  decavsubWork( hb_avsub_context_t * ctx,
+hb_decavsub_context_t * decavsubInit( hb_work_object_t * w, hb_job_t * job );
+int                     decavsubWork( hb_decavsub_context_t * ctx,
                                    hb_buffer_t ** in, hb_buffer_t ** out );
-void                 decavsubClose( hb_avsub_context_t * ctx );
+void                    decavsubClose( hb_decavsub_context_t * ctx );
 
 #endif // HANDBRAKE_DECAVSUB_H
diff -Naupr a/libhb/handbrake/decomb.h b/libhb/handbrake/decomb.h
--- a/libhb/handbrake/decomb.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/decomb.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* decomb.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/dovi_common.h b/libhb/handbrake/dovi_common.h
--- a/libhb/handbrake/dovi_common.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/dovi_common.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* dovi_common.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/dvd.h b/libhb/handbrake/dvd.h
--- a/libhb/handbrake/dvd.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/dvd.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* dvd.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/eedi2.h b/libhb/handbrake/eedi2.h
--- a/libhb/handbrake/eedi2.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/eedi2.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* eedi2.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/encavsub.h b/libhb/handbrake/encavsub.h
--- a/libhb/handbrake/encavsub.h	1970-01-01 01:00:00.000000000 +0100
+++ b/libhb/handbrake/encavsub.h	2025-03-31 11:55:35.242884415 +0200
@@ -0,0 +1,22 @@
+/* encavsub.h
+
+   Copyright (c) 2003-2025 HandBrake Team
+   This file is part of the HandBrake source code
+   Homepage: <http://handbrake.fr/>.
+   It may be used under the terms of the GNU General Public License v2.
+   For full terms see the file COPYING file or visit http://www.gnu.org/licenses/gpl-2.0.html
+ */
+
+#ifndef HANDBRAKE_ENCAVSUB_H
+#define HANDBRAKE_ENCAVSUB_H
+
+#include "handbrake/handbrake.h"
+
+typedef struct hb_encavsub_context_s hb_encavsub_context_t;
+
+hb_encavsub_context_t * encavsubInit( hb_work_object_t * w, hb_job_t * job );
+int                     encavsubWork( hb_encavsub_context_t * ctx,
+                                      hb_buffer_t ** in, hb_buffer_t ** out );
+void                    encavsubClose( hb_encavsub_context_t * ctx );
+
+#endif // HANDBRAKE_ENCAVSUB_H
diff -Naupr a/libhb/handbrake/encx264.h b/libhb/handbrake/encx264.h
--- a/libhb/handbrake/encx264.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/encx264.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* encx264.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/extradata.h b/libhb/handbrake/extradata.h
--- a/libhb/handbrake/extradata.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/extradata.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* extradata.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -19,9 +19,6 @@ int hb_set_extradata(hb_data_t **extrada
 int hb_set_h264_extradata(hb_data_t **extradata, uint8_t *sps, size_t sps_length, uint8_t *pps, size_t pps_length);
 int hb_set_xiph_extradata(hb_data_t **extradata, uint8_t headers[3][HB_CONFIG_MAX_SIZE]);
 
-int hb_set_text_extradata(hb_data_t **extradata, const uint8_t *bytes, size_t length);
-int hb_set_ssa_extradata(hb_data_t **extradata, const char *font, int fs, int w, int h);
-
 int hb_parse_av1_extradata(hb_data_t *extradata, int *level_idx, int *high_tier);
 int hb_parse_h265_extradata(hb_data_t *extradata, int *level_idc, int *high_tier);
 
diff -Naupr a/libhb/handbrake/h264_common.h b/libhb/handbrake/h264_common.h
--- a/libhb/handbrake/h264_common.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/h264_common.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* h264_common.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -10,6 +10,8 @@
 #ifndef HANDBRAKE_H264_COMMON_H
 #define HANDBRAKE_H264_COMMON_H
 
+static const char * const hb_x264_tune_names[]          = {
+    "none", "film", "animation", "grain", "stillimage", "psnr", "ssim", "fastdecode", "zerolatency", NULL };
 static const char * const hb_h264_profile_names_8bit[]  = {
     "auto", "baseline", "main", "high", NULL, };
 static const char * const hb_x264_profile_names_8bit[] = {
diff -Naupr a/libhb/handbrake/h265_common.h b/libhb/handbrake/h265_common.h
--- a/libhb/handbrake/h265_common.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/h265_common.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* h265_common.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -17,6 +17,8 @@
 // in HEVC, all "random access point" NAL units are keyframes
 #define HB_HEVC_NALU_KEYFRAME(nal_unit_type) (((nal_unit_type) >= 16) && ((nal_unit_type) <= 23))
 
+static const char * const hb_x265_tune_names[]              = {
+    "none", "psnr", "ssim", "grain", "zerolatency", "fastdecode", "animation", NULL };
 static const char * const hb_h265_tier_names[]              = {
     "auto", "main", "high", NULL, };
 static const char * const hb_h265_profile_names_8bit[]      = {
diff -Naupr a/libhb/handbrake/handbrake.h b/libhb/handbrake/handbrake.h
--- a/libhb/handbrake/handbrake.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/handbrake.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* handbrake.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -63,6 +63,10 @@ hb_list_t   * hb_get_titles( hb_handle_t
    by the latest scan and title set data. */
 hb_title_set_t   * hb_get_title_set( hb_handle_t * );
 
+/* hb_get_title_coverart
+   returns the list of coverart files and byte data in hb_coverart_s */
+hb_list_t * hb_get_title_coverarts( hb_handle_t * h, int title );
+
 #ifdef __LIBHB__
 /* hb_detect_comb()
    Analyze a frame for interlacing artifacts, returns true if they're found.
@@ -76,6 +80,8 @@ hb_buffer_t * hb_read_preview( hb_handle
                                int preview, int format );
 #endif // __LIBHB__
 
+hb_image_t  * hb_get_preview(hb_handle_t * h, hb_dict_t * job_dict,
+                             int picture, int rescale, int pix_fmt);
 hb_image_t  * hb_get_preview3(hb_handle_t * h, int picture,
                               hb_dict_t * job_dict);
 void          hb_rotate_geometry( hb_geometry_crop_t * geo,
diff -Naupr a/libhb/handbrake/hb_dict.h b/libhb/handbrake/hb_dict.h
--- a/libhb/handbrake/hb_dict.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/hb_dict.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* hb_dict.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/hb_json.h b/libhb/handbrake/hb_json.h
--- a/libhb/handbrake/hb_json.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/hb_json.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* hb_json.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/hbavfilter.h b/libhb/handbrake/hbavfilter.h
--- a/libhb/handbrake/hbavfilter.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/hbavfilter.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* hbavfilter.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/hbffmpeg.h b/libhb/handbrake/hbffmpeg.h
--- a/libhb/handbrake/hbffmpeg.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/hbffmpeg.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* hbffmpeg.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/hbtypes.h b/libhb/handbrake/hbtypes.h
--- a/libhb/handbrake/hbtypes.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/hbtypes.h	2025-03-31 11:55:35.242884415 +0200
@@ -1,6 +1,6 @@
 /* hbtypes.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/hdr10plus.h b/libhb/handbrake/hdr10plus.h
--- a/libhb/handbrake/hdr10plus.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/hdr10plus.h	2025-03-31 11:55:35.243884397 +0200
@@ -1,6 +1,6 @@
 /* hdr10plus.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/hwaccel.h b/libhb/handbrake/hwaccel.h
--- a/libhb/handbrake/hwaccel.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/hwaccel.h	2025-03-31 11:55:35.243884397 +0200
@@ -1,6 +1,6 @@
 /* hwaccel.h
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code.
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
@@ -16,7 +16,7 @@ int hb_directx_available();
 
 enum AVPixelFormat hw_hwaccel_get_hw_format(AVCodecContext *ctx, const enum AVPixelFormat *pix_fmts);
 
-int hb_hwaccel_hw_ctx_init(int codec_id, int hw_decode, void **hw_device_ctx);
+int hb_hwaccel_hw_ctx_init(int codec_id, int hw_decode, void **hw_device_ctx, hb_job_t *job);
 void hb_hwaccel_hw_ctx_close(void **hw_device_ctx);
 
 int hb_hwaccel_hwframes_ctx_init(struct AVCodecContext *ctx, hb_job_t *job);
@@ -24,7 +24,8 @@ AVBufferRef *hb_hwaccel_init_hw_frames_c
                                        enum AVPixelFormat sw_fmt,
                                        enum AVPixelFormat hw_fmt,
                                        int width,
-                                       int height);
+                                       int height,
+                                       int initial_pool_size);
 int hb_hwaccel_hwframe_init(hb_job_t *job, struct AVFrame **frame);
 hb_buffer_t * hb_hwaccel_copy_video_buffer_to_hw_video_buffer(hb_job_t *job, hb_buffer_t **buf);
 
diff -Naupr a/libhb/handbrake/internal.h b/libhb/handbrake/internal.h
--- a/libhb/handbrake/internal.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/internal.h	2025-03-31 11:55:35.243884397 +0200
@@ -1,6 +1,6 @@
 /* internal.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -397,16 +397,17 @@ hb_data_t * hb_data_dup(const hb_data_t
 enum
 {
     WORK_NONE = 0,
+    WORK_PASS,
     WORK_SYNC_VIDEO,
     WORK_SYNC_AUDIO,
     WORK_SYNC_SUBTITLE,
     WORK_DECVOBSUB,
     WORK_DECSRTSUB,
     WORK_DECTX3GSUB,
+    WORK_ENCTX3GSUB,
     WORK_DECSSASUB,
     WORK_RENDER,
     WORK_ENCAVCODEC,
-    WORK_ENCQSV,
     WORK_ENCVT,
     WORK_ENCX264,
     WORK_ENCX265,
@@ -422,7 +423,8 @@ enum
     WORK_ENCAVCODEC_AUDIO,
     WORK_MUX,
     WORK_READER,
-    WORK_DECAVSUB
+    WORK_DECAVSUB,
+    WORK_ENCAVSUB
 };
 
 extern hb_filter_object_t hb_filter_detelecine;
@@ -463,12 +465,13 @@ extern hb_filter_object_t hb_filter_unsh
 #endif
 
 extern hb_motion_metric_object_t hb_motion_metric;
+extern hb_blend_object_t hb_blend;
 
 #if defined(__APPLE__)
 extern hb_motion_metric_object_t hb_motion_metric_vt;
+extern hb_blend_object_t hb_blend_vt;
 #endif
 
-extern hb_blend_object_t hb_blend;
 
 extern hb_work_object_t * hb_objects;
 
diff -Naupr a/libhb/handbrake/lang.h b/libhb/handbrake/lang.h
--- a/libhb/handbrake/lang.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/lang.h	2025-03-31 11:55:35.243884397 +0200
@@ -1,6 +1,6 @@
 /* lang.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/mf_common.h b/libhb/handbrake/mf_common.h
--- a/libhb/handbrake/mf_common.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/mf_common.h	2025-03-31 11:55:35.243884397 +0200
@@ -1,7 +1,7 @@
 /* mf_common.h
  *
  * Copyright (c) Dash Santosh <dash.sathyanarayanan@multicorewareinc.com>
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code.
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/nal_units.h b/libhb/handbrake/nal_units.h
--- a/libhb/handbrake/nal_units.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/nal_units.h	2025-03-31 11:55:35.243884397 +0200
@@ -1,6 +1,6 @@
 /* nal_units.h
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code.
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
@@ -133,6 +133,10 @@ typedef struct hb_sei_s
     hb_sei_type_t  type;
     size_t         payload_size;
     const uint8_t *payload;
+
+    // Internal fields
+    size_t  nalu_size;
+    uint8_t written;
 } hb_sei_t;
 
 /*
@@ -141,7 +145,7 @@ typedef struct hb_sei_s
  */
 hb_buffer_t * hb_isomp4_hevc_nal_bitstream_insert_payloads(const uint8_t *data,
                                                            const size_t size,
-                                                           const hb_sei_t *sei,
+                                                                 hb_sei_t *sei,
                                                            const size_t sei_count,
                                                            const hb_nal_t *nals,
                                                            const size_t nal_count,
diff -Naupr a/libhb/handbrake/nlmeans.h b/libhb/handbrake/nlmeans.h
--- a/libhb/handbrake/nlmeans.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/nlmeans.h	2025-03-31 11:55:35.243884397 +0200
@@ -1,7 +1,7 @@
 /* nlmeans.h
 
    Copyright (c) 2013 Dirk Farin
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/nvenc_common.h b/libhb/handbrake/nvenc_common.h
--- a/libhb/handbrake/nvenc_common.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/nvenc_common.h	2025-03-31 11:55:35.243884397 +0200
@@ -1,6 +1,6 @@
 /* nvenc_common.h
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code.
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/param.h b/libhb/handbrake/param.h
--- a/libhb/handbrake/param.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/param.h	2025-03-31 11:55:35.243884397 +0200
@@ -1,6 +1,6 @@
 /* param.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/ports.h b/libhb/handbrake/ports.h
--- a/libhb/handbrake/ports.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/ports.h	2025-03-31 11:55:35.243884397 +0200
@@ -1,6 +1,6 @@
 /* ports.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -212,6 +212,11 @@ int        hb_net_recv( hb_net_t *, char
 void       hb_net_close( hb_net_t ** );
 
 /************************************************************************
+* OS Backup Include / Exclude
+***********************************************************************/
+void hb_system_backup_set_excluded(const char *path, int exclude);
+
+/************************************************************************
 * OS Sleep Allow / Prevent
 ***********************************************************************/
 void* hb_system_sleep_opaque_init();
diff -Naupr a/libhb/handbrake/preset.h b/libhb/handbrake/preset.h
--- a/libhb/handbrake/preset.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/preset.h	2025-03-31 11:55:35.243884397 +0200
@@ -1,6 +1,6 @@
 /* preset.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/preset_builtin.h b/libhb/handbrake/preset_builtin.h
--- a/libhb/handbrake/preset_builtin.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/preset_builtin.h	2025-03-31 11:55:35.244884380 +0200
@@ -98,14 +98,15 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoGrayScale\": false,\n"
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
-"                    \"VideoOptionExtra\": \"\",\n"
-"                    \"VideoPreset\": \"9\",\n"
+"                    \"VideoOptionExtra\": \"enable-variance-boost=1\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
+"                    \"VideoPreset\": \"8\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
 "                    \"VideoQualitySlider\": 35.0,\n"
 "                    \"VideoQualityType\": 2,\n"
 "                    \"VideoScaler\": \"swscale\",\n"
-"                    \"VideoTune\": \"\",\n"
+"                    \"VideoTune\": \"vq\",\n"
 "                    \"VideoTurboMultiPass\": true,\n"
 "                    \"x264Option\": \"\",\n"
 "                    \"x264UseAdvancedOptions\": false\n"
@@ -206,6 +207,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"strong-intra-smoothing=0:rect=0:aq-mode=1:rd=4:psy-rd=0.75:psy-rdoq=4.0:rdoq-level=1:rskip=2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"superfast\",\n"
 "                    \"VideoProfile\": \"main10\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -312,6 +314,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.0\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"veryfast\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -418,6 +421,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"veryfast\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -524,6 +528,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"veryfast\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -630,6 +635,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"veryfast\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -736,14 +742,15 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoGrayScale\": false,\n"
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
-"                    \"VideoOptionExtra\": \"\",\n"
-"                    \"VideoPreset\": \"8\",\n"
+"                    \"VideoOptionExtra\": \"enable-variance-boost=1\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
+"                    \"VideoPreset\": \"7\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
 "                    \"VideoQualitySlider\": 30.0,\n"
 "                    \"VideoQualityType\": 2,\n"
 "                    \"VideoScaler\": \"swscale\",\n"
-"                    \"VideoTune\": \"\",\n"
+"                    \"VideoTune\": \"vq\",\n"
 "                    \"VideoTurboMultiPass\": true,\n"
 "                    \"x264Option\": \"\",\n"
 "                    \"x264UseAdvancedOptions\": false\n"
@@ -844,6 +851,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"strong-intra-smoothing=0:rect=0:aq-mode=1:rd=4:psy-rd=0.75:psy-rdoq=4.0:rdoq-level=1:rskip=2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"faster\",\n"
 "                    \"VideoProfile\": \"main10\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -950,6 +958,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.0\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"fast\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -1056,6 +1065,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"fast\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -1162,6 +1172,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"fast\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -1268,6 +1279,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"fast\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -1387,14 +1399,15 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoGrayScale\": false,\n"
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
-"                    \"VideoOptionExtra\": \"\",\n"
-"                    \"VideoPreset\": \"7\",\n"
+"                    \"VideoOptionExtra\": \"enable-variance-boost=1\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
+"                    \"VideoPreset\": \"6\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
 "                    \"VideoQualitySlider\": 25.0,\n"
 "                    \"VideoQualityType\": 2,\n"
 "                    \"VideoScaler\": \"swscale\",\n"
-"                    \"VideoTune\": \"\",\n"
+"                    \"VideoTune\": \"vq\",\n"
 "                    \"VideoTurboMultiPass\": false,\n"
 "                    \"x264Option\": \"\",\n"
 "                    \"x264UseAdvancedOptions\": false\n"
@@ -1508,6 +1521,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"strong-intra-smoothing=0:rect=0:aq-mode=1:rd=4:psy-rd=0.75:psy-rdoq=4.0:rdoq-level=1:rskip=2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main10\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -1628,6 +1642,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.0\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"slow\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -1748,6 +1763,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"slow\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -1868,6 +1884,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"slow\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -1988,6 +2005,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"slow\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -2108,14 +2126,15 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoGrayScale\": false,\n"
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
-"                    \"VideoOptionExtra\": \"\",\n"
-"                    \"VideoPreset\": \"5\",\n"
+"                    \"VideoOptionExtra\": \"enable-variance-boost=1\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
+"                    \"VideoPreset\": \"4\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
 "                    \"VideoQualitySlider\": 20.0,\n"
 "                    \"VideoQualityType\": 2,\n"
 "                    \"VideoScaler\": \"swscale\",\n"
-"                    \"VideoTune\": \"\",\n"
+"                    \"VideoTune\": \"vq\",\n"
 "                    \"VideoTurboMultiPass\": false,\n"
 "                    \"x264Option\": \"\",\n"
 "                    \"x264UseAdvancedOptions\": false\n"
@@ -2230,6 +2249,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"strong-intra-smoothing=0:rect=0:aq-mode=1:rd=4:psy-rd=0.75:psy-rdoq=4.0:rdoq-level=1:rskip=2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"slow\",\n"
 "                    \"VideoProfile\": \"main10\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -2350,6 +2370,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.0\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"ref=5:bframes=5\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"veryslow\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -2470,6 +2491,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"ref=5:bframes=5\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"veryslow\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -2590,6 +2612,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"ref=5:bframes=5\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"veryslow\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -2710,6 +2733,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"ref=5:bframes=5\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"veryslow\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -2823,6 +2847,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"5.2\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"keyint=30:min-keyint=15:ref=1:bframes=2:b-pyramid=none\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -2929,6 +2954,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"5.2\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"keyint=30:min-keyint=15:ref=1:bframes=2:b-pyramid=none\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -3035,6 +3061,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.2\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"keyint=30:min-keyint=15:ref=1:bframes=2:b-pyramid=none\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -3141,6 +3168,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.2\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"keyint=30:min-keyint=15:ref=1:bframes=2:b-pyramid=none\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -3247,6 +3275,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.2\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"qcomp=0.5:aq-mode=2:aq-strength=0.8:bframes=2:b-adapt=2:b-pyramid=0\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -3353,6 +3382,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.2\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"qcomp=0.5:aq-mode=2:aq-strength=0.8:bframes=2:b-adapt=2:b-pyramid=0\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -3459,6 +3489,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.2\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"qcomp=0.5:aq-mode=2:aq-strength=0.8:bframes=2:b-adapt=2:b-pyramid=0\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -3565,6 +3596,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.2\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"qcomp=0.5:aq-mode=2:aq-strength=0.8:bframes=2:b-adapt=2:b-pyramid=0\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -3575,6 +3607,327 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoTurboMultiPass\": true,\n"
 "                    \"x264Option\": \"\",\n"
 "                    \"x264UseAdvancedOptions\": false\n"
+"                },\n"
+"                {\n"
+"                    \"AlignAVStart\": true,\n"
+"                    \"AudioCopyMask\": [\n"
+"                        \"copy:aac\"\n"
+"                    ],\n"
+"                    \"AudioEncoderFallback\": \"aac\",\n"
+"                    \"AudioLanguageList\": [],\n"
+"                    \"AudioList\": [\n"
+"                        {\n"
+"                            \"AudioBitrate\": 160,\n"
+"                            \"AudioCompressionLevel\": -1.0,\n"
+"                            \"AudioDitherMethod\": \"auto\",\n"
+"                            \"AudioEncoder\": \"aac\",\n"
+"                            \"AudioMixdown\": \"stereo\",\n"
+"                            \"AudioNormalizeMixLevel\": false,\n"
+"                            \"AudioSamplerate\": \"auto\",\n"
+"                            \"AudioTrackDRCSlider\": 0.0,\n"
+"                            \"AudioTrackGainSlider\": 0.0,\n"
+"                            \"AudioTrackQuality\": -1.0,\n"
+"                            \"AudioTrackQualityEnable\": false\n"
+"                        }\n"
+"                    ],\n"
+"                    \"AudioSecondaryEncoderMode\": true,\n"
+"                    \"AudioTrackSelectionBehavior\": \"first\",\n"
+"                    \"ChapterMarkers\": true,\n"
+"                    \"ChildrenArray\": [],\n"
+"                    \"Default\": false,\n"
+"                    \"FileFormat\": \"mp4\",\n"
+"                    \"Folder\": false,\n"
+"                    \"FolderOpen\": false,\n"
+"                    \"InlineParameterSets\": false,\n"
+"                    \"Mp4iPodCompatible\": false,\n"
+"                    \"Optimize\": true,\n"
+"                    \"PictureBottomCrop\": 0,\n"
+"                    \"PictureChromaSmoothCustom\": \"\",\n"
+"                    \"PictureChromaSmoothPreset\": \"off\",\n"
+"                    \"PictureChromaSmoothTune\": \"none\",\n"
+"                    \"PictureColorspaceCustom\": \"\",\n"
+"                    \"PictureColorspacePreset\": \"off\",\n"
+"                    \"PictureCombDetectCustom\": \"\",\n"
+"                    \"PictureCombDetectPreset\": \"off\",\n"
+"                    \"PictureCropMode\": 0,\n"
+"                    \"PictureDARWidth\": 0,\n"
+"                    \"PictureDeblockCustom\": \"strength=strong:thresh=20:blocksize=8\",\n"
+"                    \"PictureDeblockPreset\": \"off\",\n"
+"                    \"PictureDeblockTune\": \"medium\",\n"
+"                    \"PictureDeinterlaceCustom\": \"\",\n"
+"                    \"PictureDeinterlaceFilter\": \"off\",\n"
+"                    \"PictureDeinterlacePreset\": \"default\",\n"
+"                    \"PictureDenoiseCustom\": \"\",\n"
+"                    \"PictureDenoiseFilter\": \"off\",\n"
+"                    \"PictureDenoisePreset\": \"medium\",\n"
+"                    \"PictureDenoiseTune\": \"none\",\n"
+"                    \"PictureDetelecine\": \"off\",\n"
+"                    \"PictureDetelecineCustom\": \"\",\n"
+"                    \"PictureForceHeight\": 0,\n"
+"                    \"PictureForceWidth\": 0,\n"
+"                    \"PictureHeight\": 720,\n"
+"                    \"PictureItuPAR\": false,\n"
+"                    \"PictureKeepRatio\": true,\n"
+"                    \"PictureLeftCrop\": 0,\n"
+"                    \"PictureModulus\": 2,\n"
+"                    \"PicturePAR\": \"auto\",\n"
+"                    \"PicturePARHeight\": 720,\n"
+"                    \"PicturePARWidth\": 853,\n"
+"                    \"PictureRightCrop\": 0,\n"
+"                    \"PictureRotate\": \"angle=0:hflip=0\",\n"
+"                    \"PictureSharpenCustom\": \"\",\n"
+"                    \"PictureSharpenFilter\": \"off\",\n"
+"                    \"PictureSharpenPreset\": \"medium\",\n"
+"                    \"PictureSharpenTune\": \"none\",\n"
+"                    \"PictureTopCrop\": 0,\n"
+"                    \"PictureWidth\": 1280,\n"
+"                    \"PresetDescription\": \"Up to 30 seconds of video in 10 MB or less, for sharing via online social communities such as Discord and email services such as Gmail. H.264 video (up to 720p60) and AAC stereo audio, in an MP4 container.\",\n"
+"                    \"PresetName\": \"Social 10 MB 30 Seconds 720p60\",\n"
+"                    \"SubtitleAddCC\": false,\n"
+"                    \"SubtitleAddForeignAudioSearch\": true,\n"
+"                    \"SubtitleAddForeignAudioSubtitle\": false,\n"
+"                    \"SubtitleBurnBDSub\": true,\n"
+"                    \"SubtitleBurnBehavior\": \"foreign\",\n"
+"                    \"SubtitleBurnDVDSub\": true,\n"
+"                    \"SubtitleLanguageList\": [],\n"
+"                    \"SubtitleTrackSelectionBehavior\": \"none\",\n"
+"                    \"Type\": 0,\n"
+"                    \"UsesPictureFilters\": true,\n"
+"                    \"UsesPictureSettings\": 1,\n"
+"                    \"VideoAvgBitrate\": 2250,\n"
+"                    \"VideoColorMatrixCodeOverride\": 0,\n"
+"                    \"VideoEncoder\": \"x264\",\n"
+"                    \"VideoFramerate\": \"60\",\n"
+"                    \"VideoFramerateMode\": \"pfr\",\n"
+"                    \"VideoGrayScale\": false,\n"
+"                    \"VideoLevel\": \"3.2\",\n"
+"                    \"VideoMultiPass\": true,\n"
+"                    \"VideoOptionExtra\": \"qcomp=0.5:aq-mode=2:aq-strength=0.8:bframes=2:b-adapt=2:b-pyramid=0\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
+"                    \"VideoPreset\": \"slow\",\n"
+"                    \"VideoProfile\": \"high\",\n"
+"                    \"VideoQSVDecode\": false,\n"
+"                    \"VideoQualitySlider\": 27.0,\n"
+"                    \"VideoQualityType\": 1,\n"
+"                    \"VideoScaler\": \"swscale\",\n"
+"                    \"VideoTune\": \"\",\n"
+"                    \"VideoTurboMultiPass\": true,\n"
+"                    \"x264Option\": \"\",\n"
+"                    \"x264UseAdvancedOptions\": false\n"
+"                },\n"
+"                {\n"
+"                    \"AlignAVStart\": true,\n"
+"                    \"AudioCopyMask\": [\n"
+"                        \"copy:aac\"\n"
+"                    ],\n"
+"                    \"AudioEncoderFallback\": \"aac\",\n"
+"                    \"AudioLanguageList\": [],\n"
+"                    \"AudioList\": [\n"
+"                        {\n"
+"                            \"AudioBitrate\": 160,\n"
+"                            \"AudioCompressionLevel\": -1.0,\n"
+"                            \"AudioDitherMethod\": \"auto\",\n"
+"                            \"AudioEncoder\": \"aac\",\n"
+"                            \"AudioMixdown\": \"stereo\",\n"
+"                            \"AudioNormalizeMixLevel\": false,\n"
+"                            \"AudioSamplerate\": \"auto\",\n"
+"                            \"AudioTrackDRCSlider\": 0.0,\n"
+"                            \"AudioTrackGainSlider\": 0.0,\n"
+"                            \"AudioTrackQuality\": -1.0,\n"
+"                            \"AudioTrackQualityEnable\": false\n"
+"                        }\n"
+"                    ],\n"
+"                    \"AudioSecondaryEncoderMode\": true,\n"
+"                    \"AudioTrackSelectionBehavior\": \"first\",\n"
+"                    \"ChapterMarkers\": true,\n"
+"                    \"ChildrenArray\": [],\n"
+"                    \"Default\": false,\n"
+"                    \"FileFormat\": \"mp4\",\n"
+"                    \"Folder\": false,\n"
+"                    \"FolderOpen\": false,\n"
+"                    \"InlineParameterSets\": false,\n"
+"                    \"Mp4iPodCompatible\": false,\n"
+"                    \"Optimize\": true,\n"
+"                    \"PictureBottomCrop\": 0,\n"
+"                    \"PictureChromaSmoothCustom\": \"\",\n"
+"                    \"PictureChromaSmoothPreset\": \"off\",\n"
+"                    \"PictureChromaSmoothTune\": \"none\",\n"
+"                    \"PictureColorspaceCustom\": \"\",\n"
+"                    \"PictureColorspacePreset\": \"off\",\n"
+"                    \"PictureCombDetectCustom\": \"\",\n"
+"                    \"PictureCombDetectPreset\": \"off\",\n"
+"                    \"PictureCropMode\": 0,\n"
+"                    \"PictureDARWidth\": 0,\n"
+"                    \"PictureDeblockCustom\": \"strength=strong:thresh=20:blocksize=8\",\n"
+"                    \"PictureDeblockPreset\": \"off\",\n"
+"                    \"PictureDeblockTune\": \"medium\",\n"
+"                    \"PictureDeinterlaceCustom\": \"\",\n"
+"                    \"PictureDeinterlaceFilter\": \"off\",\n"
+"                    \"PictureDeinterlacePreset\": \"default\",\n"
+"                    \"PictureDenoiseCustom\": \"\",\n"
+"                    \"PictureDenoiseFilter\": \"off\",\n"
+"                    \"PictureDenoisePreset\": \"medium\",\n"
+"                    \"PictureDenoiseTune\": \"none\",\n"
+"                    \"PictureDetelecine\": \"off\",\n"
+"                    \"PictureDetelecineCustom\": \"\",\n"
+"                    \"PictureForceHeight\": 0,\n"
+"                    \"PictureForceWidth\": 0,\n"
+"                    \"PictureHeight\": 540,\n"
+"                    \"PictureItuPAR\": false,\n"
+"                    \"PictureKeepRatio\": true,\n"
+"                    \"PictureLeftCrop\": 0,\n"
+"                    \"PictureModulus\": 2,\n"
+"                    \"PicturePAR\": \"auto\",\n"
+"                    \"PicturePARHeight\": 720,\n"
+"                    \"PicturePARWidth\": 853,\n"
+"                    \"PictureRightCrop\": 0,\n"
+"                    \"PictureRotate\": \"angle=0:hflip=0\",\n"
+"                    \"PictureSharpenCustom\": \"\",\n"
+"                    \"PictureSharpenFilter\": \"off\",\n"
+"                    \"PictureSharpenPreset\": \"medium\",\n"
+"                    \"PictureSharpenTune\": \"none\",\n"
+"                    \"PictureTopCrop\": 0,\n"
+"                    \"PictureWidth\": 960,\n"
+"                    \"PresetDescription\": \"Up to 1 minute of video in 10 MB or less, for sharing via online social communities such as Discord and email services such as Gmail. H.264 video (up to 540p60) and AAC stereo audio, in an MP4 container.\",\n"
+"                    \"PresetName\": \"Social 10 MB 1 Minute 540p60\",\n"
+"                    \"SubtitleAddCC\": false,\n"
+"                    \"SubtitleAddForeignAudioSearch\": true,\n"
+"                    \"SubtitleAddForeignAudioSubtitle\": false,\n"
+"                    \"SubtitleBurnBDSub\": true,\n"
+"                    \"SubtitleBurnBehavior\": \"foreign\",\n"
+"                    \"SubtitleBurnDVDSub\": true,\n"
+"                    \"SubtitleLanguageList\": [],\n"
+"                    \"SubtitleTrackSelectionBehavior\": \"none\",\n"
+"                    \"Type\": 0,\n"
+"                    \"UsesPictureFilters\": true,\n"
+"                    \"UsesPictureSettings\": 1,\n"
+"                    \"VideoAvgBitrate\": 1125,\n"
+"                    \"VideoColorMatrixCodeOverride\": 0,\n"
+"                    \"VideoEncoder\": \"x264\",\n"
+"                    \"VideoFramerate\": \"60\",\n"
+"                    \"VideoFramerateMode\": \"pfr\",\n"
+"                    \"VideoGrayScale\": false,\n"
+"                    \"VideoLevel\": \"3.2\",\n"
+"                    \"VideoMultiPass\": true,\n"
+"                    \"VideoOptionExtra\": \"qcomp=0.5:aq-mode=2:aq-strength=0.8:bframes=2:b-adapt=2:b-pyramid=0\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
+"                    \"VideoPreset\": \"slow\",\n"
+"                    \"VideoProfile\": \"high\",\n"
+"                    \"VideoQSVDecode\": false,\n"
+"                    \"VideoQualitySlider\": 27.0,\n"
+"                    \"VideoQualityType\": 1,\n"
+"                    \"VideoScaler\": \"swscale\",\n"
+"                    \"VideoTune\": \"\",\n"
+"                    \"VideoTurboMultiPass\": true,\n"
+"                    \"x264Option\": \"\",\n"
+"                    \"x264UseAdvancedOptions\": false\n"
+"                },\n"
+"                {\n"
+"                    \"AlignAVStart\": true,\n"
+"                    \"AudioCopyMask\": [\n"
+"                        \"copy:aac\"\n"
+"                    ],\n"
+"                    \"AudioEncoderFallback\": \"aac\",\n"
+"                    \"AudioLanguageList\": [],\n"
+"                    \"AudioList\": [\n"
+"                        {\n"
+"                            \"AudioBitrate\": 160,\n"
+"                            \"AudioCompressionLevel\": -1.0,\n"
+"                            \"AudioDitherMethod\": \"auto\",\n"
+"                            \"AudioEncoder\": \"aac\",\n"
+"                            \"AudioMixdown\": \"stereo\",\n"
+"                            \"AudioNormalizeMixLevel\": false,\n"
+"                            \"AudioSamplerate\": \"auto\",\n"
+"                            \"AudioTrackDRCSlider\": 0.0,\n"
+"                            \"AudioTrackGainSlider\": 0.0,\n"
+"                            \"AudioTrackQuality\": -1.0,\n"
+"                            \"AudioTrackQualityEnable\": false\n"
+"                        }\n"
+"                    ],\n"
+"                    \"AudioSecondaryEncoderMode\": true,\n"
+"                    \"AudioTrackSelectionBehavior\": \"first\",\n"
+"                    \"ChapterMarkers\": true,\n"
+"                    \"ChildrenArray\": [],\n"
+"                    \"Default\": false,\n"
+"                    \"FileFormat\": \"mp4\",\n"
+"                    \"Folder\": false,\n"
+"                    \"FolderOpen\": false,\n"
+"                    \"InlineParameterSets\": false,\n"
+"                    \"Mp4iPodCompatible\": false,\n"
+"                    \"Optimize\": true,\n"
+"                    \"PictureBottomCrop\": 0,\n"
+"                    \"PictureChromaSmoothCustom\": \"\",\n"
+"                    \"PictureChromaSmoothPreset\": \"off\",\n"
+"                    \"PictureChromaSmoothTune\": \"none\",\n"
+"                    \"PictureColorspaceCustom\": \"\",\n"
+"                    \"PictureColorspacePreset\": \"off\",\n"
+"                    \"PictureCombDetectCustom\": \"\",\n"
+"                    \"PictureCombDetectPreset\": \"off\",\n"
+"                    \"PictureCropMode\": 0,\n"
+"                    \"PictureDARWidth\": 0,\n"
+"                    \"PictureDeblockCustom\": \"strength=strong:thresh=20:blocksize=8\",\n"
+"                    \"PictureDeblockPreset\": \"off\",\n"
+"                    \"PictureDeblockTune\": \"medium\",\n"
+"                    \"PictureDeinterlaceCustom\": \"\",\n"
+"                    \"PictureDeinterlaceFilter\": \"off\",\n"
+"                    \"PictureDeinterlacePreset\": \"default\",\n"
+"                    \"PictureDenoiseCustom\": \"\",\n"
+"                    \"PictureDenoiseFilter\": \"off\",\n"
+"                    \"PictureDenoisePreset\": \"medium\",\n"
+"                    \"PictureDenoiseTune\": \"none\",\n"
+"                    \"PictureDetelecine\": \"off\",\n"
+"                    \"PictureDetelecineCustom\": \"\",\n"
+"                    \"PictureForceHeight\": 0,\n"
+"                    \"PictureForceWidth\": 0,\n"
+"                    \"PictureHeight\": 360,\n"
+"                    \"PictureItuPAR\": false,\n"
+"                    \"PictureKeepRatio\": true,\n"
+"                    \"PictureLeftCrop\": 0,\n"
+"                    \"PictureModulus\": 2,\n"
+"                    \"PicturePAR\": \"auto\",\n"
+"                    \"PicturePARHeight\": 720,\n"
+"                    \"PicturePARWidth\": 853,\n"
+"                    \"PictureRightCrop\": 0,\n"
+"                    \"PictureRotate\": \"angle=0:hflip=0\",\n"
+"                    \"PictureSharpenCustom\": \"\",\n"
+"                    \"PictureSharpenFilter\": \"off\",\n"
+"                    \"PictureSharpenPreset\": \"medium\",\n"
+"                    \"PictureSharpenTune\": \"none\",\n"
+"                    \"PictureTopCrop\": 0,\n"
+"                    \"PictureWidth\": 640,\n"
+"                    \"PresetDescription\": \"Up to 2 minutes of video in 10 MB or less, for sharing via online social communities such as Discord and email services such as Gmail. H.264 video (up to 360p60) and AAC stereo audio, in an MP4 container.\",\n"
+"                    \"PresetName\": \"Social 10 MB 2 Minutes 360p60\",\n"
+"                    \"SubtitleAddCC\": false,\n"
+"                    \"SubtitleAddForeignAudioSearch\": true,\n"
+"                    \"SubtitleAddForeignAudioSubtitle\": false,\n"
+"                    \"SubtitleBurnBDSub\": true,\n"
+"                    \"SubtitleBurnBehavior\": \"foreign\",\n"
+"                    \"SubtitleBurnDVDSub\": true,\n"
+"                    \"SubtitleLanguageList\": [],\n"
+"                    \"SubtitleTrackSelectionBehavior\": \"none\",\n"
+"                    \"Type\": 0,\n"
+"                    \"UsesPictureFilters\": true,\n"
+"                    \"UsesPictureSettings\": 1,\n"
+"                    \"VideoAvgBitrate\": 500,\n"
+"                    \"VideoColorMatrixCodeOverride\": 0,\n"
+"                    \"VideoEncoder\": \"x264\",\n"
+"                    \"VideoFramerate\": \"60\",\n"
+"                    \"VideoFramerateMode\": \"pfr\",\n"
+"                    \"VideoGrayScale\": false,\n"
+"                    \"VideoLevel\": \"3.2\",\n"
+"                    \"VideoMultiPass\": true,\n"
+"                    \"VideoOptionExtra\": \"qcomp=0.5:aq-mode=2:aq-strength=0.8:bframes=2:b-adapt=2:b-pyramid=0\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
+"                    \"VideoPreset\": \"slow\",\n"
+"                    \"VideoProfile\": \"high\",\n"
+"                    \"VideoQSVDecode\": false,\n"
+"                    \"VideoQualitySlider\": 27.0,\n"
+"                    \"VideoQualityType\": 1,\n"
+"                    \"VideoScaler\": \"swscale\",\n"
+"                    \"VideoTune\": \"\",\n"
+"                    \"VideoTurboMultiPass\": true,\n"
+"                    \"x264Option\": \"\",\n"
+"                    \"x264UseAdvancedOptions\": false\n"
 "                }\n"
 "            ],\n"
 "            \"Folder\": true,\n"
@@ -3692,6 +4045,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"strong-intra-smoothing=0:rect=0:aq-mode=1:rd=4:psy-rd=0.75:psy-rdoq=4.0:rdoq-level=1:rskip=2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"slow\",\n"
 "                    \"VideoProfile\": \"main10\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -3812,6 +4166,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.0\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -3918,6 +4273,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -4024,6 +4380,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.0\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -4130,6 +4487,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -4236,6 +4594,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.0\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -4342,6 +4701,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.0\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -4462,6 +4822,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"strong-intra-smoothing=0:rect=0:aq-mode=1:rd=4:psy-rd=0.75:psy-rdoq=4.0:rdoq-level=1:rskip=2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"slow\",\n"
 "                    \"VideoProfile\": \"main10\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -4582,6 +4943,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.2\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -4702,6 +5064,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.0\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -4822,6 +5185,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -4942,6 +5306,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"qpmin=4:cabac=0:ref=2:b-pyramid=none:weightb=0:weightp=0:vbv-maxrate=9500:vbv-bufsize=9500\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -5062,6 +5427,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"strong-intra-smoothing=0:rect=0:aq-mode=1:rd=4:psy-rd=0.75:psy-rdoq=4.0:rdoq-level=1:rskip=2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"slow\",\n"
 "                    \"VideoProfile\": \"main10\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -5182,6 +5548,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.2\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -5302,6 +5669,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.0\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -5422,6 +5790,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"5.2\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -5542,6 +5911,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.0\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -5648,6 +6018,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -5754,6 +6125,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -5877,6 +6249,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"strong-intra-smoothing=0:rect=0:aq-mode=1:rd=4:psy-rd=0.75:psy-rdoq=4.0:rdoq-level=1:rskip=2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"slow\",\n"
 "                    \"VideoProfile\": \"main10\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -5997,6 +6370,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.0\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -6117,6 +6491,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -6223,6 +6598,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -6329,6 +6705,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -6449,6 +6826,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.0\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -6559,14 +6937,15 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoGrayScale\": false,\n"
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
-"                    \"VideoOptionExtra\": \"\",\n"
-"                    \"VideoPreset\": \"8\",\n"
+"                    \"VideoOptionExtra\": \"enable-variance-boost=1\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
+"                    \"VideoPreset\": \"7\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
 "                    \"VideoQualitySlider\": 30.0,\n"
 "                    \"VideoQualityType\": 2,\n"
 "                    \"VideoScaler\": \"swscale\",\n"
-"                    \"VideoTune\": \"\",\n"
+"                    \"VideoTune\": \"vq\",\n"
 "                    \"VideoTurboMultiPass\": false,\n"
 "                    \"x264Option\": \"\",\n"
 "                    \"x264UseAdvancedOptions\": false\n"
@@ -6666,6 +7045,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"strong-intra-smoothing=0:rect=0:aq-mode=1:rd=4:psy-rd=0.75:psy-rdoq=4.0:rdoq-level=1:rskip=2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"slow\",\n"
 "                    \"VideoProfile\": \"main10\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -6772,6 +7152,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"strong-intra-smoothing=0:rect=0:aq-mode=1:rd=4:psy-rd=0.75:psy-rdoq=4.0:rdoq-level=1:rskip=2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"slow\",\n"
 "                    \"VideoProfile\": \"main10\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -6878,6 +7259,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"strong-intra-smoothing=0:rect=0:aq-mode=1:rd=4:psy-rd=0.75:psy-rdoq=4.0:rdoq-level=1:rskip=2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"slow\",\n"
 "                    \"VideoProfile\": \"main10\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -6984,6 +7366,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"strong-intra-smoothing=0:rect=0:aq-mode=1:rd=4:psy-rd=0.75:psy-rdoq=4.0:rdoq-level=1:rskip=2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"slow\",\n"
 "                    \"VideoProfile\": \"main10\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -7090,6 +7473,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"strong-intra-smoothing=0:rect=0:aq-mode=1:rd=4:psy-rd=0.75:psy-rdoq=4.0:rdoq-level=1:rskip=2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"slow\",\n"
 "                    \"VideoProfile\": \"main10\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -7196,6 +7580,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"5.2\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -7302,6 +7687,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"4.0\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -7408,6 +7794,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -7514,6 +7901,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -7620,6 +8008,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"3.1\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -7724,6 +8113,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"auto\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -7828,6 +8218,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"auto\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -7932,6 +8323,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"auto\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -8036,6 +8428,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"auto\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -8140,6 +8533,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"auto\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -8253,6 +8647,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": false,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"speed\",\n"
 "                    \"VideoProfile\": \"auto\",\n"
 "                    \"VideoQSVDecode\": true,\n"
@@ -8359,6 +8754,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": false,\n"
 "                    \"VideoOptionExtra\": \"rc-lookahead=10\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"auto\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -8465,6 +8861,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": false,\n"
 "                    \"VideoOptionExtra\": \"rc-lookahead=10\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"auto\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -8571,6 +8968,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": false,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"speed\",\n"
 "                    \"VideoProfile\": \"auto\",\n"
 "                    \"VideoQSVDecode\": true,\n"
@@ -8677,6 +9075,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": false,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"speed\",\n"
 "                    \"VideoProfile\": \"auto\",\n"
 "                    \"VideoQSVDecode\": true,\n"
@@ -8783,6 +9182,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": false,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"balanced\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -8889,6 +9289,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": false,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"balanced\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -8995,6 +9396,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": false,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"balanced\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -9101,6 +9503,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": false,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"balanced\",\n"
 "                    \"VideoProfile\": \"main\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -9207,6 +9610,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": false,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"speed\",\n"
 "                    \"VideoProfile\": \"auto\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -9313,6 +9717,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": false,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"speed\",\n"
 "                    \"VideoProfile\": \"auto\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -9426,6 +9831,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"keyint=12:min-keyint=1:ref=1:bframes=0:qcomp=0.8:aq-strength=0.5:dct-decimate=0:fast-pskip=0:deblock=-2,-2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"fast\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -9532,6 +9938,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"keyint=12:min-keyint=1:ref=1:bframes=0:qcomp=0.8:aq-strength=0.5:dct-decimate=0:fast-pskip=0:deblock=-2,-2\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"fast\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -9638,6 +10045,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"keyint=1:min-keyint=1:ref=1:bframes=0:qcomp=0.8:aq-strength=0.5\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"superfast\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -9744,6 +10152,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"keyint=1:min-keyint=1:ref=1:bframes=0:qcomp=0.8:aq-strength=0.5\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"superfast\",\n"
 "                    \"VideoProfile\": \"high\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -9863,6 +10272,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": true,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"preservation\",\n"
 "                    \"VideoProfile\": \"\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -9984,6 +10394,7 @@ const char hb_builtin_presets_json[] =
 "                    \"VideoLevel\": \"auto\",\n"
 "                    \"VideoMultiPass\": false,\n"
 "                    \"VideoOptionExtra\": \"\",\n"
+"                    \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "                    \"VideoPreset\": \"medium\",\n"
 "                    \"VideoProfile\": \"auto\",\n"
 "                    \"VideoQSVDecode\": false,\n"
@@ -10117,6 +10528,7 @@ const char hb_builtin_presets_json[] =
 "            \"VideoLevel\": \"auto\",\n"
 "            \"VideoMultiPass\": false,\n"
 "            \"VideoOptionExtra\": \"\",\n"
+"            \"VideoPasshtruHDRDynamicMetadata\": \"all\",\n"
 "            \"VideoPreset\": \"medium\",\n"
 "            \"VideoProfile\": \"auto\",\n"
 "            \"VideoQSVDecode\": false,\n"
@@ -10128,7 +10540,7 @@ const char hb_builtin_presets_json[] =
 "            \"x264Option\": \"\",\n"
 "            \"x264UseAdvancedOptions\": false\n"
 "        },\n"
-"        \"VersionMajor\": 59,\n"
+"        \"VersionMajor\": 64,\n"
 "        \"VersionMicro\": 0,\n"
 "        \"VersionMinor\": 0\n"
 "    }\n"
diff -Naupr a/libhb/handbrake/qsv_common.h b/libhb/handbrake/qsv_common.h
--- a/libhb/handbrake/qsv_common.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/qsv_common.h	2025-03-31 11:55:35.244884380 +0200
@@ -1,6 +1,6 @@
 /* qsv_common.h
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code.
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
@@ -25,11 +25,103 @@ int  hb_qsv_impl_set_preferred(const cha
 #include "vpl/mfxvideo.h"
 #include "handbrake/hb_dict.h"
 #include "handbrake/qsv_libav.h"
+#include "libavutil/hwcontext_qsv.h"
 
 /* Minimum Intel Media SDK version (currently 1.3, for Sandy Bridge support) */
 #define HB_QSV_MINVERSION_MAJOR HB_QSV_MSDK_VERSION_MAJOR
 #define HB_QSV_MINVERSION_MINOR HB_QSV_MSDK_VERSION_MINOR
 
+static const char * const hb_qsv_h264_level_names[] =
+{
+    "auto", "1.0", "1b", "1.1", "1.2", "1.3", "2.0", "2.1", "2.2", "3.0",
+    "3.1", "3.2", "4.0", "4.1", "4.2", "5.0", "5.1", "5.2", "6.0", "6.1", "6.2",  NULL,
+};
+
+static const int hb_qsv_h264_levels[] =
+{
+    MFX_LEVEL_UNKNOWN,
+    MFX_LEVEL_AVC_1,
+    MFX_LEVEL_AVC_1b,
+    MFX_LEVEL_AVC_11,
+    MFX_LEVEL_AVC_12,
+    MFX_LEVEL_AVC_13,
+    MFX_LEVEL_AVC_2,
+    MFX_LEVEL_AVC_21,
+    MFX_LEVEL_AVC_22,
+    MFX_LEVEL_AVC_3,
+    MFX_LEVEL_AVC_31,
+    MFX_LEVEL_AVC_32,
+    MFX_LEVEL_AVC_4,
+    MFX_LEVEL_AVC_41,
+    MFX_LEVEL_AVC_42,
+    MFX_LEVEL_AVC_5,
+    MFX_LEVEL_AVC_51,
+    MFX_LEVEL_AVC_52,
+    MFX_LEVEL_AVC_6,
+    MFX_LEVEL_AVC_61,
+    MFX_LEVEL_AVC_62,
+};
+
+static const char * const hb_qsv_h265_level_names[] =
+{
+    "auto", "1.0", "2.0", "2.1", "3.0", "3.1", "4.0", "4.1",
+    "5.0", "5.1", "5.2", "6.0", "6.1", "6.2",  NULL,
+};
+
+static const int hb_qsv_h265_levels[] =
+{
+    MFX_LEVEL_UNKNOWN,
+    MFX_LEVEL_HEVC_1,
+    MFX_LEVEL_HEVC_2,
+    MFX_LEVEL_HEVC_21,
+    MFX_LEVEL_HEVC_3,
+    MFX_LEVEL_HEVC_31,
+    MFX_LEVEL_HEVC_4,
+    MFX_LEVEL_HEVC_41,
+    MFX_LEVEL_HEVC_5,
+    MFX_LEVEL_HEVC_51,
+    MFX_LEVEL_HEVC_52,
+    MFX_LEVEL_HEVC_6,
+    MFX_LEVEL_HEVC_61,
+    MFX_LEVEL_HEVC_62
+};
+
+static const char * const hb_qsv_av1_level_names[] =
+{
+    "auto", "2.0", "2.1", "2.2", "2.3", "3.0", "3.1", "3.2",
+    "3.3", "4.0", "4.1", "4.2", "4.3", "5.0", "5.1", "5.2",
+    "5.3", "6.0", "6.1", "6.2", "6.3", "7.0", "7.1", "7.2", "7.3", NULL,
+};
+
+static const int hb_qsv_av1_levels[] =
+{
+    MFX_LEVEL_UNKNOWN,
+    MFX_LEVEL_AV1_2,
+    MFX_LEVEL_AV1_21,
+    MFX_LEVEL_AV1_22,
+    MFX_LEVEL_AV1_23,
+    MFX_LEVEL_AV1_3,
+    MFX_LEVEL_AV1_31,
+    MFX_LEVEL_AV1_32,
+    MFX_LEVEL_AV1_33,
+    MFX_LEVEL_AV1_4,
+    MFX_LEVEL_AV1_41,
+    MFX_LEVEL_AV1_42,
+    MFX_LEVEL_AV1_43,
+    MFX_LEVEL_AV1_5,
+    MFX_LEVEL_AV1_51,
+    MFX_LEVEL_AV1_52,
+    MFX_LEVEL_AV1_53,
+    MFX_LEVEL_AV1_6,
+    MFX_LEVEL_AV1_61,
+    MFX_LEVEL_AV1_62,
+    MFX_LEVEL_AV1_63,
+    MFX_LEVEL_AV1_7,
+    MFX_LEVEL_AV1_71,
+    MFX_LEVEL_AV1_72,
+    MFX_LEVEL_AV1_73,
+};
+
 /*
  * Get & store all available Intel Quick Sync information:
  *
@@ -145,6 +237,14 @@ enum
 
 typedef struct
 {
+    const char *name;
+    const char *key;
+    const int value;
+}
+hb_triplet_t;
+
+typedef struct
+{
     /*
      * Supported mfxExtBuffer.BufferId values:
      *
@@ -170,7 +270,7 @@ typedef struct
     mfxExtCodingOption    codingOption;
     mfxExtCodingOption2   codingOption2;
     mfxExtVideoSignalInfo videoSignalInfo;
-    mfxExtHyperModeParam hyperEncodeParam;
+    hb_triplet_t*         hyperEncodeParam;
     mfxExtAV1ScreenContentTools av1ScreenContentToolsParam;
     mfxExtChromaLocInfo   chromaLocInfo;
     mfxExtMasteringDisplayColourVolume masteringDisplayColourVolume;
@@ -195,6 +295,7 @@ typedef struct
 
     // assigned via hb_qsv_param_default, may be shared with another structure
     mfxVideoParam *videoParam;
+    int low_power;
 } hb_qsv_param_t;
 
 static const char* const hb_qsv_preset_names1[] = { "speed", "balanced",            NULL, };
@@ -218,20 +319,22 @@ int   hb_qsv_atoi    (const char *str, i
 float hb_qsv_atof    (const char *str, int *err);
 
 int hb_qsv_param_default_async_depth();
-int hb_qsv_param_default_preset     (hb_qsv_param_t *param, mfxVideoParam *videoParam, hb_qsv_info_t *info, const char *preset);
-int hb_qsv_param_default            (hb_qsv_param_t *param, mfxVideoParam *videoParam, hb_qsv_info_t *info);
-int hb_qsv_param_parse              (hb_qsv_param_t *param,                            hb_qsv_info_t *info, hb_job_t *job,  const char *key, const char *value);
+int hb_qsv_param_default_preset     (AVDictionary* av_opts, hb_qsv_param_t *param, mfxVideoParam *videoParam, hb_qsv_info_t *info, const char *preset);
+int hb_qsv_param_default            (hb_qsv_param_t *param, hb_qsv_info_t *info);
+int hb_qsv_param_parse              (AVDictionary  **av_opts, hb_qsv_param_t *param, hb_qsv_info_t *info, hb_job_t *job,  const char *key, const char *value);
 int hb_qsv_profile_parse            (hb_qsv_param_t *param,                            hb_qsv_info_t *info, const char *profile_key, const int codec);
-int hb_qsv_level_parse              (hb_qsv_param_t *param,                            hb_qsv_info_t *info, const char *level_key);
 int hb_qsv_param_parse_dx_index     (hb_job_t *job, const int dx_index);
 
 typedef struct
 {
-    const char *name;
-    const char *key;
-    const int value;
-}
-hb_triplet_t;
+    hb_qsv_info_t      * qsv_info;
+    hb_qsv_param_t       param;
+    int                  async_depth;
+    int                  max_async_depth;
+    int                  is_sys_mem;
+    const AVCodec      * codec;
+    AVDictionary       * av_opts;
+} qsv_data_t;
 
 hb_triplet_t* hb_triplet4value(hb_triplet_t *triplets, const int  value);
 hb_triplet_t* hb_triplet4name (hb_triplet_t *triplets, const char *name);
@@ -240,7 +343,6 @@ hb_triplet_t* hb_triplet4key  (hb_triple
 const char* hb_qsv_codec_name    (uint32_t codec_id);
 const char* hb_qsv_profile_name  (uint32_t codec_id, uint16_t profile_id);
 const char* hb_qsv_level_name    (uint32_t codec_id, uint16_t level_id);
-const char* hb_qsv_frametype_name(uint16_t qsv_frametype);
 uint8_t     hb_qsv_frametype_xlat(uint16_t qsv_frametype, uint16_t *out_flags);
 
 const char* hb_qsv_impl_get_name(int impl);
@@ -248,31 +350,18 @@ int         hb_qsv_impl_get_num(int impl
 const char* hb_qsv_impl_get_via_name(int impl);
 mfxIMPL     hb_qsv_dx_index_to_impl(int dx_index);
 
-/* Full QSV pipeline helpers */
+/* QSV pipeline helpers */
+const char * hb_map_qsv_preset_name(const char * preset);
+int hb_qsv_apply_encoder_options(qsv_data_t * qsv_data, hb_job_t * job, AVDictionary** av_opts);
 int hb_qsv_is_enabled(hb_job_t *job);
 hb_qsv_context* hb_qsv_context_init();
 void hb_qsv_context_uninit(hb_job_t *job);
+int hb_qsv_are_filters_supported(hb_job_t *job);
 int hb_qsv_sanitize_filter_list(hb_job_t *job);
-int hb_qsv_hw_frames_init(AVCodecContext *s);
-int hb_qsv_create_ffmpeg_dec_pool(hb_job_t * job, int width, int height, int sw_pix_fmt);
-int hb_qsv_create_ffmpeg_pool(hb_job_t *job, int coded_width, int coded_height, enum AVPixelFormat sw_pix_fmt, int pool_size, int extra_hw_frames, AVBufferRef **out_hw_frames_ctx);
-int hb_qsv_create_ffmpeg_vpp_pool(hb_filter_init_t *init, int width, int height);
-int hb_qsv_hw_filters_via_system_memory_are_enabled(hb_job_t *job);
-int hb_qsv_hw_filters_via_video_memory_are_enabled(hb_job_t *job);
 int hb_qsv_get_memory_type(hb_job_t *job);
 int hb_qsv_full_path_is_enabled(hb_job_t *job);
-AVBufferRef *hb_qsv_create_mids(AVBufferRef *hw_frames_ref);
-hb_buffer_t * hb_qsv_copy_video_buffer_to_hw_video_buffer(hb_job_t *job, hb_buffer_t *in, const int is_vpp);
-hb_buffer_t * hb_qsv_buffer_dup(hb_job_t *job, hb_buffer_t *in, const int is_vpp);
-hb_buffer_t * hb_qsv_copy_avframe_to_video_buffer(hb_job_t *job, AVFrame *frame, AVRational time_base, const int is_vpp);
-int hb_qsv_get_free_surface_from_pool(HBQSVFramesContext* hb_enc_qsv_frames_ctx, AVFrame* frame, QSVMid** out_mid);
-void hb_qsv_get_free_surface_from_pool_with_range(HBQSVFramesContext* hb_enc_qsv_frames_ctx, const int start_index, const int end_index, QSVMid** out_mid, mfxFrameSurface1** out_surface);
-int hb_qsv_get_mid_by_surface_from_pool(HBQSVFramesContext* hb_enc_qsv_frames_ctx, mfxFrameSurface1 *surface, QSVMid **out_mid);
-int hb_qsv_replace_surface_mid(HBQSVFramesContext* hb_qsv_frames_ctx, const QSVMid *mid, mfxFrameSurface1 *surface);
-int hb_qsv_release_surface_from_pool_by_surface_pointer(HBQSVFramesContext* hb_enc_qsv_frames_ctx, const mfxFrameSurface1 *surface);
 int hb_qsv_get_buffer(AVCodecContext *s, AVFrame *frame, int flags);
 enum AVPixelFormat hb_qsv_get_format(AVCodecContext *s, const enum AVPixelFormat *pix_fmts);
-void hb_qsv_uninit_dec(AVCodecContext *s);
 void hb_qsv_uninit_enc(hb_job_t *job);
 int hb_qsv_setup_job(hb_job_t *job);
 int hb_qsv_decode_h264_is_supported(int adapter_index);
@@ -281,7 +370,8 @@ int hb_qsv_decode_h265_10_bit_is_support
 int hb_qsv_decode_av1_is_supported(int adapter_index);
 int hb_qsv_decode_vvc_is_supported(int adapter_index);
 int hb_qsv_decode_is_codec_supported(int adapter_index, int video_codec_param, int pix_fmt, int width, int height);
-int hb_qsv_device_init(hb_job_t *job);
+int hb_qsv_device_init(hb_job_t *job, void **hw_device_ctx);
+int hb_qsv_is_ffmpeg_supported_codec(int vcodec);
 
 #endif // __LIBHB__
 #endif // HB_PROJECT_FEATURE_QSV
diff -Naupr a/libhb/handbrake/qsv_memory.h b/libhb/handbrake/qsv_memory.h
--- a/libhb/handbrake/qsv_memory.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/qsv_memory.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/* ********************************************************************* *\
-
-Copyright (C) 2013 Intel Corporation.  All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-- Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-- Neither the name of Intel Corporation nor the names of its contributors
-may be used to endorse or promote products derived from this software
-without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY INTEL CORPORATION "AS IS" AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL INTEL CORPORATION BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-\* ********************************************************************* */
-
-#ifndef HANDBRAKE_QSV_MEMORY_H
-#define HANDBRAKE_QSV_MEMORY_H
-
-#include "handbrake/project.h"
-
-#if HB_PROJECT_FEATURE_QSV
-
-#include "handbrake/qsv_libav.h"
-
-int qsv_copy_buffer_to_surface(mfxFrameSurface1 *dst, hb_buffer_t *src);
-
-#endif // HB_PROJECT_FEATURE_QSV
-#endif // HANDBRAKE_QSV_MEMORY_H
diff -Naupr a/libhb/handbrake/rpu.h b/libhb/handbrake/rpu.h
--- a/libhb/handbrake/rpu.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/rpu.h	2025-03-31 11:55:35.244884380 +0200
@@ -1,6 +1,6 @@
 /* rpu.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/ssautil.h b/libhb/handbrake/ssautil.h
--- a/libhb/handbrake/ssautil.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/ssautil.h	2025-03-31 11:55:35.244884380 +0200
@@ -1,6 +1,6 @@
 /* ssautil.h
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
@@ -20,9 +20,9 @@ typedef struct hb_tx3g_style_context_s h
 #define HB_STYLE_FLAG_BOLD      0x0002
 #define HB_STYLE_FLAG_UNDERLINE 0x0004
 
-hb_subtitle_style_context_t * hb_subtitle_style_init(const char * ssa_header);
+hb_subtitle_style_context_t * hb_subtitle_style_init(const uint8_t * ssa_buf, int size);
 hb_tx3g_style_context_t     * hb_tx3g_style_init(
-                                        int height, const char * ssa_header);
+                                        int height, const uint8_t * ssa_buf, int size);
 void hb_subtitle_style_close(hb_subtitle_style_context_t ** ctx);
 void hb_tx3g_style_close(hb_tx3g_style_context_t ** ctx);
 
diff -Naupr a/libhb/handbrake/taskset.h b/libhb/handbrake/taskset.h
--- a/libhb/handbrake/taskset.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/taskset.h	2025-03-31 11:55:35.244884380 +0200
@@ -1,6 +1,6 @@
 /* taskset.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/handbrake/vce_common.h b/libhb/handbrake/vce_common.h
--- a/libhb/handbrake/vce_common.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/handbrake/vce_common.h	2025-03-31 11:55:35.244884380 +0200
@@ -1,6 +1,6 @@
 /* vce_common.h
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code.
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
@@ -15,9 +15,9 @@ int            hb_vce_h265_available();
 int            hb_vce_av1_available();
 
 static const char * const hb_vce_h264_profile_names[] = { "auto", "baseline", "main", "high",  NULL, };
-static const char * const hb_vce_h265_profile_names[] = { "main", NULL, };
-static const char * const hb_vce_h265_10bit_profile_names[] = { "main10", NULL, };
-static const char * const hb_vce_av1_profile_names[]  = { "main", NULL, };
+static const char * const hb_vce_h265_profile_names[] = { "auto", "main", NULL, };
+static const char * const hb_vce_h265_10bit_profile_names[] = { "auto", "main10", NULL, };
+static const char * const hb_vce_av1_profile_names[]  = { "auto", "main", NULL, };
 
 static const char * const hb_vce_h264_level_names[] =
 {
diff -Naupr a/libhb/hb.c b/libhb/hb.c
--- a/libhb/hb.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/hb.c	2025-03-31 11:55:35.244884380 +0200
@@ -1,6 +1,6 @@
 /* hb.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -483,6 +483,19 @@ hb_title_set_t * hb_get_title_set( hb_ha
     return &h->title_set;
 }
 
+hb_list_t * hb_get_title_coverarts( hb_handle_t * h, int title )
+{
+    hb_title_t * sourceTitle = hb_list_item(h->title_set.list_title, title);
+    if (sourceTitle) 
+    {
+        hb_list_t * coverart = sourceTitle->metadata->list_coverart;
+        return coverart;
+    }
+    
+    hb_list_t * emptyList = hb_list_init();
+    return emptyList;
+}
+
 int hb_save_preview( hb_handle_t * h, int title, int preview, hb_buffer_t *buf, int format )
 {
     FILE    * file;
@@ -771,8 +784,8 @@ static void process_filter(hb_filter_obj
 }
 
 // Get preview and apply applicable filters
-hb_image_t * hb_get_preview3(hb_handle_t * h, int picture,
-                             hb_dict_t * job_dict)
+hb_image_t * hb_get_preview(hb_handle_t * h, hb_dict_t * job_dict,
+                             int picture, int rescale, int pix_fmt)
 {
     hb_job_t    * job;
     hb_title_t  * title = NULL;
@@ -880,50 +893,55 @@ hb_image_t * hb_get_preview3(hb_handle_t
     job->cfr = init.cfr;
     job->grayscale = init.grayscale;
 
-    // Add "cropscale"
-    // Adjusts for pixel aspect, performs any requested
-    // post-scaling and sets required pix_fmt AV_PIX_FMT_RGB32
-    //
-    // This will scale the result at the end of the pipeline.
-    // I.e. padding will be scaled
-    hb_rational_t par = job->par;
-
-    int scaled_width  = init.geometry.width;
-    int scaled_height = init.geometry.height;
-
-    filter = hb_filter_init(HB_FILTER_CROP_SCALE);
-    filter->settings = hb_dict_init();
-    if (par.num >= par.den)
-    {
-        scaled_width = scaled_width * par.num / par.den;
-    }
-    else
+    if (rescale)
     {
-        scaled_height = scaled_height * par.den / par.num;
-    }
-    hb_dict_set_int(filter->settings, "width", scaled_width);
-    hb_dict_set_int(filter->settings, "height", scaled_height);
-    hb_list_add(job->list_filter, filter);
+        // Add "cropscale"
+        // Adjusts for pixel aspect, performs any requested post-scaling
+        //
+        // This will scale the result at the end of the pipeline.
+        // I.e. padding will be scaled
+        hb_rational_t par = job->par;
+
+        int scaled_width  = init.geometry.width;
+        int scaled_height = init.geometry.height;
+
+        filter = hb_filter_init(HB_FILTER_CROP_SCALE);
+        filter->settings = hb_dict_init();
+        if (par.num >= par.den)
+        {
+            scaled_width = scaled_width * par.num / par.den;
+        }
+        else
+        {
+            scaled_height = scaled_height * par.den / par.num;
+        }
+        hb_dict_set_int(filter->settings, "width", scaled_width);
+        hb_dict_set_int(filter->settings, "height", scaled_height);
+        hb_list_add(job->list_filter, filter);
 
-    if (filter->init != NULL && filter->init(filter, &init))
-    {
-        hb_error("hb_get_preview3: Failure to initialize filter '%s'",
-                 filter->name);
-        hb_list_rem(list_filter, filter);
-        hb_filter_close(&filter);
+        if (filter->init != NULL && filter->init(filter, &init))
+        {
+            hb_error("hb_get_preview3: Failure to initialize filter '%s'",
+                     filter->name);
+            hb_list_rem(list_filter, filter);
+            hb_filter_close(&filter);
+        }
     }
 
-    filter = hb_filter_init(HB_FILTER_FORMAT);
-    filter->settings = hb_dict_init();
-    hb_dict_set_string(filter->settings, "format", av_get_pix_fmt_name(AV_PIX_FMT_RGB32));
-    hb_list_add(job->list_filter, filter);
-
-    if (filter->init != NULL && filter->init(filter, &init))
+    if (pix_fmt != AV_PIX_FMT_NONE)
     {
-        hb_error("hb_get_preview3: Failure to initialize filter '%s'",
-                 filter->name);
-        hb_list_rem(list_filter, filter);
-        hb_filter_close(&filter);
+        filter = hb_filter_init(HB_FILTER_FORMAT);
+        filter->settings = hb_dict_init();
+        hb_dict_set_string(filter->settings, "format", av_get_pix_fmt_name(pix_fmt));
+        hb_list_add(job->list_filter, filter);
+
+        if (filter->init != NULL && filter->init(filter, &init))
+        {
+            hb_error("hb_get_preview3: Failure to initialize filter '%s'",
+                     filter->name);
+            hb_list_rem(list_filter, filter);
+            hb_filter_close(&filter);
+        }
     }
 
     hb_avfilter_combine(list_filter);
@@ -1023,13 +1041,19 @@ fail:
             height = geo->height;
         }
 
-        image = hb_image_init(AV_PIX_FMT_RGB32, width, height);
+        image = hb_image_init(pix_fmt, width, height);
     }
     hb_job_close(&job);
 
     return image;
 }
 
+hb_image_t * hb_get_preview3(hb_handle_t * h, int picture,
+                             hb_dict_t * job_dict)
+{
+    return hb_get_preview(h, job_dict, picture, 1, AV_PIX_FMT_RGB32);
+}
+
  /**
  * Analyzes a frame to detect interlacing artifacts
  * and returns true if interlacing (combing) is found.
@@ -2123,6 +2147,7 @@ int hb_global_init()
     }
 
     /* HB work objects */
+    hb_register(&hb_workpass);
     hb_register(&hb_muxer);
     hb_register(&hb_reader);
     hb_register(&hb_sync_video);
@@ -2132,9 +2157,11 @@ int hb_global_init()
     hb_register(&hb_decavcodeca);
     hb_register(&hb_declpcm);
     hb_register(&hb_decavsub);
+    hb_register(&hb_encavsub);
     hb_register(&hb_decsrtsub);
     hb_register(&hb_decssasub);
     hb_register(&hb_dectx3gsub);
+    hb_register(&hb_enctx3gsub);
     hb_register(&hb_encavcodec);
     hb_register(&hb_encavcodeca);
 #ifdef __APPLE__
@@ -2149,12 +2176,6 @@ int hb_global_init()
     hb_register(&hb_encx265);
 #endif
     hb_register(&hb_encsvtav1);
-#if HB_PROJECT_FEATURE_QSV
-    if (!disable_hardware)
-    {
-        hb_register(&hb_encqsv);
-    }
-#endif
 
     hb_x264_global_init();
     hb_common_global_init(disable_hardware);
diff -Naupr a/libhb/hb_dict.c b/libhb/hb_dict.c
--- a/libhb/hb_dict.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/hb_dict.c	2025-03-31 11:55:35.245884363 +0200
@@ -1,6 +1,6 @@
 /* hb_dict.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/hb_json.c b/libhb/hb_json.c
--- a/libhb/hb_json.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/hb_json.c	2025-03-31 11:55:35.245884363 +0200
@@ -1,6 +1,6 @@
 /* json.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -494,6 +494,26 @@ static hb_dict_t* hb_title_to_dict_inter
     }
     hb_dict_set(dict, "SubtitleList", subtitle_list);
 
+    // process cover arts
+    if (title->metadata && title->metadata->list_coverart)
+    {
+        hb_value_array_t *art_array = hb_value_array_init();
+        for (ii = 0; ii < hb_list_count(title->metadata->list_coverart); ii++)
+        {
+            hb_coverart_t *art = hb_list_item(title->metadata->list_coverart, ii);
+            hb_dict_t *coverart_dict = json_pack_ex(&error, 0,
+                                                    "{s:o, s:o, s:o}",
+                                                    "ID", hb_value_int(ii),
+                                                    "Name",  hb_value_string(art->name),
+                                                    "Type",  hb_value_int(art->type));
+            if (coverart_dict)
+            {
+                hb_value_array_append(art_array, coverart_dict);
+            }
+        }
+        hb_dict_set(dict, "CoverArts", art_array);
+    }
+
     return dict;
 }
 
@@ -821,6 +841,9 @@ hb_dict_t* hb_job_to_dict( const hb_job_
         hb_dict_set(video_dict, "Turbo",
                             hb_value_bool(job->fastanalysispass));
     }
+    hb_dict_set(video_dict, "PasshtruHDRDynamicMetadata",
+                        hb_value_int(job->passthru_dynamic_hdr_metadata));
+
     if (job->encoder_preset != NULL)
     {
         hb_dict_set(video_dict, "Preset",
@@ -933,6 +956,12 @@ hb_dict_t* hb_job_to_dict( const hb_job_
 
     // process subtitle list
     hb_dict_t *subtitles_dict = hb_dict_get(dict, "Subtitle");
+    if (job->select_subtitle_config.external_filename != NULL)
+    {
+        hb_dict_t *search = hb_dict_get(subtitles_dict, "Search");
+        hb_dict_set_string(search, "ExternalFilename",
+                           job->select_subtitle_config.external_filename);
+    }
     hb_dict_t *subtitle_list = hb_dict_get(subtitles_dict, "SubtitleList");
     for (ii = 0; ii < hb_list_count(job->list_subtitle); ii++)
     {
@@ -973,9 +1002,34 @@ hb_dict_t* hb_job_to_dict( const hb_job_
         {
             hb_dict_set_string(subtitle_dict, "Name", subtitle->config.name);
         }
+        if (subtitle->config.external_filename != NULL)
+        {
+            hb_dict_set_string(subtitle_dict, "ExternalFilename",
+                               subtitle->config.external_filename);
+        }
         hb_value_array_append(subtitle_list, subtitle_dict);
     }
 
+    // process cover arts
+    if (job->metadata && job->metadata->list_coverart)
+    {
+        hb_value_array_t *art_array = hb_value_array_init();
+        for (ii = 0; ii < hb_list_count(job->metadata->list_coverart); ii++)
+        {
+            hb_coverart_t *art = hb_list_item(job->metadata->list_coverart, ii);
+            hb_dict_t *art_dict = json_pack_ex(&error, 0,
+                                               "{s:o, s:o, s:o}",
+                                               "ID", hb_value_int(ii),
+                                               "Name",  hb_value_string(art->name),
+                                               "Type",  hb_value_int(art->type));
+            if (art_dict)
+            {
+                hb_value_array_append(art_array, art_dict);
+            }
+        }
+        hb_dict_set(dict, "CoverArts", art_array);
+    }
+
     return dict;
 }
 
@@ -1115,12 +1169,15 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
     const char       * video_preset = NULL, * video_tune = NULL;
     const char       * video_profile = NULL, * video_level = NULL;
     const char       * video_options = NULL;
+    int                passthru_dynamic_hdr_metadata = -1;
     int                subtitle_search_burn = 0;
+    const char       * subtitle_search_external_filename = NULL;
     json_int_t         range_start = -1, range_end = -1, range_seek_points = -1;
     int                vbitrate = -1;
     double             vquality = HB_INVALID_VIDEO_QUALITY;
     int                adapter_index = -1;
     hb_dict_t        * meta_dict = NULL;
+    hb_value_array_t * art_array = NULL;
 
     result = json_unpack_ex(dict, &error, 0,
     "{"
@@ -1135,7 +1192,7 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
     // PAR {Num, Den}
     "s?{s:i, s:i},"
     // Video {Codec, Quality, Bitrate, Preset, Tune, Profile, Level, Options
-    //       MultiPass, Turbo,
+    //       MultiPass, Turbo, PasshtruHDRDynamicMetadata
     //       ColorInputFormat, ColorOutputFormat, ColorRange,
     //       ColorPrimaries, ColorTransfer, ColorMatrix, ChromaLocation,
     //       MasteringDisplayColorVolume,
@@ -1145,7 +1202,7 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
     //       HardwareDecode
     //       QSV {Decode, AsyncDepth, AdapterIndex}}
     "s:{s:o, s?F, s?i, s?s, s?s, s?s, s?s, s?s,"
-    "   s?b, s?b,"
+    "   s?b, s?b, s?i,"
     "   s?i, s?i, s?i,"
     "   s?i, s?i, s?i, s?i,"
     "   s?o,"
@@ -1156,10 +1213,12 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
     "   s?{s?b, s?i, s?i}},"
     // Audio {CopyMask, FallbackEncoder, AudioList}
     "s?{s?o, s?o, s?o},"
-    // Subtitle {Search {Enable, Forced, Default, Burn}, SubtitleList}
-    "s?{s?{s:b, s?b, s?b, s?b}, s?o},"
+    // Subtitle {Search {Enable, Forced, Default, Burn, ExternalFilename}, SubtitleList}
+    "s?{s?{s:b, s?b, s?b, s?b, s?s}, s?o},"
     // Metadata
     "s?o,"
+    // Cover arts
+    "s?o,"
     // Filters {FilterList}
     "s?{s?o}"
     "}",
@@ -1196,6 +1255,7 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
             "Options",              unpack_s(&video_options),
             "MultiPass",            unpack_b(&job->multipass),
             "Turbo",                unpack_b(&job->fastanalysispass),
+            "PasshtruHDRDynamicMetadata", unpack_i(&passthru_dynamic_hdr_metadata),
             "ColorInputFormat",     unpack_i(&job->input_pix_fmt),
             "ColorOutputFormat",    unpack_i(&job->output_pix_fmt),
             "ColorRange",           unpack_i(&job->color_range),
@@ -1224,8 +1284,10 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
                 "Forced",           unpack_b(&job->select_subtitle_config.force),
                 "Default",          unpack_b(&job->select_subtitle_config.default_track),
                 "Burn",             unpack_b(&subtitle_search_burn),
+                "ExternalFilename", unpack_s(&subtitle_search_external_filename),
             "SubtitleList",         unpack_o(&subtitle_list),
         "Metadata",                 unpack_o(&meta_dict),
+        "CoverArts",                unpack_o(&art_array),
         "Filters",
             "FilterList",           unpack_o(&filter_list)
     );
@@ -1239,6 +1301,35 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
         hb_value_free(&job->metadata->dict);
         job->metadata->dict = hb_value_dup(meta_dict);
     }
+    if (art_array != NULL)
+    {
+        if (hb_value_type(art_array) == HB_VALUE_TYPE_ARRAY)
+        {
+            int count = hb_value_array_len(art_array);
+            for (int ii = hb_list_count(job->metadata->list_coverart) - 1; ii >= 0; ii--)
+            {
+                int found = 0;
+                for (int jj = count; jj >= 0; jj--)
+                {
+                    hb_dict_t *art_dict = hb_value_array_get(art_array, jj);
+                    if (art_dict)
+                    {
+                        int index = hb_dict_get_int(art_dict, "ID");
+                        if (index == ii)
+                        {
+                            found = 1;
+                            break;
+                        }
+                    }
+                }
+
+                if (found == 0)
+                {
+                    hb_metadata_rem_coverart(job->metadata, ii);
+                }
+            }
+        }
+    }
     // Lookup mux id
     if (hb_value_type(mux) == HB_VALUE_TYPE_STRING)
     {
@@ -1297,6 +1388,11 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
         }
     }
 
+    if (passthru_dynamic_hdr_metadata > -1)
+    {
+        job->passthru_dynamic_hdr_metadata = passthru_dynamic_hdr_metadata;
+    }
+
     if (destfile != NULL && destfile[0] != 0)
     {
         hb_job_set_file(job, destfile);
@@ -1312,6 +1408,10 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
     if (job->qsv.ctx) {
         job->qsv.ctx->dx_index = adapter_index;
     }
+    // Prefer to use QSV decode when QSV encoder is enabled
+    if (!job->hw_decode && job->qsv.decode && hb_qsv_encoder_info_get(hb_qsv_get_adapter_index(), job->vcodec)) {
+        job->hw_decode = HB_DECODE_SUPPORT_QSV;
+    }
 #endif
     // If both vbitrate and vquality were specified, vbitrate is used;
     // we need to ensure the unused rate control mode is always set to an
@@ -1330,9 +1430,6 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
     }
     // If neither were specified, defaults are used (set in job_setup())
 
-    job->select_subtitle_config.dest = subtitle_search_burn ?
-                                            RENDERSUB : PASSTHRUSUB;
-
     if (mastering_dict != NULL)
     {
         result = json_unpack_ex(mastering_dict, &error, 0,
@@ -1639,6 +1736,11 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
         ii++;
     }
 
+    job->select_subtitle_config.dest = subtitle_search_burn ?
+                                            RENDERSUB : PASSTHRUSUB;
+    hb_update_str(&job->select_subtitle_config.external_filename,
+                  subtitle_search_external_filename);
+
     // process subtitle list
     if (subtitle_list != NULL &&
         hb_value_type(subtitle_list) == HB_VALUE_TYPE_ARRAY)
@@ -1655,11 +1757,13 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
             const char *importfile = NULL;
             json_int_t offset = 0;
             const char *name = NULL;
+            const char *external_filename = NULL;
 
             result = json_unpack_ex(subtitle_dict, &error, 0,
-                                    "{s?i, s?s, s?{s:s}, s?{s:s}}",
+                                    "{s?i, s?s, s?s, s?{s:s}, s?{s:s}}",
                                     "Track", unpack_i(&track),
                                     "Name",  unpack_s(&name),
+                                    "ExternalFilename", unpack_s(&external_filename),
                                     // Support legacy "SRT" import
                                     "SRT",
                                         "Filename", unpack_s(&importfile),
@@ -1680,10 +1784,6 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
                 if (subtitle != NULL)
                 {
                     sub_config = subtitle->config;
-                    if (name != NULL)
-                    {
-                        sub_config.name = name;
-                    }
                     result = json_unpack_ex(subtitle_dict, &error, 0,
                         "{s?b, s?b, s?b, s?I}",
                         "Default",  unpack_b(&sub_config.default_track),
@@ -1696,8 +1796,10 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
                         hb_job_close(&job);
                         return NULL;
                     }
+                    sub_config.name = name;
                     sub_config.offset = offset;
                     sub_config.dest = burn ? RENDERSUB : PASSTHRUSUB;
+                    sub_config.external_filename = (char*)external_filename;
                     hb_subtitle_add(job, &sub_config, track);
                 }
             }
@@ -1731,10 +1833,7 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
                     hb_job_close(&job);
                     return NULL;
                 }
-                if (name != NULL)
-                {
-                    sub_config.name = name;
-                }
+                sub_config.name = name;
                 sub_config.offset = offset;
                 sub_config.dest = burn ? RENDERSUB : PASSTHRUSUB;
                 strncpy(sub_config.src_codeset, srtcodeset, 39);
@@ -1743,6 +1842,7 @@ hb_job_t* hb_dict_to_job( hb_handle_t *
                 {
                     source = IMPORTSSA;
                 }
+                sub_config.external_filename = (char*)external_filename;
                 hb_import_subtitle_add(job, &sub_config, lang, source);
             }
         }
diff -Naupr a/libhb/hbavfilter.c b/libhb/hbavfilter.c
--- a/libhb/hbavfilter.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/hbavfilter.c	2025-03-31 11:55:35.245884363 +0200
@@ -1,6 +1,6 @@
 /* hbavfilter.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -67,64 +67,37 @@ hb_avfilter_graph_init(hb_value_t * sett
 #endif
 
     // Build filter input
-#if HB_PROJECT_FEATURE_QSV
-    // Need to handle preview as special case
-    if (hb_qsv_full_path_is_enabled(graph->job) && init->pix_fmt != AV_PIX_FMT_YUV420P)
     {
-        enum AVPixelFormat pix_fmt = init->hw_pix_fmt;
-        if (pix_fmt == AV_PIX_FMT_NONE)
+        enum AVPixelFormat pix_fmt = init->pix_fmt;
+        if (init->hw_pix_fmt == AV_PIX_FMT_QSV)
         {
-            pix_fmt = init->pix_fmt;
-        }
-
-        par = av_buffersrc_parameters_alloc();
-        par->format = pix_fmt;
-        // TODO: qsv_vpp changes time_base, adapt settings to hb pipeline
-        par->frame_rate.num = init->time_base.den;
-        par->frame_rate.den = init->time_base.num;
-        par->width = init->geometry.width;
-        par->height = init->geometry.height;
-        par->sample_aspect_ratio.num = init->geometry.par.num;
-        par->sample_aspect_ratio.den = init->geometry.par.den;
-        par->time_base.num = init->time_base.num;
-        par->time_base.den = init->time_base.den;
+            par = av_buffersrc_parameters_alloc();
+            par->format = init->hw_pix_fmt;
+            // TODO: qsv_vpp changes time_base, adapt settings to hb pipeline
+            par->frame_rate.num = init->time_base.den;
+            par->frame_rate.den = init->time_base.num;
 
-        filter_args = hb_strdup_printf(
-                "video_size=%dx%d:pix_fmt=%d:sar=%d/%d:"
-                "colorspace=%d:range=%d:"
-                "time_base=%d/%d:frame_rate=%d/%d",
-                init->geometry.width, init->geometry.height, pix_fmt,
-                init->geometry.par.num, init->geometry.par.den,
-                init->color_matrix, init->color_range,
-                init->time_base.num, init->time_base.den,
-                init->vrate.num, init->vrate.den);
+            par->width = init->geometry.width;
+            par->height = init->geometry.height;
 
-        AVBufferRef *hb_hw_frames_ctx = NULL;
+            par->sample_aspect_ratio.num = init->geometry.par.num;
+            par->sample_aspect_ratio.den = init->geometry.par.den;
 
-        if (pix_fmt == AV_PIX_FMT_QSV)
-        {
-            result = hb_qsv_create_ffmpeg_pool(graph->job, init->geometry.width, init->geometry.height, init->pix_fmt, HB_QSV_POOL_SURFACE_SIZE, 0, &hb_hw_frames_ctx);
-            if (result < 0)
-            {
-                hb_error("hb_create_ffmpeg_pool failed");
+            par->time_base.num = init->time_base.num;
+            par->time_base.den = init->time_base.den;
+            par->hw_frames_ctx = hb_hwaccel_init_hw_frames_ctx((AVBufferRef*)init->job->hw_device_ctx,
+                                                    init->pix_fmt,
+                                                    init->hw_pix_fmt,
+                                                    par->width,
+                                                    par->height,
+                                                            32);
+            if (!par->hw_frames_ctx)
+            {   
                 goto fail;
             }
+            pix_fmt = init->hw_pix_fmt;
         }
-        else
-        {
-            hb_qsv_device_init(graph->job);
-            for (int i = 0; i < graph->avgraph->nb_filters; i++)
-            {
-                graph->avgraph->filters[i]->hw_device_ctx = av_buffer_ref(graph->job->qsv.ctx->hb_hw_device_ctx);
-            }
-        }
-        par->hw_frames_ctx = hb_hw_frames_ctx;
-    }
-    else
-#endif
-    {
-        enum AVPixelFormat pix_fmt = init->pix_fmt;
-        if (init->hw_pix_fmt == AV_PIX_FMT_CUDA)
+        else if (init->hw_pix_fmt == AV_PIX_FMT_CUDA)
         {
             par = av_buffersrc_parameters_alloc();
             par->format = init->hw_pix_fmt;
@@ -136,7 +109,8 @@ hb_avfilter_graph_init(hb_value_t * sett
                                                     init->pix_fmt,
                                                     init->hw_pix_fmt,
                                                     par->width,
-                                                    par->height);
+                                                    par->height,
+                                                             0);
             if (!par->hw_frames_ctx)
             {   
                 goto fail;
@@ -317,15 +291,22 @@ hb_buffer_t * hb_avfilter_get_buf(hb_avf
     {
         hb_buffer_t * buf;
 #if HB_PROJECT_FEATURE_QSV
-        if (hb_qsv_hw_filters_via_video_memory_are_enabled(graph->job))
-        {
-            buf = hb_qsv_copy_avframe_to_video_buffer(graph->job, graph->frame, graph->out_time_base, 1);
-        }
-        else
-#endif
+        if (hb_hwaccel_is_full_hardware_pipeline_enabled(graph->job) &&
+            hb_qsv_decode_is_enabled(graph->job))
         {
-            buf = hb_avframe_to_video_buffer(graph->frame, graph->out_time_base);
+            AVBufferRef *hw_frames_ctx = av_buffersink_get_hw_frames_ctx(graph->output);
+            if (!hw_frames_ctx)
+            {
+                hb_error("hb_avfilter_get_buf: failed to get hw_frames_ctx from sink");
+            }
+            else
+            {
+                // copy hw frame ctx from filter graph for future encoder initialization
+                graph->job->qsv.ctx->hb_ffmpeg_qsv_hw_frames_ctx = av_buffer_ref(hw_frames_ctx);
+            }
         }
+ #endif
+        buf = hb_avframe_to_video_buffer(graph->frame, graph->out_time_base);
         av_frame_unref(graph->frame);
         return buf;
     }
diff -Naupr a/libhb/hbffmpeg.c b/libhb/hbffmpeg.c
--- a/libhb/hbffmpeg.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/hbffmpeg.c	2025-03-31 11:55:35.245884363 +0200
@@ -1,6 +1,6 @@
 /* hbffmpeg.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/hdr10plus.c b/libhb/hdr10plus.c
--- a/libhb/hdr10plus.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/hdr10plus.c	2025-03-31 11:55:35.245884363 +0200
@@ -1,6 +1,6 @@
 /* hdr10plus.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/hwaccel.c b/libhb/hwaccel.c
--- a/libhb/hwaccel.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/hwaccel.c	2025-03-31 11:55:35.245884363 +0200
@@ -1,6 +1,6 @@
 /* hwaccel.c
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code.
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
@@ -10,11 +10,96 @@
 #include "handbrake/hbffmpeg.h"
 #include "handbrake/handbrake.h"
 #include "handbrake/nvenc_common.h"
-
+#include "handbrake/qsv_common.h"
 #ifdef __APPLE__
 #include "platform/macosx/vt_common.h"
 #endif
 
+static int is_encoder_supported(int encoder_id)
+{
+    switch (encoder_id)
+    {
+        case HB_VCODEC_FFMPEG_NVENC_H264:
+        case HB_VCODEC_FFMPEG_NVENC_H265:
+        case HB_VCODEC_FFMPEG_NVENC_H265_10BIT:
+        case HB_VCODEC_FFMPEG_NVENC_AV1:
+        case HB_VCODEC_FFMPEG_NVENC_AV1_10BIT:
+        case HB_VCODEC_VT_H264:
+        case HB_VCODEC_VT_H265:
+        case HB_VCODEC_VT_H265_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_H264:
+        case HB_VCODEC_FFMPEG_QSV_H265:
+        case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_AV1:
+        case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
+            return 1;
+        default:
+            return 0;
+    }
+}
+
+static int are_filters_supported(hb_job_t * job)
+{
+    int ret = 0;
+#ifdef __APPLE__
+    if (job->hw_decode & HB_DECODE_SUPPORT_VIDEOTOOLBOX)
+    {
+        ret = hb_vt_are_filters_supported(job->list_filter);
+    }
+#endif
+    if (job->hw_decode & HB_DECODE_SUPPORT_NVDEC)
+    {
+        ret = hb_nvenc_are_filters_supported(job->list_filter);
+    }
+#if HB_PROJECT_FEATURE_QSV
+    if (job->hw_decode & HB_DECODE_SUPPORT_QSV)
+    {
+        ret = hb_qsv_are_filters_supported(job);
+    }
+#endif
+    return ret;
+}
+
+int hb_hwaccel_is_enabled(hb_job_t *job)
+{
+    return job != NULL &&
+           (
+              (
+                (job->title->video_decode_support & HB_DECODE_SUPPORT_HWACCEL) && 
+                (job->hw_decode & HB_DECODE_SUPPORT_HWACCEL)
+              )
+#if HB_PROJECT_FEATURE_QSV
+              || hb_qsv_decode_is_enabled(job)
+#endif
+           );
+}
+
+int hb_hwaccel_is_full_hardware_pipeline_enabled(hb_job_t *job)
+{
+    return hb_hwaccel_is_enabled(job) &&
+            are_filters_supported(job) &&
+            is_encoder_supported(job->vcodec);
+}
+
+int hb_hwaccel_decode_is_enabled(hb_job_t *job)
+{
+    if (job != NULL)
+    {
+        if (job->hw_decode & HB_DECODE_SUPPORT_FORCE_HW)
+        {
+            return hb_hwaccel_is_enabled(job);
+        }
+        else
+        {
+            return hb_hwaccel_is_full_hardware_pipeline_enabled(job);
+        }
+    }
+    else
+    {
+        return 0;
+    }
+}
+
 enum AVHWDeviceType hb_hwaccel_available(int codec_id, const char *hwdevice_name)
 {
     if (is_hardware_disabled())
@@ -24,6 +109,10 @@ enum AVHWDeviceType hb_hwaccel_available
 
     const AVCodec *codec = avcodec_find_decoder(codec_id);
     enum AVHWDeviceType hw_type = av_hwdevice_find_type_by_name(hwdevice_name);
+    if (hw_type == AV_HWDEVICE_TYPE_QSV)
+    {
+        return 1;
+    }
 
     if (hw_type != AV_HWDEVICE_TYPE_NONE)
     {
@@ -56,6 +145,16 @@ enum AVPixelFormat hw_hwaccel_get_hw_for
         {
             if (*p == job->hw_pix_fmt)
             {
+#if HB_PROJECT_FEATURE_QSV
+                if (*p == AV_PIX_FMT_QSV)
+                {
+                    if (job->qsv.ctx->hb_ffmpeg_qsv_hw_frames_ctx)
+                    {
+                        // in case if decoder and encoder have the same size
+                        ctx->hw_frames_ctx = av_buffer_ref(job->qsv.ctx->hb_ffmpeg_qsv_hw_frames_ctx);
+                    }
+                }
+#endif
                 return *p;
             }
         }
@@ -69,7 +168,7 @@ enum AVPixelFormat hw_hwaccel_get_hw_for
     return AV_PIX_FMT_NONE;
 }
 
-int hb_hwaccel_hw_ctx_init(int codec_id, int hw_decode, void **hw_device_ctx)
+int hb_hwaccel_hw_ctx_init(int codec_id, int hw_decode, void **hw_device_ctx, hb_job_t *job)
 {
     enum AVHWDeviceType hw_type = AV_HWDEVICE_TYPE_NONE;
     enum AVPixelFormat pix_fmt = AV_PIX_FMT_NONE;
@@ -85,6 +184,22 @@ int hb_hwaccel_hw_ctx_init(int codec_id,
     {
         hw_type = av_hwdevice_find_type_by_name("cuda");
     }
+#if HB_PROJECT_FEATURE_QSV
+    else if (hw_decode & HB_DECODE_SUPPORT_QSV)
+    {
+        AVBufferRef *ctx = NULL;
+        hw_type = av_hwdevice_find_type_by_name("qsv");
+        pix_fmt = AV_PIX_FMT_QSV;
+        err = hb_qsv_device_init(job, (void**)&ctx);
+        if (err < 0)
+        {
+            hb_error("hwaccel: failed to create hwdevice");
+            return err;
+        }
+        *hw_device_ctx = av_buffer_ref(ctx);
+        return err;
+    }
+#endif
     else if (hw_decode & HB_DECODE_SUPPORT_MF)
     {
         hw_type = av_hwdevice_find_type_by_name("d3d11va");
@@ -136,12 +251,21 @@ int hb_hwaccel_hwframes_ctx_init(AVCodec
 {
     if (!ctx->hw_device_ctx)
     {
-        hb_error("hwaccel: failed to initialize hw frames context");
+        hb_error("hwaccel: failed to initialize hw frames context - no hw_device_ctx");
         return 1;
     }
 
     ctx->get_format = hw_hwaccel_get_hw_format;
     ctx->pix_fmt = job->hw_pix_fmt;
+#if HB_PROJECT_FEATURE_QSV
+    if (hb_hwaccel_is_full_hardware_pipeline_enabled(job) &&
+            hb_qsv_decode_is_enabled(job))
+    {
+        ctx->extra_hw_frames = 32;
+        ctx->sw_pix_fmt = job->input_pix_fmt;
+    }
+#endif
+
     ctx->hw_frames_ctx = av_hwframe_ctx_alloc(ctx->hw_device_ctx);
 
     AVHWFramesContext *frames_ctx = (AVHWFramesContext *)ctx->hw_frames_ctx->data;
@@ -150,9 +274,26 @@ int hb_hwaccel_hwframes_ctx_init(AVCodec
     frames_ctx->width = ctx->width;
     frames_ctx->height = ctx->height;
 
+#if HB_PROJECT_FEATURE_QSV
+    if (hb_hwaccel_is_full_hardware_pipeline_enabled(job) &&
+            hb_qsv_decode_is_enabled(job))
+    {
+        // Use input pix format for decoder and filters frame pools, output frame pools are created by FFmpeg
+        frames_ctx->sw_format = job->input_pix_fmt;
+        frames_ctx->initial_pool_size = HB_QSV_POOL_FFMPEG_SURFACE_SIZE;
+        if (ctx->extra_hw_frames >= 0)
+        {
+            frames_ctx->initial_pool_size += ctx->extra_hw_frames;
+        }
+
+        AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;
+        frames_hwctx->frame_type = MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET;
+    }
+#endif
+
     if (av_hwframe_ctx_init(ctx->hw_frames_ctx) != 0)
     {
-        hb_error("hwaccel: failed to initialize hw frames context");
+        hb_error("hwaccel: failed to initialize hw frames context - av_hwframe_ctx_init");
         return 1;
     }
 
@@ -163,7 +304,8 @@ AVBufferRef *hb_hwaccel_init_hw_frames_c
                                        enum AVPixelFormat sw_fmt,
                                        enum AVPixelFormat hw_fmt,
                                        int width,
-                                       int height)
+                                       int height,
+                                       int initial_pool_size)
 {
     AVBufferRef *hw_frames_ctx = av_hwframe_ctx_alloc(hw_device_ctx);
     AVHWFramesContext *frames_ctx = (AVHWFramesContext*)hw_frames_ctx->data;
@@ -171,6 +313,11 @@ AVBufferRef *hb_hwaccel_init_hw_frames_c
     frames_ctx->sw_format = sw_fmt;
     frames_ctx->width = width;
     frames_ctx->height = height;
+
+    if (initial_pool_size > 0)
+    {
+        frames_ctx->initial_pool_size = initial_pool_size;
+    }
     if (0 != av_hwframe_ctx_init(hw_frames_ctx))
     {
         hb_error("hwaccel: failed to initialize hw frames context");
@@ -194,7 +341,7 @@ static int hb_hwaccel_hwframe_init(hb_jo
 
     *frame = av_frame_alloc();
     hw_frames_ctx = hb_hwaccel_init_hw_frames_ctx(hw_device_ctx, job->input_pix_fmt, job->hw_pix_fmt,
-                                       job->width, job->height);
+                                       job->width, job->height, 0);
     return av_hwframe_get_buffer(hw_frames_ctx, *frame, 0);
 }
 
@@ -249,75 +396,6 @@ hb_buffer_t * hb_hwaccel_copy_video_buff
     return NULL;
 }
 
-static int is_encoder_supported(int encoder_id)
-{
-    switch (encoder_id)
-    {
-        case HB_VCODEC_FFMPEG_NVENC_H264:
-        case HB_VCODEC_FFMPEG_NVENC_H265:
-        case HB_VCODEC_FFMPEG_NVENC_H265_10BIT:
-        case HB_VCODEC_FFMPEG_NVENC_AV1:
-        case HB_VCODEC_FFMPEG_NVENC_AV1_10BIT:
-        case HB_VCODEC_VT_H264:
-        case HB_VCODEC_VT_H265:
-        case HB_VCODEC_VT_H265_10BIT:
-            return 1;
-        default:
-            return 0;
-    }
-}
-
-static int are_filters_supported(hb_list_t *filters, int hw_decode)
-{
-    int ret = 0;
-
-#ifdef __APPLE__
-    if (hw_decode & HB_DECODE_SUPPORT_VIDEOTOOLBOX)
-    {
-        ret = hb_vt_are_filters_supported(filters);
-    }
-#endif
-    if (hw_decode & HB_DECODE_SUPPORT_NVDEC)
-    {
-        ret = hb_nvenc_are_filters_supported(filters);
-    }
-
-    return ret;
-}
-
-int hb_hwaccel_is_enabled(hb_job_t *job)
-{
-    return job != NULL &&
-           (job->title->video_decode_support & HB_DECODE_SUPPORT_HWACCEL) &&
-           (job->hw_decode & HB_DECODE_SUPPORT_HWACCEL);
-}
-
-int hb_hwaccel_is_full_hardware_pipeline_enabled(hb_job_t *job)
-{
-    return hb_hwaccel_is_enabled(job) &&
-            are_filters_supported(job->list_filter, job->hw_decode) &&
-            is_encoder_supported(job->vcodec);
-}
-
-int hb_hwaccel_decode_is_enabled(hb_job_t *job)
-{
-    if (job != NULL)
-    {
-        if (job->hw_decode & HB_DECODE_SUPPORT_FORCE_HW)
-        {
-            return hb_hwaccel_is_enabled(job);
-        }
-        else
-        {
-            return hb_hwaccel_is_full_hardware_pipeline_enabled(job);
-        }
-    }
-    else
-    {
-        return 0;
-    }
-}
-
 #if HB_PROJECT_FEATURE_MF
 int hb_directx_available()
 {
diff -Naupr a/libhb/lang.c b/libhb/lang.c
--- a/libhb/lang.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/lang.c	2025-03-31 11:55:35.245884363 +0200
@@ -1,6 +1,6 @@
 /* lang.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/lapsharp.c b/libhb/lapsharp.c
--- a/libhb/lapsharp.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/lapsharp.c	2025-03-31 11:55:35.245884363 +0200
@@ -1,6 +1,6 @@
 /* lapsharp.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/mf_common.c b/libhb/mf_common.c
--- a/libhb/mf_common.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/mf_common.c	2025-03-31 11:55:35.245884363 +0200
@@ -1,6 +1,6 @@
 /* mf_common.c
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code.
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/module.defs b/libhb/module.defs
--- a/libhb/module.defs	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/module.defs	2025-03-31 11:55:35.245884363 +0200
@@ -1,4 +1,4 @@
-__deps__ := BZIP2 LIBVPX SVT-AV1 FFMPEG FREETYPE LAME LIBASS \
+__deps__ := BZIP2 CPUINFO LIBVPX SVT-AV1 FFMPEG FREETYPE LAME LIBASS \
     LIBDVDREAD LIBDVDNAV LIBICONV LIBTHEORA LIBVORBIS LIBOGG \
     X264 X265 ZLIB LIBBLURAY FDKAAC LIBVPL LIBGNURX JANSSON \
     HARFBUZZ LIBOPUS LIBSPEEX LIBDAV1D LIBJPEGTURBO LIBDOVI
@@ -116,7 +116,7 @@ LIBHB.dll = $(LIBHB.build/)hb.dll
 LIBHB.lib = $(LIBHB.build/)hb.lib
 
 LIBHB.dll.libs = $(foreach n, \
-        ass avformat avfilter avcodec avutil swresample dvdnav dvdread \
+        ass avformat avfilter avcodec avutil swresample cpuinfo dvdnav dvdread \
         freetype mp3lame swscale vpx theora vorbis vorbisenc ogg x264 \
         bluray jansson harfbuzz opus speex dav1d turbojpeg zimg SvtAv1Enc, \
         $(CONTRIB.build/)lib/lib$(n).a )
@@ -187,7 +187,11 @@ ifeq ($(HAS.dlfcn),1)
     LIBHB.GCC.l += dl
 endif
 LIBHB.out += $(LIBHB.dll) $(LIBHB.lib)
-
+ifeq ($(HOST.machine),$(filter $(HOST.machine),aarch64))
+    ifneq (none,$(GCC.g))
+        LIBHB.out += $(LIBHB.pdb)
+    endif
+endif
 endif
 
 ###############################################################################
diff -Naupr a/libhb/motion_metric.c b/libhb/motion_metric.c
--- a/libhb/motion_metric.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/motion_metric.c	2025-03-31 11:55:35.245884363 +0200
@@ -1,6 +1,6 @@
 /* motionmetric.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/mt_frame_filter.c b/libhb/mt_frame_filter.c
--- a/libhb/mt_frame_filter.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/mt_frame_filter.c	2025-03-31 11:55:35.246884345 +0200
@@ -1,6 +1,6 @@
 /* mt_frame_filter.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/muxavformat.c b/libhb/muxavformat.c
--- a/libhb/muxavformat.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/muxavformat.c	2025-03-31 11:55:35.246884345 +0200
@@ -1,6 +1,6 @@
 /* muxavformat.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -13,7 +13,6 @@
 #include "libavutil/avstring.h"
 
 #include "handbrake/handbrake.h"
-#include "handbrake/ssautil.h"
 #include "handbrake/lang.h"
 #include "handbrake/hbffmpeg.h"
 
@@ -26,7 +25,8 @@ struct hb_mux_data_s
         MUX_TYPE_SUBTITLE
     } type;
 
-    AVStream    *st;
+    AVFormatContext * oc;
+    AVStream        * st;
 
     int64_t  duration;
 
@@ -36,7 +36,6 @@ struct hb_mux_data_s
     int16_t  current_chapter;
 
     AVBSFContext            * bitstream_context;
-    hb_tx3g_style_context_t * tx3g;
 };
 
 struct hb_mux_object_s
@@ -58,6 +57,7 @@ enum
 {
     META_HB,
     META_MUX_MP4,
+    META_MUX_MOV,
     META_MUX_MKV,
     META_MUX_WEBM,
     META_MUX_LAST
@@ -65,16 +65,77 @@ enum
 
 const char *metadata_keys[][META_MUX_LAST] =
 {
-    {"Name",            "title",        "TITLE"},
-    {"Artist",          "artist",       "ARTIST"},
-    {"AlbumArtist",     "album_artist", "DIRECTOR"},
-    {"Composer",        "composer",     "COMPOSER"},
-    {"ReleaseDate",     "date",         "DATE_RELEASED"},
-    {"Comment",         "comment",      "SUMMARY"},
-    {"Album",           "album",        NULL},
-    {"Genre",           "genre",        "GENRE"},
-    {"Description",     "description",  "DESCRIPTION"},
-    {"LongDescription", "synopsis",     "SYNOPSIS"},
+    {"Name",                "title",                  "com.apple.quicktime.displayname",      "TITLE"},
+    {"Artist",              "artist",                 "com.apple.quicktime.artist",           "ARTIST"},
+    {"AlbumArtist",         "album_artist",           NULL,                                   NULL},
+    {"Album",               "album",                  "com.apple.quicktime.album",            NULL},
+    {"Genre",               "genre",                  "com.apple.quicktime.genre",            "GENRE"},
+    {"ReleaseDate",         "date",                   "com.apple.quicktime.creationdate",     "DATE_RELEASED"},
+    {"CreationTime",        "creation_time",          NULL,                                   NULL},
+    {"Track",               "track",                  "com.apple.quicktime.track",            NULL},
+    {"Show",                "show",                   NULL,                                   NULL},
+    {"Network",             "network",                NULL,                                   NULL},
+    {"Episode ID",          "episode_id",             NULL,                                   NULL},
+    {"Episode Sort",        "episode_sort",           NULL,                                   NULL},
+    {"Season Number",       "season_number",          NULL,                                   NULL},
+    {"Rating",              "rating",                 NULL,                                   NULL},
+    {"Media Type",          "media_type",             NULL,                                   NULL},
+    {"HD Video",            "hd_video",               NULL,                                   NULL},
+    {"Description",         "description",            "com.apple.quicktime.description",      "DESCRIPTION"},
+    {"LongDescription",     "synopsis",               "com.apple.quicktime.information",      "SYNOPSIS"},
+    {"SeriesDescription",   "series_description",     NULL,                                   NULL},
+    {"Comment",             "comment",                "com.apple.quicktime.comment",          "SUMMARY"},
+    {"Grouping",            "grouping",               NULL,                                   NULL},
+    {"Compilation",         "compilation",            NULL,                                   NULL},
+    {"Tempo",               "tmpo",                   NULL,                                   "BPM"},
+
+    {"Subtitle",            "subtitle",               NULL,                                   "SUBTITLE"},
+    {"SongDescription",     "song_description",       NULL,                                   NULL},
+    {"Director",            "director",               "com.apple.quicktime.director",         "DIRECTOR"},
+    {"ArtDirector",         "art_director",           NULL,                                   "DIRECTOR_OF_PHOTOGRAPHY"},
+    {"Composer",            "composer",               "com.apple.quicktime.composer",         "COMPOSER"},
+    {"Arranger",            "arranger",               "com.apple.quicktime.arranger",         "ARRANGER"},
+    {"Author",              "author",                 "com.apple.quicktime.author",           "WRITTEN_BY"},
+    {"Acknowledgement",     "acknowledgement",        NULL,                                   NULL},
+    {"Conductor",           "conductor",              NULL,                                   "CONDUCTOR"},
+    {"Lyrics",              "lyrics",                 NULL,                                   "LYRICS"},
+    {"Keywords",            "keywords",               "com.apple.quicktime.keywords",         "KEYWORDS"},
+    {"Copyright",           "copyright",              "com.apple.quicktime.copyright",        "COPYRIGHT"},
+
+    {"WorkName",            "work_name",              NULL,                                   NULL},
+    {"MovementName",        "movement_name",          NULL,                                   NULL},
+    {"MovementNumber",      "movement_number",        NULL,                                   NULL},
+    {"MovementShow",        "movement_count",         NULL,                                   NULL},
+    {"ShowWorkAndMovement", "show_work_and_movement", NULL,                                   NULL},
+
+    {"LinearNotes",         "linear_notes",           NULL,                                   NULL},
+    {"RecordCompany",       "make",                   "com.apple.quicktime.make",             NULL},
+    {"OriginalArtist",      "original_artist",        "com.apple.quicktime.originalartist",   NULL},
+    {"PhonogramRights",     "phonogram_rights",       "com.apple.quicktime.phonogramrights",  NULL},
+    {"Producer",            "producer",               "com.apple.quicktime.producer",         "PRODUCER"},
+    {"Performers",          "performers",             "com.apple.quicktime.performer",        NULL},
+    {"Publisher",           "publisher",              "com.apple.quicktime.publisher",        "PUBLISHER"},
+    {"SoundEngineer",       "sound_engineer",         NULL,                                   "SOUND_ENGINEER"},
+    {"Soloist",             "soloist",                NULL,                                   "LEAD_PERFORMER"},
+    {"Credits",             "original_source",        "com.apple.quicktime.credits",          NULL},
+    {"Thanks",              "thanks",                 NULL,                                   "THANKS_TO"},
+    {"OnlineExtra",         "URL",                    NULL,                                   NULL},
+    {"ExecutiveProducer",   "executive_producer",     NULL,                                   "EXECUTIVE_PRODUCER"},
+
+    {"iTunesU",             "itunes_u",               NULL,                                   NULL},
+    {"Podcast",             "podcast",                NULL,                                   NULL},
+    {"Category",            "category",               NULL,                                   NULL},
+
+    {"ContentID",           "content_id",             NULL,                                   NULL},
+    {"ArtistID",            "artist_id",              NULL,                                   NULL},
+    {"PlaylistID",          "playlist_id",            NULL,                                   NULL},
+    {"GenreID",             "genre_id",               NULL,                                   NULL},
+    {"ComposerID",          "composer_id",            NULL,                                   NULL},
+    {"XID",                 "xid",                    NULL,                                   NULL},
+
+    {"iTunEXTC",            "iTunEXTC",               NULL,                                   NULL},
+    {"iTunMOVI",            "iTunMOVI",               NULL,                                   NULL},
+    {"Location",            "location",               "com.apple.quicktime.location.ISO6709", NULL},
     {NULL}
 };
 
@@ -134,6 +195,26 @@ static char* lookup_lang_code(int mux, c
     return out;
 }
 
+const char * get_subtitle_muxer(int source)
+{
+    switch (source)
+    {
+        case CC608SUB:
+        case CC708SUB:
+        case SSASUB:
+        case IMPORTSSA:
+            return "ass";
+        case UTF8SUB:
+        case TX3GSUB:
+        case IMPORTSRT:
+            return "srt";
+        case PGSSUB:
+            return "sup";
+    }
+
+    return NULL;
+}
+
 static int set_extradata(hb_data_t *extradata, uint8_t **priv_data, int *priv_size)
 {
     if (*priv_data)
@@ -284,10 +365,10 @@ static int avformatInit( hb_mux_object_t
     {
         case HB_VCODEC_X264_8BIT:
         case HB_VCODEC_X264_10BIT:
-        case HB_VCODEC_QSV_H264:
         case HB_VCODEC_VT_H264:
         case HB_VCODEC_FFMPEG_VCE_H264:
         case HB_VCODEC_FFMPEG_NVENC_H264:
+        case HB_VCODEC_FFMPEG_QSV_H264:
         case HB_VCODEC_FFMPEG_MF_H264:
             track->st->codecpar->codec_id = AV_CODEC_ID_H264;
             if (job->mux == HB_MUX_AV_MP4 && job->inline_parameter_sets)
@@ -322,41 +403,12 @@ static int avformatInit( hb_mux_object_t
         case HB_VCODEC_FFMPEG_NVENC_AV1:
         case HB_VCODEC_FFMPEG_NVENC_AV1_10BIT:
         case HB_VCODEC_FFMPEG_VCE_AV1:
+        case HB_VCODEC_FFMPEG_QSV_AV1:
+        case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
         case HB_VCODEC_FFMPEG_MF_AV1:
             track->st->codecpar->codec_id = AV_CODEC_ID_AV1;
             break;
 
-        case HB_VCODEC_QSV_AV1_10BIT:
-        case HB_VCODEC_QSV_AV1:
-        {
-            const AVBitStreamFilter  *bsf;
-            AVBSFContext             *ctx;
-            int                       ret;
-
-            track->st->codecpar->codec_id = AV_CODEC_ID_AV1;
-
-            bsf = av_bsf_get_by_name("extract_extradata");
-            ret = av_bsf_alloc(bsf, &ctx);
-            if (ret < 0)
-            {
-                hb_error("AV1 bitstream filter: alloc failure");
-                goto error;
-            }
-
-            track->bitstream_context = ctx;
-            if (track->bitstream_context != NULL)
-            {
-                avcodec_parameters_copy(track->bitstream_context->par_in,
-                                       track->st->codecpar);
-                ret = av_bsf_init(track->bitstream_context);
-                if (ret < 0)
-                {
-                    hb_error("AV1 bitstream filter: init failure");
-                    goto error;
-                }
-            }
-        } break;
-
         case HB_VCODEC_THEORA:
             track->st->codecpar->codec_id = AV_CODEC_ID_THEORA;
             break;
@@ -365,14 +417,14 @@ static int avformatInit( hb_mux_object_t
         case HB_VCODEC_X265_10BIT:
         case HB_VCODEC_X265_12BIT:
         case HB_VCODEC_X265_16BIT:
-        case HB_VCODEC_QSV_H265:
-        case HB_VCODEC_QSV_H265_10BIT:
         case HB_VCODEC_VT_H265:
         case HB_VCODEC_VT_H265_10BIT:
         case HB_VCODEC_FFMPEG_VCE_H265:
         case HB_VCODEC_FFMPEG_VCE_H265_10BIT:
         case HB_VCODEC_FFMPEG_NVENC_H265:
         case HB_VCODEC_FFMPEG_NVENC_H265_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_H265:
+        case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
         case HB_VCODEC_FFMPEG_MF_H265:
             track->st->codecpar->codec_id  = AV_CODEC_ID_HEVC;
             if (job->mux == HB_MUX_AV_MP4 && job->inline_parameter_sets)
@@ -461,7 +513,7 @@ static int avformatInit( hb_mux_object_t
                                 sizeof(AVAmbientViewingEnvironment), 0);
     }
 
-    if (job->passthru_dynamic_hdr_metadata & DOVI)
+    if (job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_DOVI)
     {
         if (job->dovi.dv_profile == 5 && job->mux == HB_MUX_AV_MP4)
         {
@@ -766,21 +818,6 @@ static int avformatInit( hb_mux_object_t
         }
     }
 
-    char * subidx_fmt =
-        "size: %dx%d\n"
-        "org: %d, %d\n"
-        "scale: 100%%, 100%%\n"
-        "alpha: 100%%\n"
-        "smooth: OFF\n"
-        "fadein/out: 50, 50\n"
-        "align: OFF at LEFT TOP\n"
-        "time offset: 0\n"
-        "forced subs: %s\n"
-        "palette: %06x, %06x, %06x, %06x, %06x, %06x, "
-        "%06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x, %06x\n"
-        "custom colors: OFF, tridx: 0000, "
-        "colors: 000000, 000000, 000000, 000000\n";
-
     int subtitle_default = -1;
     for( ii = 0; ii < hb_list_count( job->list_subtitle ); ii++ )
     {
@@ -804,10 +841,9 @@ static int avformatInit( hb_mux_object_t
 
     for( ii = 0; ii < hb_list_count( job->list_subtitle ); ii++ )
     {
-        hb_subtitle_t * subtitle;
-        uint32_t        rgb[16];
-        char            subidx[2048];
-        int             len;
+        hb_subtitle_t   * subtitle;
+        AVFormatContext * oc;
+        const char      * subtitle_muxer_name = NULL;
 
         subtitle = hb_list_item( job->list_subtitle, ii );
         if (subtitle->config.dest != PASSTHRUSUB)
@@ -816,8 +852,39 @@ static int avformatInit( hb_mux_object_t
         track = m->tracks[m->ntracks++] = calloc(1, sizeof( hb_mux_data_t ) );
         subtitle->mux_data = track;
 
+        if (subtitle->config.external_filename != NULL)
+        {
+            subtitle_muxer_name = get_subtitle_muxer(subtitle->source);
+            if (subtitle_muxer_name == NULL)
+            {
+                hb_error( "No muxer for subtitle source %d", subtitle->source );
+                goto error;
+            }
+            ret = avformat_alloc_output_context2(&track->oc, NULL,
+                subtitle_muxer_name, subtitle->config.external_filename);
+            if (ret < 0)
+            {
+                hb_error( "Could not initialize subtitle avformat context." );
+                goto error;
+            }
+
+            oc = track->oc;
+            ret = avio_open2(&oc->pb, subtitle->config.external_filename,
+                             AVIO_FLAG_WRITE, &track->oc->interrupt_callback,
+                             NULL);
+            if( ret < 0 )
+            {
+                hb_error( "subtitle avio_open2 failed, errno %d", ret);
+                goto error;
+            }
+        }
+        else
+        {
+            oc = m->oc;
+        }
+
         track->type = MUX_TYPE_SUBTITLE;
-        track->st = avformat_new_stream(m->oc, NULL);
+        track->st = avformat_new_stream(oc, NULL);
         if (track->st == NULL)
         {
             hb_error("Could not initialize subtitle stream");
@@ -829,33 +896,13 @@ static int avformatInit( hb_mux_object_t
         track->st->codecpar->width = subtitle->width;
         track->st->codecpar->height = subtitle->height;
 
-        uint8_t *priv_data = NULL;
-        size_t   priv_size = 0;
+        int need_extradata = 0;
         switch (subtitle->source)
         {
             case VOBSUB:
             {
-                int jj;
                 track->st->codecpar->codec_id = AV_CODEC_ID_DVD_SUBTITLE;
-
-                for (jj = 0; jj < 16; jj++)
-                    rgb[jj] = hb_yuv2rgb(subtitle->palette[jj]);
-                len = snprintf(subidx, 2048, subidx_fmt,
-                        subtitle->width, subtitle->height,
-                        0, 0, "OFF",
-                        rgb[0], rgb[1], rgb[2], rgb[3],
-                        rgb[4], rgb[5], rgb[6], rgb[7],
-                        rgb[8], rgb[9], rgb[10], rgb[11],
-                        rgb[12], rgb[13], rgb[14], rgb[15]);
-
-                priv_size = len + 1;
-                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-                if (priv_data == NULL)
-                {
-                    hb_error("VOBSUB extradata: malloc failure");
-                    goto error;
-                }
-                memcpy(priv_data, subidx, priv_size);
+                need_extradata = 1;
             } break;
 
             case PGSSUB:
@@ -866,107 +913,56 @@ static int avformatInit( hb_mux_object_t
             case DVBSUB:
             {
                 track->st->codecpar->codec_id = AV_CODEC_ID_DVB_SUBTITLE;
-                if (subtitle->extradata != NULL && subtitle->extradata->size)
-                {
-                    priv_size = subtitle->extradata->size;
-                    priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-                    memcpy(priv_data, subtitle->extradata->bytes, priv_size);
-                }
+                need_extradata = 1;
             } break;
 
             case CC608SUB:
             case CC708SUB:
-            case TX3GSUB:
-            case UTF8SUB:
             case SSASUB:
-            case IMPORTSRT:
             case IMPORTSSA:
             {
-                if (job->mux == HB_MUX_AV_MP4)
+                if (job->mux == HB_MUX_AV_MP4 &&
+                    subtitle->config.external_filename == NULL)
                 {
                     track->st->codecpar->codec_id = AV_CODEC_ID_MOV_TEXT;
-                    track->tx3g = hb_tx3g_style_init(
-                                job->height, (char*)subtitle->extradata);
                 }
                 else
                 {
                     track->st->codecpar->codec_id = AV_CODEC_ID_ASS;
                     need_fonts = 1;
+                }
+                need_extradata = 1;
+            } break;
 
-                    if (subtitle->extradata && subtitle->extradata->size)
-                    {
-                        priv_size = subtitle->extradata->size;
-                        priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-                        if (priv_data == NULL)
-                        {
-                            hb_error("SSA extradata: malloc failure");
-                            goto error;
-                        }
-                        memcpy(priv_data, subtitle->extradata->bytes, priv_size);
-                    }
+            case TX3GSUB:
+            case UTF8SUB:
+            case IMPORTSRT:
+            {
+                if (job->mux == HB_MUX_AV_MP4 &&
+                    subtitle->config.external_filename == NULL)
+                {
+                    track->st->codecpar->codec_id = AV_CODEC_ID_MOV_TEXT;
+                }
+                else
+                {
+                    track->st->codecpar->codec_id = AV_CODEC_ID_SUBRIP;
                 }
+                need_extradata = 1;
             } break;
 
             default:
                 continue;
         }
-        if (track->st->codecpar->codec_id == AV_CODEC_ID_MOV_TEXT)
+
+        if (need_extradata)
         {
-            // Build codec extradata for tx3g.
-            // If we were using a libav codec to generate this data
-            // this would (or should) be done for us.
-            uint8_t properties[] = {
-                0x00, 0x00, 0x00, 0x00,     // Display Flags
-                0x01,                       // Horiz. Justification
-                0xff,                       // Vert. Justification
-                0x00, 0x00, 0x00, 0xff,     // Bg color
-                0x00, 0x00, 0x00, 0x00,     // Default text box
-                0x00, 0x00, 0x00, 0x00,
-                0x00, 0x00, 0x00, 0x00,     // Reserved
-                0x00, 0x01,                 // Font ID
-                0x00,                       // Font face
-                0x18,                       // Font size
-                0xff, 0xff, 0xff, 0xff,     // Fg color
-                // Font table:
-                0x00, 0x00, 0x00, 0x12,     // Font table size
-                'f','t','a','b',            // Tag
-                0x00, 0x01,                 // Count
-                0x00, 0x01,                 // Font ID
-                0x05,                       // Font name length
-                'A','r','i','a','l'         // Font name
-            };
-
-            int width, height, font_size;
-            width     = job->width * job->par.num / job->par.den;
-            font_size = 0.05 * job->height;
-            if (font_size < 12)
-            {
-                font_size = 12;
-            }
-            else if (font_size > 255)
-            {
-                font_size = 255;
-            }
-            properties[25] = font_size;
-            height = 3 * font_size;
-            track->st->codecpar->width  = width;
-            track->st->codecpar->height = height;
-            properties[14] = height >> 8;
-            properties[15] = height & 0xff;
-            properties[16] = width >> 8;
-            properties[17] = width & 0xff;
-
-            priv_size = sizeof(properties);
-            priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
-            if (priv_data == NULL)
+            if (set_extradata(subtitle->extradata,
+                              &track->st->codecpar->extradata,
+                              &track->st->codecpar->extradata_size))
             {
-                hb_error("TX3G extradata: malloc failure");
                 goto error;
             }
-            memcpy(priv_data, properties, priv_size);
         }
-        track->st->codecpar->extradata = priv_data;
-        track->st->codecpar->extradata_size = priv_size;
 
         if (ii == subtitle_default)
         {
@@ -1043,43 +1039,132 @@ static int avformatInit( hb_mux_object_t
         }
     }
 
-    if( job->metadata && job->metadata->dict )
+    if (job->metadata)
     {
         hb_deep_log(2, "Writing Metadata to output file...");
-        hb_dict_iter_t iter = hb_dict_iter_init(job->metadata->dict);
 
-        while (iter != HB_DICT_ITER_DONE)
+        if (job->metadata->dict)
         {
-            const char * key;
-            hb_value_t * val;
+            hb_dict_iter_t iter = hb_dict_iter_init(job->metadata->dict);
 
-            hb_dict_iter_next_ex(job->metadata->dict, &iter, &key, &val);
-            if (key != NULL && val != NULL)
+            while (iter != HB_DICT_ITER_DONE)
             {
-                const char * str = hb_value_get_string(val);
+                const char *key;
+                hb_value_t *val;
 
-                if (str != NULL)
+                hb_dict_iter_next_ex(job->metadata->dict, &iter, &key, &val);
+                if (key != NULL && val != NULL)
                 {
-                    const char * mux_key = lookup_meta_mux_key(meta_mux, key);
+                    const char *str = hb_value_get_string(val);
 
-                    if (mux_key != NULL)
+                    if (str != NULL)
                     {
-                        av_dict_set(&m->oc->metadata, mux_key, str, 0);
+                        const char *mux_key = lookup_meta_mux_key(meta_mux, key);
+
+                        if (mux_key != NULL)
+                        {
+                            av_dict_set(&m->oc->metadata, mux_key, str, 0);
+                        }
                     }
                 }
             }
+
+            if (job->mux == HB_MUX_AV_MP4)
+            {
+                // Set the location tag language to undefined,
+                // Apple software seems to require it
+                hb_value_t *location = hb_dict_get(job->metadata->dict, "Location");
+                if (location)
+                {
+                    char *str = hb_value_get_string_xform(location);
+                    av_dict_set(&m->oc->metadata, "location-und", str, 0);
+                    free(str);
+                }
+            }
         }
+
+        if (job->metadata->list_coverart)
+        {
+            hb_list_t *list_coverart = job->metadata->list_coverart;
+            for (int ii = 0; ii < hb_list_count(list_coverart); ii++)
+            {
+                hb_coverart_t *art = hb_list_item(list_coverart, ii);
+
+                enum AVCodecID codec_id = AV_CODEC_ID_NONE;
+                const char *mimetype;
+                const char *filename;
+
+                switch (art->type)
+                {
+                    case HB_ART_PNG:
+                        codec_id = AV_CODEC_ID_PNG;
+                        mimetype = "image/png";
+                        filename = art->name ? art->name : "cover.png";
+                        break;
+                    case HB_ART_JPEG:
+                        codec_id = AV_CODEC_ID_MJPEG;
+                        mimetype = "image/jpeg";
+                        filename = art->name ? art->name : "cover.jpg";
+                        break;
+                    default:
+                        break;
+                }
+
+                if (codec_id != AV_CODEC_ID_NONE)
+                {
+                    AVStream *st = avformat_new_stream(m->oc, NULL);
+                    if (st == NULL)
+                    {
+                        hb_error("Could not initialize cover art stream");
+                        goto error;
+                    }
+
+                    if (job->mux == HB_MUX_AV_MP4)
+                    {
+                        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
+                        st->codecpar->codec_id = codec_id;
+                        st->codecpar->width  = 640;
+                        st->codecpar->height = 360;
+                        st->disposition = AV_DISPOSITION_ATTACHED_PIC;
+                    }
+                    else
+                    {
+                        st->codecpar->codec_type = AVMEDIA_TYPE_ATTACHMENT;
+                        st->codecpar->codec_id = codec_id;
+
+                        av_dict_set(&st->metadata, "mimetype", mimetype, 0);
+                        av_dict_set(&st->metadata, "filename", filename, 0);
+
+                        size_t   priv_size = art->size;
+                        uint8_t *priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
+                        if (priv_data == NULL)
+                        {
+                            hb_error("Cover art extradata: malloc failure");
+                            goto error;
+                        }
+                        memcpy(priv_data, art->data, priv_size);
+
+                        st->codecpar->extradata = priv_data;
+                        st->codecpar->extradata_size = priv_size;
+                    }
+                }
+            }
+        }
+    }
+
+    if (av_dict_get(m->oc->metadata, "creation_time", NULL, 0) == NULL)
+    {
+        time_t now = time(NULL);
+        struct tm *now_utc = gmtime(&now);
+        char now_8601[24];
+        strftime(now_8601, sizeof(now_8601), "%Y-%m-%dT%H:%M:%SZ", now_utc);
+        av_dict_set(&m->oc->metadata, "creation_time", now_8601, 0);
     }
 
     char tool_string[80];
     snprintf(tool_string, sizeof(tool_string), "HandBrake %s %i",
              HB_PROJECT_VERSION, HB_PROJECT_BUILD);
     av_dict_set(&m->oc->metadata, "encoding_tool", tool_string, 0);
-    time_t now = time(NULL);
-    struct tm * now_utc = gmtime(&now);
-    char now_8601[24];
-    strftime(now_8601, sizeof(now_8601), "%Y-%m-%dT%H:%M:%SZ", now_utc);
-    av_dict_set(&m->oc->metadata, "creation_time", now_8601, 0);
 
     ret = avformat_write_header(m->oc, &av_opts);
     if( ret < 0 )
@@ -1095,9 +1180,29 @@ static int avformatInit( hb_mux_object_t
     }
     av_dict_free( &av_opts );
 
+    for (ii = 0; ii < m->ntracks; ii++)
+    {
+        if (m->tracks[ii]->oc != NULL)
+        {
+            ret = avformat_write_header(m->tracks[ii]->oc, NULL);
+            if( ret < 0 )
+            {
+                hb_error( "muxavformat: avformat_write_header external track failed!");
+                goto error;
+            }
+        }
+    }
+
     return 0;
 
 error:
+    for (ii = 0; ii < m->ntracks; ii++)
+    {
+        if (m->tracks[ii]->oc != NULL)
+        {
+            avformat_free_context(m->tracks[ii]->oc);
+        }
+    }
     av_dict_free(&av_opts);
     free(job->mux_data);
     job->mux_data = NULL;
@@ -1147,10 +1252,12 @@ static int add_chapter(hb_mux_object_t *
 
 static int avformatMux(hb_mux_object_t *m, hb_mux_data_t *track, hb_buffer_t *buf)
 {
-    int64_t    dts, pts, duration = AV_NOPTS_VALUE;
-    hb_job_t * job     = m->job;
-    uint8_t  * sub_out = NULL;
+    int64_t           dts, pts, duration = AV_NOPTS_VALUE;
+    hb_job_t        * job     = m->job;
+    uint8_t         * sub_out = NULL;
+    AVFormatContext * oc;
 
+    oc = track->oc != NULL ? track->oc : m->oc;
     if (track->type == MUX_TYPE_VIDEO && (job->mux & HB_MUX_MASK_MP4))
     {
         // compute dts duration for MP4 files
@@ -1163,7 +1270,8 @@ static int avformatMux(hb_mux_object_t *
     }
     if (buf == NULL)
     {
-        if (job->mux == HB_MUX_AV_MP4 && track->type == MUX_TYPE_SUBTITLE)
+        if (job->mux == HB_MUX_AV_MP4 &&
+            track->oc == NULL && track->type == MUX_TYPE_SUBTITLE)
         {
             // Write a final "empty" subtitle to terminate the last
             // subtitle that was written
@@ -1317,7 +1425,7 @@ static int avformatMux(hb_mux_object_t *
 
         case MUX_TYPE_SUBTITLE:
         {
-            if (job->mux == HB_MUX_AV_MP4)
+            if (job->mux == HB_MUX_AV_MP4 && track->oc == NULL)
             {
                 /* Write an empty sample */
                 if ( track->duration < pts )
@@ -1343,41 +1451,6 @@ static int avformatMux(hb_mux_object_t *
                         return -1;
                     }
                 }
-                if (track->st->codecpar->codec_id == AV_CODEC_ID_MOV_TEXT)
-                {
-                    uint8_t  * styleatom;
-                    uint16_t   stylesize = 0;
-                    uint8_t  * buffer;
-                    uint16_t   buffersize = 0;
-
-                    /*
-                     * Copy the subtitle into buffer stripping markup and
-                     * creating style atoms for them.
-                     */
-                    hb_muxmp4_process_subtitle_style(
-                        track->tx3g, buf->data, &buffer,
-                        &styleatom, &stylesize);
-
-                    if (buffer != NULL)
-                    {
-                        buffersize = strlen((char*)buffer);
-                        if (styleatom == NULL)
-                        {
-                            stylesize = 0;
-                        }
-                        sub_out = malloc(2 + buffersize + stylesize);
-
-                        /* Write the subtitle sample */
-                        memcpy(sub_out + 2, buffer, buffersize);
-                        memcpy(sub_out + 2 + buffersize, styleatom, stylesize);
-                        sub_out[0] = (buffersize >> 8) & 0xff;
-                        sub_out[1] = buffersize & 0xff;
-                        m->pkt->data = sub_out;
-                        m->pkt->size = buffersize + stylesize + 2;
-                    }
-                    free(buffer);
-                    free(styleatom);
-                }
             }
             if (m->pkt->data == NULL)
             {
@@ -1418,7 +1491,7 @@ static int avformatMux(hb_mux_object_t *
     }
 
     m->pkt->stream_index = track->st->index;
-    int ret = av_interleaved_write_frame(m->oc, m->pkt);
+    int ret = av_interleaved_write_frame(oc, m->pkt);
     av_packet_unref(m->pkt);
     if (sub_out != NULL)
     {
@@ -1427,10 +1500,10 @@ static int avformatMux(hb_mux_object_t *
     // Many avformat muxer functions do not check the error status
     // of the AVIOContext.  So we need to check it ourselves to detect
     // write errors (like disk full condition).
-    if (ret < 0 || m->oc->pb->error != 0)
+    if (ret < 0 || oc->pb->error != 0)
     {
         char errstr[64];
-        av_strerror(ret < 0 ? ret : m->oc->pb->error, errstr, sizeof(errstr));
+        av_strerror(ret < 0 ? ret : oc->pb->error, errstr, sizeof(errstr));
         hb_error("avformatMux: track %d, av_interleaved_write_frame failed with error '%s'",
                  track->st->index, errstr);
         *job->done_error = HB_ERROR_UNKNOWN;
@@ -1465,10 +1538,6 @@ static int avformatEnd(hb_mux_object_t *
         {
             av_bsf_free(&m->tracks[ii]->bitstream_context);
         }
-        if (m->tracks[ii]->tx3g)
-        {
-            hb_tx3g_style_close(&m->tracks[ii]->tx3g);
-        }
     }
 
     if (job->chapter_markers)
@@ -1515,11 +1584,38 @@ static int avformatEnd(hb_mux_object_t *
         }
     }
 
+    // Write MP4 cover art
+    if (job->mux == HB_MUX_AV_MP4 && job->metadata)
+    {
+        hb_list_t *list_coverart = job->metadata->list_coverart;
+        for (int ii = 0; ii < hb_list_count(list_coverart); ii++)
+        {
+            hb_coverart_t *art = hb_list_item(list_coverart, ii);
+            m->pkt->data = art->data;
+            m->pkt->size = art->size;
+            m->pkt->stream_index = m->ntracks + ii;
+            av_interleaved_write_frame(m->oc, m->pkt);
+            av_packet_unref(m->pkt);
+        }
+    }
+
     av_write_trailer(m->oc);
     avio_close(m->oc->pb);
     avformat_free_context(m->oc);
     av_packet_free(&m->pkt);
     av_packet_free(&m->empty_pkt);
+    m->oc = NULL;
+
+    for (ii = 0; ii < m->ntracks; ii++)
+    {
+        if (m->tracks[ii]->oc != NULL)
+        {
+            av_write_trailer(m->tracks[ii]->oc);
+            avio_close(m->tracks[ii]->oc->pb);
+            avformat_free_context(m->tracks[ii]->oc);
+            m->tracks[ii]->oc = NULL;
+        }
+    }
 
     for (int i = 0; i < m->ntracks; i++)
     {
@@ -1529,7 +1625,6 @@ static int avformatEnd(hb_mux_object_t *
     }
 
     free(m->tracks);
-    m->oc = NULL;
 
     return 0;
 }
diff -Naupr a/libhb/muxcommon.c b/libhb/muxcommon.c
--- a/libhb/muxcommon.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/muxcommon.c	2025-03-31 11:55:35.246884345 +0200
@@ -1,6 +1,6 @@
 /* muxcommon.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -578,6 +578,8 @@ static void muxClose( hb_work_object_t *
                         frames_total );
             }
         }
+
+        hb_system_backup_set_excluded(job->file, 0);
     }
 
     for (i = 0; i < mux->ntracks; ++i)
@@ -686,11 +688,12 @@ static int muxInit( hb_work_object_t * m
         if( mux->m )
         {
             mux->m->init( mux->m );
+            hb_system_backup_set_excluded(job->file, 1);
         }
     }
 
     /* Initialize the work objects that will receive fifo data */
-    muxer->fifo_in = job->fifo_mpeg4;
+    muxer->fifo_in = job->fifo_out;
     if (add_mux_track(mux, job->mux_data, 1))
     {
         goto fail;
diff -Naupr a/libhb/nal_units.c b/libhb/nal_units.c
--- a/libhb/nal_units.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/nal_units.c	2025-03-31 11:55:35.246884345 +0200
@@ -1,6 +1,6 @@
 /* nal_units.c
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * Copyright (c) FFmpeg
  * This file is part of the HandBrake source code.
  * Homepage: <http://handbrake.fr/>.
@@ -481,7 +481,7 @@ size_t hb_sei_unit_write_isomp4(const ui
 
 hb_buffer_t * hb_isomp4_hevc_nal_bitstream_insert_payloads(const uint8_t *data,
                                                            const size_t size,
-                                                           const hb_sei_t *seis,
+                                                                 hb_sei_t *seis,
                                                            const size_t sei_count,
                                                            const hb_nal_t *nals,
                                                            const size_t nal_count,
@@ -492,9 +492,6 @@ hb_buffer_t * hb_isomp4_hevc_nal_bitstre
     uint8_t *out_data;
     size_t out_size = 0, buf_size;
 
-    size_t sei_nalu_size[4];
-    uint8_t sei_written[4];
-
     if ((seis == NULL || sei_count == 0) &&
         (nals == NULL || nal_count == 0))
     {
@@ -509,11 +506,12 @@ hb_buffer_t * hb_isomp4_hevc_nal_bitstre
 
     for (int i = 0; i < sei_count; i++)
     {
-        size_t msg_size = get_sei_msg_bytes(seis[i].payload, seis[i].payload_size, seis[i].type);
-        sei_nalu_size[i] = nal_length_size + 2 + msg_size + 1;
-        sei_written[i] = 0;
+        hb_sei_t *sei = &seis[i];
+        size_t msg_size = get_sei_msg_bytes(sei->payload, sei->payload_size, sei->type);
+        sei->nalu_size = nal_length_size + 2 + msg_size + 1;
+        sei->written = 0;
 
-        out_size += sei_nalu_size[i];
+        out_size += sei->nalu_size;
     }
 
     for (int i = 0; i < nal_count; i++)
@@ -542,11 +540,12 @@ hb_buffer_t * hb_isomp4_hevc_nal_bitstre
 
         for (int i = 0; i < sei_count; i++)
         {
-            if (!sei_written[i] && is_post_hevc_sei_nal_type(nal_type))
+            hb_sei_t *sei = &seis[i];
+            if (!sei->written && is_post_hevc_sei_nal_type(nal_type))
             {
-                out_data += hb_sei_unit_write_isomp4(seis[i].payload, seis[i].payload_size, seis[i].type,
-                                                     out_data, sei_nalu_size[i], nal_length_size);
-                sei_written[i] = 1;
+                out_data += hb_sei_unit_write_isomp4(sei->payload, sei->payload_size, sei->type,
+                                                     out_data, sei->nalu_size, nal_length_size);
+                sei->written = 1;
             }
         }
 
diff -Naupr a/libhb/nlmeans.c b/libhb/nlmeans.c
--- a/libhb/nlmeans.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/nlmeans.c	2025-03-31 11:55:35.246884345 +0200
@@ -1,7 +1,7 @@
 /* nlmeans.c
 
    Copyright (c) 2013 Dirk Farin
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/nlmeans_x86.c b/libhb/nlmeans_x86.c
--- a/libhb/nlmeans_x86.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/nlmeans_x86.c	2025-03-31 11:55:35.246884345 +0200
@@ -1,7 +1,7 @@
 /* nlmeans_x86.c
 
    Copyright (c) 2013 Dirk Farin
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/nvenc_common.c b/libhb/nvenc_common.c
--- a/libhb/nvenc_common.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/nvenc_common.c	2025-03-31 11:55:35.246884345 +0200
@@ -1,6 +1,6 @@
 /* nvenc_common.c
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code.
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/pad.c b/libhb/pad.c
--- a/libhb/pad.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/pad.c	2025-03-31 11:55:35.246884345 +0200
@@ -1,6 +1,6 @@
 /* pad.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/param.c b/libhb/param.c
--- a/libhb/param.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/param.c	2025-03-31 11:55:35.246884345 +0200
@@ -1,6 +1,6 @@
 /* param.c
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/platform/macosx/blend_vt.m b/libhb/platform/macosx/blend_vt.m
--- a/libhb/platform/macosx/blend_vt.m	1970-01-01 01:00:00.000000000 +0100
+++ b/libhb/platform/macosx/blend_vt.m	2025-03-31 11:55:35.247884328 +0200
@@ -0,0 +1,320 @@
+/* blend_vt.m
+
+   Copyright (c) 2003-2025 HandBrake Team
+   This file is part of the HandBrake source code
+   Homepage: <http://handbrake.fr/>.
+   It may be used under the terms of the GNU General Public License v2.
+   For full terms see the file COPYING file or visit http://www.gnu.org/licenses/gpl-2.0.html
+ */
+
+#include "handbrake/handbrake.h"
+#include "cv_utils.h"
+#include "metal_utils.h"
+
+extern char hb_blend_vt_metallib_data[];
+extern unsigned int hb_blend_vt_metallib_len;
+
+struct mtl_blend_params
+{
+    uint16_t x;
+    uint16_t y;
+    uint16_t xc;
+    uint16_t yc;
+    uint16_t width;
+    uint16_t height;
+};
+
+struct hb_blend_private_s
+{
+    hb_metal_context_t *mtl;
+
+    id<MTLTexture> overlays[4];
+    id<MTLBuffer> chroma_coeffs;
+
+    const AVPixFmtDescriptor *in_desc;
+    const AVPixFmtDescriptor *overlay_desc;
+
+    uint16_t subw;
+    uint16_t subh;
+    uint16_t overlay_subw;
+    uint16_t overlay_subh;
+};
+
+static int hb_blend_vt_init(hb_blend_object_t *object,
+                            int in_width,
+                            int in_height,
+                            int in_pix_fmt,
+                            int in_chroma_location,
+                            int in_color_range,
+                            int overlay_pix_fmt);
+
+static hb_buffer_t * hb_blend_vt_work(hb_blend_object_t *object,
+                                      hb_buffer_t *in,
+                                      hb_buffer_list_t *overlays,
+                                      int changed);
+
+static void hb_blend_vt_close(hb_blend_object_t *object);
+
+hb_blend_object_t hb_blend_vt =
+{
+    .name  = "Blend (VideoToolbox)",
+    .init  = hb_blend_vt_init,
+    .work  = hb_blend_vt_work,
+    .close = hb_blend_vt_close,
+};
+
+static int hb_blend_vt_init(hb_blend_object_t *object,
+                            int in_width,
+                            int in_height,
+                            int in_pix_fmt,
+                            int in_chroma_location,
+                            int in_color_range,
+                            int overlay_pix_fmt)
+{
+    object->private_data = calloc(sizeof(struct hb_blend_private_s), 1);
+    if (object->private_data == NULL)
+    {
+        hb_error("blend_vt: calloc failed");
+        return -1;
+    }
+    hb_blend_private_t *pv = object->private_data;
+
+    pv->in_desc      = av_pix_fmt_desc_get(in_pix_fmt);
+    pv->overlay_desc = av_pix_fmt_desc_get(overlay_pix_fmt);
+
+    uint16_t depth     = pv->in_desc->comp[0].depth == 8 ? 8 : 16;
+    uint16_t shift     = depth - 8;
+    uint32_t max_value = (1 << depth) - 1;
+
+    pv->subw  = pv->in_desc->log2_chroma_w;
+    pv->subh  = pv->in_desc->log2_chroma_h;
+    pv->overlay_subw = pv->overlay_desc->log2_chroma_w;
+    pv->overlay_subh = pv->overlay_desc->log2_chroma_h;
+
+    bool needs_subsample = (pv->subw != pv->overlay_subw) || (pv->subh != pv->overlay_subh);
+
+    pv->mtl = hb_metal_context_init(hb_blend_vt_metallib_data,
+                                    hb_blend_vt_metallib_len,
+                                    NULL, NULL, sizeof(struct mtl_blend_params),
+                                    in_width, in_height,
+                                    in_pix_fmt, in_color_range);
+    if (pv->mtl == NULL)
+    {
+        hb_error("blend_vt: failed to create Metal device");
+        return -1;
+    }
+
+    uint16_t plane = 0;
+    uint16_t channels = 1;
+    MTLFunctionConstantValues *constant_values = [MTLFunctionConstantValues new];
+
+    [constant_values setConstantValue:&plane            type:MTLDataTypeUShort withName:@"plane"];
+    [constant_values setConstantValue:&channels         type:MTLDataTypeUShort withName:@"channels"];
+    [constant_values setConstantValue:&pv->subw         type:MTLDataTypeUShort withName:@"subw"];
+    [constant_values setConstantValue:&pv->subh         type:MTLDataTypeUShort withName:@"subh"];
+    [constant_values setConstantValue:&pv->overlay_subw type:MTLDataTypeUShort withName:@"osubw"];
+    [constant_values setConstantValue:&pv->overlay_subh type:MTLDataTypeUShort withName:@"osubh"];
+    [constant_values setConstantValue:&shift            type:MTLDataTypeUShort withName:@"shift"];
+    [constant_values setConstantValue:&max_value        type:MTLDataTypeUInt withName:@"maxv"];
+    [constant_values setConstantValue:&needs_subsample  type:MTLDataTypeBool withName:@"subsample"];
+
+    if (hb_metal_add_pipeline(pv->mtl, "blend", constant_values, pv->mtl->pipelines_count))
+    {
+        hb_error("blend_vt: failed to create Metal pipeline");
+        [constant_values release];
+        return -1;
+    }
+
+    plane = 1;
+    channels = 2;
+    [constant_values setConstantValue:&plane    type:MTLDataTypeUShort withName:@"plane"];
+    [constant_values setConstantValue:&channels type:MTLDataTypeUShort withName:@"channels"];
+
+    if (hb_metal_add_pipeline(pv->mtl, "blend", constant_values, pv->mtl->pipelines_count))
+    {
+        hb_error("blend_vt: failed to create Metal pipeline");
+        [constant_values release];
+        return -1;
+    }
+
+    [constant_values release];
+
+    for (int pp = 0; pp < pv->overlay_desc->nb_components; pp++)
+    {
+        int width  = pp == 1 || pp == 2 ? in_width  >> pv->overlay_desc->log2_chroma_w : in_width;
+        int height = pp == 1 || pp == 2 ? in_height >> pv->overlay_desc->log2_chroma_h : in_height;
+
+        MTLTextureDescriptor *descriptor = [[MTLTextureDescriptor alloc] init];
+        descriptor.textureType = MTLTextureType2D;
+        descriptor.pixelFormat = MTLPixelFormatR8Uint;
+        descriptor.width       = width;
+        descriptor.height      = height;
+        descriptor.depth       = 1;
+        descriptor.storageMode = MTLStorageModeManaged;
+        descriptor.usage       = MTLTextureUsageShaderRead;
+
+        pv->overlays[pp] = [pv->mtl->device newTextureWithDescriptor:descriptor];
+
+        [descriptor release];
+    }
+
+    NSUInteger length = 4 * 2 * sizeof(uint32_t);
+    pv->chroma_coeffs = [pv->mtl->device newBufferWithLength:length
+                                                     options:MTLResourceStorageModeManaged];
+    if (pv->chroma_coeffs == nil)
+    {
+        hb_error("blend_vt: failed to create Metal buffers");
+    }
+
+    hb_compute_chroma_smoothing_coefficient(pv->chroma_coeffs.contents,
+                                            in_pix_fmt,
+                                            in_chroma_location);
+    [pv->chroma_coeffs didModifyRange:NSMakeRange(0, length)];
+
+    return 0;
+}
+
+static void upload_overlays(hb_blend_private_t *pv, hb_buffer_list_t *overlays)
+{
+    for (hb_buffer_t *overlay = hb_buffer_list_head(overlays); overlay; overlay = overlay->next)
+    {
+        for (int pp = 0; pp < pv->overlay_desc->nb_components; pp++)
+        {
+            int x = pp == 1 || pp == 2 ? overlay->f.x >> pv->overlay_desc->log2_chroma_w : overlay->f.x;
+            int y = pp == 1 || pp == 2 ? overlay->f.y >> pv->overlay_desc->log2_chroma_h : overlay->f.y;
+
+            [pv->overlays[pp] replaceRegion:MTLRegionMake2D(x, y,
+                                                            overlay->plane[pp].width,
+                                                            overlay->plane[pp].height)
+                                mipmapLevel:0
+                                  withBytes:overlay->plane[pp].data
+                                bytesPerRow:overlay->plane[pp].stride];
+        }
+    }
+}
+
+static void call_kernel(hb_blend_private_t *pv,
+                        id<MTLTexture> dst,
+                        int plane,
+                        int width, int height,
+                        int x, int y)
+{
+    id<MTLCommandBuffer> buffer = pv->mtl->queue.commandBuffer;
+    id<MTLComputeCommandEncoder> encoder = buffer.computeCommandEncoder;
+
+    struct mtl_blend_params *params = (struct mtl_blend_params *)pv->mtl->params_buffer.contents;
+    params->x = x;
+    params->y = y;
+    params->xc = x & ~((1 << pv->subw) - 1);
+    params->yc = y & ~((1 << pv->subh) - 1);
+    params->width  = width;
+    params->height = height;
+
+    [encoder setTexture:dst atIndex:0];
+    for (int i = 0; i < pv->overlay_desc->nb_components; i++)
+    {
+        [encoder setTexture:pv->overlays[i] atIndex:i + 1];
+    }
+    [encoder setBuffer:pv->chroma_coeffs offset:0 atIndex:0];
+    [encoder setBuffer:pv->mtl->params_buffer offset:0 atIndex:1];
+
+    if (plane)
+    {
+        // Chroma plane subsampling can differ
+        // always call the kernel in the destination coordinate space
+        width  >>= (pv->subw - pv->overlay_subw);
+        height >>= (pv->subh - pv->overlay_subh);
+    }
+
+    hb_metal_compute_encoder_dispatch(pv->mtl->device, pv->mtl->pipelines[plane],
+                                      encoder, width, height);
+
+    [encoder endEncoding];
+
+    [buffer commit];
+    [buffer waitUntilCompleted];
+}
+
+void blend(hb_blend_private_t *pv, hb_buffer_t *out, hb_buffer_t *overlay, int changed)
+{
+    CVPixelBufferRef cv_dest = hb_cv_get_pixel_buffer(out);
+
+    if (cv_dest == NULL)
+    {
+        hb_log("blend_vt: extract_buf failed");
+        return;
+    }
+
+    for (int i = 0; i < pv->in_desc->nb_components; i++)
+    {
+        const AVComponentDescriptor *comp = &pv->in_desc->comp[i];
+        if (comp->plane < i)
+        {
+            continue;
+        }
+
+        int channels;
+        const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, 1, &channels);
+        if (format == MTLPixelFormatInvalid)
+        {
+            break;
+        }
+
+        CVMetalTextureRef dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, i, channels, format);
+
+        id<MTLTexture> tex_dest = CVMetalTextureGetTexture(dest);
+        call_kernel(pv, tex_dest, i,
+                    overlay->plane[i].width, overlay->plane[i].height,
+                    overlay->f.x, overlay->f.y);
+        CFRelease(dest);
+    }
+}
+
+static hb_buffer_t * hb_blend_vt_work(hb_blend_object_t *object,
+                                      hb_buffer_t *in,
+                                      hb_buffer_list_t *overlays,
+                                      int changed)
+{
+    hb_blend_private_t *pv = object->private_data;
+    hb_buffer_t *out = in;
+
+    if (hb_buffer_list_count(overlays) == 0)
+    {
+        return out;
+    }
+
+    @autoreleasepool
+    {
+        if (changed)
+        {
+            upload_overlays(pv, overlays);
+        }
+
+        for (hb_buffer_t *overlay = hb_buffer_list_head(overlays); overlay; overlay = overlay->next)
+        {
+            blend(pv, out, overlay, changed);
+        }
+        return out;
+    }
+}
+
+static void hb_blend_vt_close(hb_blend_object_t *metric)
+{
+    hb_blend_private_t *pv = metric->private_data;
+
+    if (pv == NULL)
+    {
+        return;
+    }
+
+    for (int i = 0; i < pv->overlay_desc->nb_components; i++)
+    {
+        [pv->overlays[i] release];
+    }
+
+    [pv->chroma_coeffs release];
+
+    hb_metal_context_close(&pv->mtl);
+
+    free(pv);
+}
diff -Naupr a/libhb/platform/macosx/chroma_smooth_vt.m b/libhb/platform/macosx/chroma_smooth_vt.m
--- a/libhb/platform/macosx/chroma_smooth_vt.m	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/chroma_smooth_vt.m	2025-03-31 11:55:35.247884328 +0200
@@ -1,7 +1,7 @@
 /* unsharp_vt.m
 
    Copyright (c) 2002 Rmi Guyomarch <rguyom at pobox.com>
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -327,14 +327,14 @@ static hb_buffer_t * filter_frame(hb_fil
         }
 
         int channels;
-        const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, &channels);
+        const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, 0, &channels);
         if (format == MTLPixelFormatInvalid)
         {
             goto fail;
         }
 
-        CVMetalTextureRef src  = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_src, i, format);
-        CVMetalTextureRef dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, i, format);
+        CVMetalTextureRef src  = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_src, i, channels, format);
+        CVMetalTextureRef dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, i, channels, format);
 
         id<MTLTexture> tex_src  = CVMetalTextureGetTexture(src);
         id<MTLTexture> tex_dest = CVMetalTextureGetTexture(dest);
@@ -345,7 +345,9 @@ static hb_buffer_t * filter_frame(hb_fil
         CFRelease(dest);
     }
 
+#if defined(HB_VT_PROPAGATE_ATTACHMENTS)
     CVBufferPropagateAttachments(cv_src, cv_dest);
+#endif
 
     out = hb_buffer_wrapper_init();
     out->storage_type      = COREMEDIA;
diff -Naupr a/libhb/platform/macosx/comb_detect_vt.m b/libhb/platform/macosx/comb_detect_vt.m
--- a/libhb/platform/macosx/comb_detect_vt.m	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/comb_detect_vt.m	2025-03-31 11:55:35.247884328 +0200
@@ -1,6 +1,6 @@
 /* comb_detect.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -270,7 +270,7 @@ static int comb_detect_vt_init(hb_filter
     descriptor.height           = init->geometry.height;
     descriptor.depth            = 1;
     descriptor.storageMode      = MTLStorageModePrivate;
-    descriptor.usage            = MTLResourceUsageRead | MTLResourceUsageWrite;
+    descriptor.usage            = MTLTextureUsageShaderRead | MTLTextureUsageShaderWrite;
 
     pv->mask   = [pv->mtl->device newTextureWithDescriptor:descriptor];
     pv->temp   = [pv->mtl->device newTextureWithDescriptor:descriptor];
@@ -386,7 +386,7 @@ static int analyze_frame(hb_filter_priva
     const AVComponentDescriptor *comp = &pv->desc->comp[0];
 
     int channels;
-    const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, &channels);
+    const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, 0, &channels);
     if (format == MTLPixelFormatInvalid)
     {
         goto fail;
@@ -403,13 +403,13 @@ static int analyze_frame(hb_filter_priva
             hb_log("comb_detect_vt: CVPixelBufferPoolCreatePixelBuffer failed");
             goto fail;
         }
-        dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, 0, format);
+        dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, 0, channels, format);
         tex_dest = CVMetalTextureGetTexture(dest);
     }
 
-    CVMetalTextureRef prev = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_prev, 0, format);
-    CVMetalTextureRef cur  = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_cur,  0, format);
-    CVMetalTextureRef next = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_next, 0, format);
+    CVMetalTextureRef prev = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_prev, 0, channels, format);
+    CVMetalTextureRef cur  = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_cur,  0, channels, format);
+    CVMetalTextureRef next = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_next, 0, channels, format);
 
     id<MTLTexture> tex_prev = CVMetalTextureGetTexture(prev);
     id<MTLTexture> tex_cur  = CVMetalTextureGetTexture(cur);
@@ -427,7 +427,9 @@ static int analyze_frame(hb_filter_priva
     if (pv->mode & MODE_MASK || pv->mode & MODE_COMPOSITE)
     {
         CFRelease(dest);
+#if defined(HB_VT_PROPAGATE_ATTACHMENTS)
         CVBufferPropagateAttachments(cv_cur, cv_dest);
+#endif
 
         *out = hb_buffer_wrapper_init();
         (*out)->storage_type = COREMEDIA;
diff -Naupr a/libhb/platform/macosx/config.m b/libhb/platform/macosx/config.m
--- a/libhb/platform/macosx/config.m	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/config.m	2025-03-31 11:55:35.247884328 +0200
@@ -1,6 +1,6 @@
 /* config.m
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/platform/macosx/cropscale_vt.c b/libhb/platform/macosx/cropscale_vt.c
--- a/libhb/platform/macosx/cropscale_vt.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/cropscale_vt.c	2025-03-31 11:55:35.247884328 +0200
@@ -1,6 +1,6 @@
 /* cropscale_vt.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -14,8 +14,8 @@
 struct hb_filter_private_s
 {
     VTPixelTransferSessionRef session;
-    CFDictionaryRef           source_clean_aperture;
     CVPixelBufferPoolRef      pool;
+    CFDictionaryRef           attachments;
 
     hb_filter_init_t          input;
     hb_filter_init_t          output;
@@ -98,12 +98,24 @@ static int crop_scale_vt_init(hb_filter_
         crop_width_num, crop_height_num, crop_offset_left_num, crop_offset_top_num
     };
 
-    pv->source_clean_aperture = CFDictionaryCreate(kCFAllocatorDefault,
-                                                   clean_aperture_keys,
-                                                   source_clean_aperture_values,
-                                                   4,
-                                                   &kCFTypeDictionaryKeyCallBacks,
-                                                   &kCFTypeDictionaryValueCallBacks);
+    CFDictionaryRef source_clean_aperture = CFDictionaryCreate(kCFAllocatorDefault,
+                                                               clean_aperture_keys,
+                                                               source_clean_aperture_values,
+                                                               4,
+                                                               &kCFTypeDictionaryKeyCallBacks,
+                                                               &kCFTypeDictionaryValueCallBacks);
+
+    CFMutableDictionaryRef attachments = CFDictionaryCreateMutable(NULL, 0,
+                                                                   &kCFTypeDictionaryKeyCallBacks,
+                                                                   &kCFTypeDictionaryValueCallBacks);
+
+    CFDictionarySetValue(attachments, kCVImageBufferCleanApertureKey, source_clean_aperture);
+    CFRelease(source_clean_aperture);
+
+    hb_cv_add_color_tag(attachments,
+                        init->color_prim, init->color_transfer,
+                        init->color_matrix, init->chroma_location);
+    pv->attachments = attachments;
 
     CFRelease(crop_width_num);
     CFRelease(crop_height_num);
@@ -197,6 +209,7 @@ static int crop_scale_vt_init(hb_filter_
     init->geometry.width = width;
     init->geometry.height = height;
 
+    init->pix_fmt = format;
     pv->output = *init;
 
     return 0;
@@ -216,14 +229,14 @@ static void crop_scale_vt_close(hb_filte
         VTPixelTransferSessionInvalidate(pv->session);
         CFRelease(pv->session);
     }
-    if (pv->source_clean_aperture)
-    {
-        CFRelease(pv->source_clean_aperture);
-    }
     if (pv->pool)
     {
         CVPixelBufferPoolRelease(pv->pool);
     }
+    if (pv->attachments)
+    {
+        CFRelease(pv->attachments);
+    }
 
     free(pv);
     filter->private_data = NULL;
@@ -247,16 +260,12 @@ static int crop_scale_vt_work(hb_filter_
     OSStatus err = noErr;
 
     CVPixelBufferRef source_buf = hb_cv_get_pixel_buffer(in);
-    hb_cv_add_color_tag(source_buf,
-                        pv->input.color_prim, pv->input.color_transfer,
-                        pv->input.color_matrix, pv->input.chroma_location);
     if (source_buf == NULL)
     {
         hb_log("cropscale_vt: extract_buf failed");
         return HB_FILTER_FAILED;
     }
-    CVBufferSetAttachment(source_buf, kCVImageBufferCleanApertureKey,
-                          pv->source_clean_aperture, kCVAttachmentMode_ShouldPropagate);
+    hb_cv_set_attachments(source_buf, pv->attachments);
 
     CVPixelBufferRef dest_buf = NULL;
     err = CVPixelBufferPoolCreatePixelBuffer(kCFAllocatorDefault, pv->pool, &dest_buf);
diff -Naupr a/libhb/platform/macosx/cv_utils.c b/libhb/platform/macosx/cv_utils.c
--- a/libhb/platform/macosx/cv_utils.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/cv_utils.c	2025-03-31 11:55:35.247884328 +0200
@@ -1,6 +1,6 @@
 /* cv_utils.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -92,27 +92,54 @@ CVPixelBufferRef hb_cv_get_pixel_buffer(
     return NULL;
 }
 
+int hb_cv_get_io_surface_usage_count(const hb_buffer_t *buf)
+{
+    IOSurfaceRef surface = NULL;
+    CVPixelBufferRef pix_buf = hb_cv_get_pixel_buffer(buf);
+
+    if (pix_buf)
+    {
+        surface = CVPixelBufferGetIOSurface(pix_buf);
+    }
+
+    if (surface)
+    {
+        return IOSurfaceGetUseCount(surface);
+    }
+
+    return 0;
+}
+
 CVPixelBufferPoolRef hb_cv_create_pixel_buffer_pool(int width, int height, enum AVPixelFormat pix_fmt, enum AVColorRange color_range)
 {
-    // CVPixelBuffer pool
-    // Set the Metal compatibility key
-    // to keep the buffer on the GPU memory
     OSType cv_pix_fmt = hb_cv_get_pixel_format(pix_fmt, color_range);
     CFNumberRef pix_fmt_num = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &cv_pix_fmt);
     CFNumberRef width_num   = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &width);
     CFNumberRef height_num  = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &height);
 
-    const void *attrs_keys[4] =
+    // Align the width and height to 16 to avoid VideoToolbox
+    // inserting an additional VTPixelTransferSession
+    int extend_width  = MULTIPLE_MOD_UP(width,  16) - width;
+    int extend_height = MULTIPLE_MOD_UP(height, 16) - height;
+
+    CFNumberRef extend_width_num  = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &extend_width);
+    CFNumberRef extend_height_num = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &extend_height);
+
+    const void *attrs_keys[6] =
     {
         kCVPixelBufferWidthKey,
         kCVPixelBufferHeightKey,
+        kCVPixelBufferExtendedPixelsRightKey,
+        kCVPixelBufferExtendedPixelsBottomKey,
         kCVPixelBufferPixelFormatTypeKey,
         kCVPixelBufferMetalCompatibilityKey
     };
-    const void *attrs_values[4] =
+    const void *attrs_values[6] =
     {
         width_num,
         height_num,
+        extend_width_num,
+        extend_height_num,
         pix_fmt_num,
         kCFBooleanTrue
     };
@@ -120,12 +147,14 @@ CVPixelBufferPoolRef hb_cv_create_pixel_
     CFDictionaryRef attrs = CFDictionaryCreate(kCFAllocatorDefault,
                                                attrs_keys,
                                                attrs_values,
-                                               4,
+                                               6,
                                                &kCFTypeDictionaryKeyCallBacks,
                                                &kCFTypeDictionaryValueCallBacks);
 
     CFRelease(width_num);
     CFRelease(height_num);
+    CFRelease(extend_width_num);
+    CFRelease(extend_height_num);
     CFRelease(pix_fmt_num);
 
     CVPixelBufferPoolRef pool;
@@ -250,7 +279,7 @@ CFStringRef hb_cv_chroma_loc_xlat(int ch
     }
 }
 
-void hb_cv_add_color_tag(CVPixelBufferRef pix_buf,
+void hb_cv_add_color_tag(CFMutableDictionaryRef attachments,
                          int color_prim, int color_transfer,
                          int color_matrix, int chroma_location)
 {
@@ -260,32 +289,35 @@ void hb_cv_add_color_tag(CVPixelBufferRe
     CFStringRef matrix     = hb_cv_colr_mat_xlat(color_matrix);
     CFStringRef chroma_loc = hb_cv_chroma_loc_xlat(chroma_location);
 
-    CVBufferRemoveAllAttachments(pix_buf);
-
     if (prim)
     {
-        CVBufferSetAttachment(pix_buf, kCVImageBufferColorPrimariesKey, prim, kCVAttachmentMode_ShouldPropagate);
+        CFDictionarySetValue(attachments, kCVImageBufferColorPrimariesKey, prim);
     }
     if (transfer)
     {
-        CVBufferSetAttachment(pix_buf, kCVImageBufferTransferFunctionKey, transfer, kCVAttachmentMode_ShouldPropagate);
+        CFDictionarySetValue(attachments, kCVImageBufferTransferFunctionKey, transfer);
     }
     if (gamma)
     {
-        CVBufferSetAttachment(pix_buf, kCVImageBufferGammaLevelKey, gamma, kCVAttachmentMode_ShouldPropagate);
+        CFDictionarySetValue(attachments, kCVImageBufferGammaLevelKey, gamma);
         CFRelease(gamma);
     }
     if (matrix)
     {
-        CVBufferSetAttachment(pix_buf, kCVImageBufferYCbCrMatrixKey, matrix, kCVAttachmentMode_ShouldPropagate);
+        CFDictionarySetValue(attachments, kCVImageBufferYCbCrMatrixKey, matrix);
     }
     if (chroma_loc)
     {
-        CVBufferSetAttachment(pix_buf, kCVImageBufferChromaLocationTopFieldKey, chroma_loc, kCVAttachmentMode_ShouldPropagate);
-        CVBufferSetAttachment(pix_buf, kCVImageBufferChromaLocationBottomFieldKey, chroma_loc, kCVAttachmentMode_ShouldPropagate);
+        CFDictionarySetValue(attachments, kCVImageBufferChromaLocationTopFieldKey, chroma_loc);
     }
 }
 
+void hb_cv_set_attachments(CVPixelBufferRef pix_buf, CFDictionaryRef attachments)
+{
+    CVBufferRemoveAllAttachments(pix_buf);
+    CVBufferSetAttachments(pix_buf, attachments, kCVAttachmentMode_ShouldPropagate);
+}
+
 int hb_cv_match_rgb_to_colorspace(int rgb,
                                   int color_prim,
                                   int color_transfer,
diff -Naupr a/libhb/platform/macosx/cv_utils.h b/libhb/platform/macosx/cv_utils.h
--- a/libhb/platform/macosx/cv_utils.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/cv_utils.h	2025-03-31 11:55:35.247884328 +0200
@@ -1,6 +1,6 @@
 /* cv_utils.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -18,6 +18,9 @@ OSType hb_cv_get_pixel_format(enum AVPix
 
 CVPixelBufferRef hb_cv_get_pixel_buffer(const hb_buffer_t *buf);
 
+int hb_cv_get_io_surface_usage_count(const hb_buffer_t *buf);
+
+
 CVPixelBufferPoolRef hb_cv_create_pixel_buffer_pool(int width, int height,
                                                     enum AVPixelFormat pix_fmt,
                                                     enum AVColorRange color_range);
@@ -29,10 +32,12 @@ CFStringRef hb_cv_colr_mat_xlat(int colo
 CFStringRef hb_cv_colr_range_xlat(int color_range);
 CFStringRef hb_cv_chroma_loc_xlat(int chroma_location);
 
-void hb_cv_add_color_tag(CVPixelBufferRef pix_buf,
+void hb_cv_add_color_tag(CFMutableDictionaryRef attachments,
                          int color_prim, int color_transfer,
                          int color_matrix, int chroma_location);
 
+void hb_cv_set_attachments(CVPixelBufferRef pix_buf, CFDictionaryRef attachments);
+
 int hb_cv_match_rgb_to_colorspace(int rgb,
                                   int color_prim,
                                   int color_transfer,
diff -Naupr a/libhb/platform/macosx/deinterlace_vt.m b/libhb/platform/macosx/deinterlace_vt.m
--- a/libhb/platform/macosx/deinterlace_vt.m	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/deinterlace_vt.m	2025-03-31 11:55:35.247884328 +0200
@@ -1,6 +1,6 @@
 /* deinterlace_vt.m
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -267,16 +267,16 @@ static hb_buffer_t * filter_frame(hb_fil
         }
 
         int channels;
-        const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, &channels);
+        const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, 0, &channels);
         if (format == MTLPixelFormatInvalid)
         {
             goto fail;
         }
 
-        CVMetalTextureRef prev = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_prev, i, format);
-        CVMetalTextureRef cur  = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_cur,  i, format);
-        CVMetalTextureRef next = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_next, i, format);
-        CVMetalTextureRef dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, i, format);
+        CVMetalTextureRef prev = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_prev, i, channels, format);
+        CVMetalTextureRef cur  = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_cur,  i, channels, format);
+        CVMetalTextureRef next = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_next, i, channels, format);
+        CVMetalTextureRef dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, i, channels, format);
 
         id<MTLTexture> tex_prev = CVMetalTextureGetTexture(prev);
         id<MTLTexture> tex_cur  = CVMetalTextureGetTexture(cur);
@@ -291,7 +291,9 @@ static hb_buffer_t * filter_frame(hb_fil
         CFRelease(dest);
     }
 
+#if defined(HB_VT_PROPAGATE_ATTACHMENTS)
     CVBufferPropagateAttachments(cv_cur, cv_dest);
+#endif
 
     out = hb_buffer_wrapper_init();
     out->storage_type      = COREMEDIA;
diff -Naupr a/libhb/platform/macosx/encca_aac.c b/libhb/platform/macosx/encca_aac.c
--- a/libhb/platform/macosx/encca_aac.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/encca_aac.c	2025-03-31 11:55:35.247884328 +0200
@@ -1,6 +1,6 @@
 /* encca_aac.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/platform/macosx/encvt.c b/libhb/platform/macosx/encvt.c
--- a/libhb/platform/macosx/encvt.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/encvt.c	2025-03-31 11:55:35.247884328 +0200
@@ -1,6 +1,6 @@
 /* encvt.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -19,6 +19,7 @@
 #include "handbrake/extradata.h"
 #include "handbrake/bitstream.h"
 
+#include "vt_common.h"
 #include "cv_utils.h"
 
 int  encvt_init(hb_work_object_t *, hb_job_t *);
@@ -34,7 +35,7 @@ hb_work_object_t hb_encvt =
     encvt_close
 };
 
-#define FRAME_INFO_SIZE 512
+#define FRAME_INFO_SIZE 1024
 #define FRAME_INFO_MASK (FRAME_INFO_SIZE - 1)
 
 struct hb_work_private_s
@@ -133,13 +134,15 @@ struct hb_work_private_s
         h264;
     }
     settings;
+
+    CFDictionaryRef attachments;
 };
 
 void hb_vt_param_default(struct hb_vt_param *param)
 {
     param->quality                  = -1;
-    param->vbv.maxrate              = 0;
-    param->vbv.bufsize              = 0;
+    param->vbv.maxrate              =  0;
+    param->vbv.bufsize              =  0;
     param->maxAllowedFrameQP        = -1;
     param->minAllowedFrameQP        = -1;
     param->maxReferenceBufferCount  = -1;
@@ -153,14 +156,15 @@ void hb_vt_param_default(struct hb_vt_pa
     param->fieldDetail              = HB_VT_FIELDORDER_PROGRESSIVE;
 }
 
-// used to pass the compression session
-// to the next job
+// Used to pass the compression
+// session to the next job
 typedef struct vt_interjob_s
 {
     VTCompressionSessionRef session;
     VTMultiPassStorageRef   passStorage;
     CMSimpleQueueRef        queue;
     CMFormatDescriptionRef  format;
+    int                     areBframes;
 } vt_interjob_t;
 
 enum
@@ -210,30 +214,57 @@ hb_vt_h265_levels[] =
     { "auto", { CFSTR("HEVC_Main_AutoLevel"), CFSTR("HEVC_Main10_AutoLevel"), CFSTR("HEVC_Main42210_AutoLevel") } }
 };
 
-static void save_frame_info(hb_work_private_t *pv, hb_buffer_t *in)
+static void hb_vt_save_frame_info(hb_work_private_t *pv, hb_buffer_t *in)
 {
     int i = pv->frameno_in & FRAME_INFO_MASK;
     pv->frame_info[i].start = in->s.start;
 }
 
-static int64_t get_frame_start(hb_work_private_t * pv, int64_t frameno)
+static int64_t hb_vt_get_frame_start(hb_work_private_t *pv, int64_t frameno)
 {
     int i = frameno & FRAME_INFO_MASK;
     return pv->frame_info[i].start;
 }
 
-static void compute_dts_offset(hb_work_private_t *pv, hb_buffer_t *buf)
+static void hb_vt_compute_dts_offset(hb_work_private_t *pv, hb_buffer_t *buf)
+{
+    if (pv->job->areBframes &&
+        pv->frameno_in == pv->job->areBframes)
+    {
+        pv->dts_delay = buf->s.start;
+        pv->job->init_delay = pv->dts_delay;
+    }
+}
+
+static void hb_vt_check_result(OSStatus err, CFStringRef propertyKey)
 {
-    if (pv->job->areBframes)
+    if (err != noErr)
     {
-        if ((pv->frameno_in) == pv->job->areBframes)
+        static const int VAL_BUF_LEN = 256;
+        char valBuf[VAL_BUF_LEN];
+
+        Boolean haveStr = CFStringGetCString(propertyKey,
+                                             valBuf,
+                                             VAL_BUF_LEN,
+                                             kCFStringEncodingUTF8);
+        if (haveStr)
+        {
+            hb_log("VTSessionSetProperty: %s failed (%d)", valBuf, err);
+        }
+        else
         {
-            pv->dts_delay = buf->s.start;
-            pv->job->init_delay = pv->dts_delay;
+            hb_log("VTSessionSetProperty: failed (%d)", err);
         }
     }
 }
 
+static OSStatus hb_vt_set_property(VTSessionRef session, CFStringRef propertyKey, CFTypeRef propertyValue)
+{
+    OSStatus err = VTSessionSetProperty(session, propertyKey, propertyValue);
+    hb_vt_check_result(err, propertyKey);
+    return err;
+}
+
 static int hb_vt_get_nal_length_size(CMSampleBufferRef sampleBuffer, CMVideoCodecType codec)
 {
     CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer);
@@ -356,43 +387,54 @@ static CFDataRef hb_vt_ambient_viewing_e
 
 static OSType hb_vt_encoder_pixel_format_xlat(int vcodec, int profile, int color_range)
 {
+    int pix_fmt = AV_PIX_FMT_NV12;
+
     switch (vcodec)
     {
         case HB_VCODEC_VT_H264:
-            switch (profile)
-            {
-                case HB_VT_H264_PROFILE_BASELINE:
-                case HB_VT_H264_PROFILE_MAIN:
-                case HB_VT_H264_PROFILE_HIGH:
-                    return hb_cv_get_pixel_format(AV_PIX_FMT_NV12, color_range);
-            }
         case HB_VCODEC_VT_H265:
+            pix_fmt = hb_vt_get_best_pix_fmt(vcodec, "auto");
+            break;
         case HB_VCODEC_VT_H265_10BIT:
             switch (profile)
             {
-                case HB_VT_H265_PROFILE_MAIN:
-                    return hb_cv_get_pixel_format(AV_PIX_FMT_NV12, color_range);
                 case HB_VT_H265_PROFILE_MAIN_10:
-                    return hb_cv_get_pixel_format(AV_PIX_FMT_P010, color_range);
+                    pix_fmt = hb_vt_get_best_pix_fmt(vcodec, "main-10");
                 case HB_VT_H265_PROFILE_MAIN_422_10:
-                    return hb_cv_get_pixel_format(AV_PIX_FMT_P210, color_range);
+                    pix_fmt = hb_vt_get_best_pix_fmt(vcodec, "main422-10");
             }
+            break;
+        default:
+            hb_log("encvt_Init: unknown codec");
     }
 
-    hb_log("encvt_Init: unknown codec");
-    return hb_cv_get_pixel_format(AV_PIX_FMT_NV12, color_range);
+    return hb_cv_get_pixel_format(pix_fmt, color_range);
+}
+
+static CFDictionaryRef hb_vt_attachments_xlat(hb_job_t *job)
+{
+    CFMutableDictionaryRef mutable_attachments = CFDictionaryCreateMutable(NULL, 0,
+                                                                   &kCFTypeDictionaryKeyCallBacks,
+                                                                   &kCFTypeDictionaryValueCallBacks);
+    hb_cv_add_color_tag(mutable_attachments,
+                        job->color_prim, job->color_transfer,
+                        job->color_matrix, job->chroma_location);
+
+    CFDictionaryRef attachments = CFDictionaryCreateCopy(NULL, mutable_attachments);
+    CFRelease(mutable_attachments);
+    return attachments;
 }
 
 static int hb_vt_settings_xlat(hb_work_private_t *pv, hb_job_t *job)
 {
-    /* Set global default values. */
+    // Set global default values.
     hb_vt_param_default(&pv->settings);
 
     pv->settings.codec       = job->vcodec == HB_VCODEC_VT_H264 ? kCMVideoCodecType_H264 : kCMVideoCodecType_HEVC;
     pv->settings.inputPixFmt = hb_cv_get_pixel_format(job->output_pix_fmt, job->color_range);
-    pv->settings.timescale = 90000;
+    pv->settings.timescale   = 90000;
 
-    // set the preset
+    // Set the preset
     if (job->encoder_preset != NULL && *job->encoder_preset != '\0')
     {
         if (!strcasecmp(job->encoder_preset, "speed"))
@@ -401,7 +443,7 @@ static int hb_vt_settings_xlat(hb_work_p
         }
     }
 
-    // set the profile and level before initializing the session
+    // Set the profile and level before initializing the session
     if (job->encoder_profile != NULL && *job->encoder_profile != '\0')
     {
         if (job->vcodec == HB_VCODEC_VT_H264)
@@ -504,7 +546,7 @@ static int hb_vt_settings_xlat(hb_work_p
         }
     }
 
-    /* Compute the frame rate and output bit rate. */
+    // Compute the frame rate and output bit rate
     pv->settings.expectedFrameRate = (double)job->vrate.num / (double)job->vrate.den;
 
     if (job->vquality > HB_INVALID_VIDEO_QUALITY)
@@ -537,16 +579,16 @@ static int hb_vt_settings_xlat(hb_work_p
     pv->settings.color.matrix   = hb_output_color_matrix(job);
     pv->settings.color.chromaLocation = job->chroma_location;
 
-    /* HDR10 Static metadata */
+    // HDR10 Static metadata
     if (job->color_transfer == HB_COLR_TRA_SMPTEST2084)
     {
-        /* Mastering display metadata */
+        // Mastering display metadata
         if (job->mastering.has_primaries && job->mastering.has_luminance)
         {
             pv->settings.color.masteringDisplay = hb_vt_mastering_display_xlat(job->mastering);
         }
 
-        /*  Content light level */
+        //  Content light level
         if (job->coll.max_cll && job->coll.max_fall)
         {
             pv->settings.color.contentLightLevel = hb_vt_content_light_level_xlat(job->coll);
@@ -679,7 +721,7 @@ static int hb_vt_parse_options(hb_work_p
     }
     hb_dict_free(&opts);
 
-    /* Sanitize interframe settings */
+    // Sanitize interframe settings
     switch (pv->settings.maxKeyFrameInterval)
     {
         case 1:
@@ -713,10 +755,8 @@ static int hb_vt_parse_options(hb_work_p
     return 0;
 }
 
-static void set_data_rate_limits(VTCompressionSessionRef session, int bufsize, int maxrate)
+static void hb_vt_set_data_rate_limits(VTCompressionSessionRef session, int bufsize, int maxrate)
 {
-    OSStatus err = 0;
-
     float seconds = ((float)bufsize / (float)maxrate);
     int bytes = maxrate * 125 * seconds;
 
@@ -728,37 +768,24 @@ static void set_data_rate_limits(VTCompr
                                                             &kCFTypeArrayCallBacks);
     CFArrayAppendValue(dataRateLimits, size);
     CFArrayAppendValue(dataRateLimits, duration);
-    err = VTSessionSetProperty(session,
-                               kVTCompressionPropertyKey_DataRateLimits,
-                               dataRateLimits);
+
+    hb_vt_set_property(session, kVTCompressionPropertyKey_DataRateLimits, dataRateLimits);
+
     CFRelease(size);
     CFRelease(duration);
     CFRelease(dataRateLimits);
-    if (err != noErr)
-    {
-        hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_DataRateLimits failed");
-    }
 }
 
-static OSStatus wrap_buf(hb_work_private_t *pv, hb_buffer_t *buf, CVPixelBufferRef *pix_buf)
+static CVPixelBufferRef hb_vt_get_pix_buf(hb_work_private_t *pv, hb_buffer_t *buf)
 {
-    OSStatus err = 0;
+    CVPixelBufferRef pix_buf = NULL;
 
     if (pv->job->hw_pix_fmt == AV_PIX_FMT_VIDEOTOOLBOX)
     {
-        if (buf->storage_type == AVFRAME)
-        {
-            *pix_buf = (CVPixelBufferRef)((AVFrame *)buf->storage)->data[3];
-            CVPixelBufferRetain(*pix_buf);
-        }
-        else if (buf->storage_type == COREMEDIA)
-        {
-            *pix_buf = (CVPixelBufferRef)buf->storage;
-            CVPixelBufferRetain(*pix_buf);
-        }
-        else
+        pix_buf = hb_cv_get_pixel_buffer(buf);
+        if (pix_buf)
         {
-            err = 1;
+            CVPixelBufferRetain(pix_buf);
         }
     }
     else
@@ -766,12 +793,12 @@ static OSStatus wrap_buf(hb_work_private
         int numberOfPlanes = pv->settings.inputPixFmt == kCVPixelFormatType_420YpCbCr8Planar ||
         pv->settings.inputPixFmt == kCVPixelFormatType_420YpCbCr8PlanarFullRange ? 3 : 2;
 
-        void *planeBaseAddress[3] = {buf->plane[0].data, buf->plane[1].data, buf->plane[2].data};
-        size_t planeWidth[3] = {buf->plane[0].width, buf->plane[1].width, buf->plane[2].width};
-        size_t planeHeight[3] = {buf->plane[0].height, buf->plane[1].height, buf->plane[2].height};
+        void *planeBaseAddress[3]  = {buf->plane[0].data,   buf->plane[1].data,   buf->plane[2].data};
+        size_t planeWidth[3]       = {buf->plane[0].width,  buf->plane[1].width,  buf->plane[2].width};
+        size_t planeHeight[3]      = {buf->plane[0].height, buf->plane[1].height, buf->plane[2].height};
         size_t planeBytesPerRow[3] = {buf->plane[0].stride, buf->plane[1].stride, buf->plane[2].stride};
 
-        err = CVPixelBufferCreateWithPlanarBytes(
+        OSStatus err = CVPixelBufferCreateWithPlanarBytes(
                                                  kCFAllocatorDefault,
                                                  buf->f.width,
                                                  buf->f.height,
@@ -786,16 +813,234 @@ static OSStatus wrap_buf(hb_work_private
                                                  NULL,
                                                  buf,
                                                  NULL,
-                                                 pix_buf);
+                                                 &pix_buf);
+        if (err)
+        {
+            pix_buf = NULL;
+        }
     }
 
-    if (*pix_buf)
+    return pix_buf;
+}
+
+static void hb_vt_insert_dynamic_metadata(hb_work_private_t *pv, CMSampleBufferRef sampleBuffer, hb_buffer_t **buf)
+{
+    if (pv->job->passthru_dynamic_hdr_metadata == 0)
     {
-        hb_cv_add_color_tag(*pix_buf, pv->job->color_prim, pv->job->color_transfer,
-                            pv->job->color_matrix, pv->job->chroma_location);
+        return;
     }
 
-    return err;
+    if (pv->nal_length_size == 0)
+    {
+        pv->nal_length_size = hb_vt_get_nal_length_size(sampleBuffer, pv->settings.codec);
+    }
+
+    if (pv->nal_length_size > 4)
+    {
+        hb_log("VTCompressionSession: unknown nal length size");
+        return;
+    }
+
+    hb_buffer_t *buf_in = *buf;
+    hb_sei_t seis[4];
+    size_t seis_count = 0;
+
+    if (buf_in->s.frametype == HB_FRAME_IDR)
+    {
+        if (pv->settings.color.contentLightLevel)
+        {
+            const uint8_t *coll_data = CFDataGetBytePtr(pv->settings.color.contentLightLevel);
+            size_t coll_size = CFDataGetLength(pv->settings.color.contentLightLevel);
+
+            seis[seis_count].type = HB_CONTENT_LIGHT_LEVEL_INFO;
+            seis[seis_count].payload = coll_data;
+            seis[seis_count].payload_size = coll_size;
+
+            seis_count += 1;
+        }
+
+        if (pv->settings.color.masteringDisplay)
+        {
+            const uint8_t *mastering_data = CFDataGetBytePtr(pv->settings.color.masteringDisplay);
+            size_t mastering_size = CFDataGetLength(pv->settings.color.masteringDisplay);
+
+            seis[seis_count].type = HB_MASTERING_DISPLAY_INFO;
+            seis[seis_count].payload = mastering_data;
+            seis[seis_count].payload_size = mastering_size;
+
+            seis_count += 1;
+        }
+    }
+
+    if (pv->job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_HDR10PLUS)
+    {
+        CFDataRef hdrPlus = CMGetAttachment(sampleBuffer, CFSTR("HB_HDR_PLUS"), NULL);
+        if (hdrPlus != NULL)
+        {
+            const uint8_t *sei_data = CFDataGetBytePtr(hdrPlus);
+            size_t sei_size = CFDataGetLength(hdrPlus);
+
+            seis[seis_count].type = HB_USER_DATA_REGISTERED_ITU_T_T35;
+            seis[seis_count].payload = sei_data;
+            seis[seis_count].payload_size = sei_size;
+
+            seis_count += 1;
+        }
+    }
+
+    hb_nal_t nals[1];
+    size_t nals_count = 0;
+
+    if (pv->job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_DOVI)
+    {
+        CFDataRef rpu = CMGetAttachment(sampleBuffer, CFSTR("HB_DOVI_RPU"), NULL);
+        if (rpu != NULL)
+        {
+            const uint8_t *rpu_data = CFDataGetBytePtr(rpu);
+            size_t rpu_size = CFDataGetLength(rpu);
+
+            nals[nals_count].type = HB_HEVC_NAL_UNIT_UNSPECIFIED;
+            nals[nals_count].payload = rpu_data;
+            nals[nals_count].payload_size = rpu_size;
+
+            nals_count += 1;
+        }
+    }
+
+    if (seis_count || nals_count)
+    {
+        hb_buffer_t *out = hb_isomp4_hevc_nal_bitstream_insert_payloads(buf_in->data, buf_in->size,
+                                                                        seis, seis_count,
+                                                                        nals, nals_count,
+                                                                        pv->nal_length_size);
+        if (out)
+        {
+            out->f = buf_in->f;
+            out->s = buf_in->s;
+            hb_buffer_close(buf);
+            *buf = out;
+        }
+    }
+}
+
+static void hb_vt_set_frametype(CMSampleBufferRef sampleBuffer, hb_buffer_t *buf)
+{
+    buf->s.frametype = HB_FRAME_IDR;
+    buf->s.flags |= HB_FLAG_FRAMETYPE_REF;
+
+    CFArrayRef attachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, 0);
+    if (CFArrayGetCount(attachmentsArray))
+    {
+        CFDictionaryRef dict = CFArrayGetValueAtIndex(attachmentsArray, 0);
+        CFBooleanRef notSync;
+        if (CFDictionaryGetValueIfPresent(dict, kCMSampleAttachmentKey_NotSync,(const void **) &notSync))
+        {
+            Boolean notSyncValue = CFBooleanGetValue(notSync);
+            if (notSyncValue)
+            {
+                CFBooleanRef b;
+                if (CFDictionaryGetValueIfPresent(dict, kCMSampleAttachmentKey_PartialSync, NULL))
+                {
+                    buf->s.frametype = HB_FRAME_I;
+                }
+                else if (CFDictionaryGetValueIfPresent(dict, kCMSampleAttachmentKey_IsDependedOnByOthers,(const void **) &b))
+                {
+                    Boolean bv = CFBooleanGetValue(b);
+                    if (bv)
+                    {
+                        buf->s.frametype = HB_FRAME_P;
+                    }
+                    else
+                    {
+                        buf->s.frametype = HB_FRAME_B;
+                        buf->s.flags &= ~HB_FLAG_FRAMETYPE_REF;
+                    }
+                }
+                else
+                {
+                   buf->s.frametype = HB_FRAME_P;
+                }
+            }
+        }
+    }
+}
+
+static void hb_vt_set_timestamps(hb_work_private_t *pv, CMSampleBufferRef sampleBuffer, hb_buffer_t *buf)
+{
+    CMTime presentationTimeStamp = CMSampleBufferGetPresentationTimeStamp(sampleBuffer);
+    CMTime duration = CMSampleBufferGetDuration(sampleBuffer);
+
+    buf->s.duration = duration.value;
+    buf->s.start = presentationTimeStamp.value;
+    buf->s.stop  = presentationTimeStamp.value + buf->s.duration;
+
+    // Use the cached frame info to get the start time of Nth frame
+    // Note that start Nth frame != start time this buffer since the
+    // output buffers have rearranged start times.
+    if (pv->frameno_out < pv->job->areBframes)
+    {
+        buf->s.renderOffset = hb_vt_get_frame_start(pv, pv->frameno_out) - pv->dts_delay;
+    }
+    else
+    {
+        buf->s.renderOffset = hb_vt_get_frame_start(pv, pv->frameno_out - pv->job->areBframes);
+    }
+    pv->frameno_out++;
+}
+
+static hb_buffer_t * hb_vt_get_buf(CMSampleBufferRef sampleBuffer, hb_work_private_t *pv)
+{
+    CMItemCount samplesNum = CMSampleBufferGetNumSamples(sampleBuffer);
+    if (samplesNum > 1)
+    {
+        hb_log("VTCompressionSession: more than 1 sample in sampleBuffer = %ld", samplesNum);
+    }
+
+    hb_buffer_t *buf = NULL;
+    CMBlockBufferRef buffer = CMSampleBufferGetDataBuffer(sampleBuffer);
+    if (buffer)
+    {
+        size_t sampleSize = CMBlockBufferGetDataLength(buffer);
+        Boolean isContiguous = CMBlockBufferIsRangeContiguous(buffer, 0, sampleSize);
+
+        if (isContiguous)
+        {
+            size_t lengthAtOffsetOut, totalLengthOut;
+            char * _Nullable dataPointerOut;
+
+            buf = hb_buffer_wrapper_init();
+            OSStatus err = CMBlockBufferGetDataPointer(buffer, 0, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut);
+            if (err != kCMBlockBufferNoErr)
+            {
+                hb_log("VTCompressionSession: CMBlockBufferGetDataPointer error");
+            }
+            buf->data = (uint8_t *)dataPointerOut;
+            buf->size = totalLengthOut;
+            buf->storage = sampleBuffer;
+            buf->storage_type = COREMEDIA;
+            CFRetain(sampleBuffer);
+        }
+        else
+        {
+            buf = hb_buffer_init(sampleSize);
+            OSStatus err = CMBlockBufferCopyDataBytes(buffer, 0, sampleSize, buf->data);
+            if (err != kCMBlockBufferNoErr)
+            {
+                hb_log("VTCompressionSession: CMBlockBufferCopyDataBytes error");
+            }
+        }
+
+        hb_vt_set_frametype(sampleBuffer, buf);
+        hb_vt_set_timestamps(pv, sampleBuffer, buf);
+        hb_vt_insert_dynamic_metadata(pv, sampleBuffer, &buf);
+
+        if (buf->s.frametype == HB_FRAME_IDR)
+        {
+            hb_chapter_dequeue(pv->chapter_queue, buf);
+        }
+    }
+
+    return buf;
 }
 
 void hb_vt_compression_output_callback(
@@ -837,7 +1082,7 @@ void hb_vt_compression_output_callback(
     }
 }
 
-static OSStatus init_vtsession(hb_work_object_t *w, hb_job_t *job, hb_work_private_t *pv, int cookieOnly)
+static OSStatus hb_vt_init_session(hb_work_object_t *w, hb_job_t *job, hb_work_private_t *pv, int cookieOnly)
 {
     OSStatus err = noErr;
     CFNumberRef cfValue = NULL;
@@ -937,103 +1182,48 @@ static OSStatus init_vtsession(hb_work_o
 
     CFRelease(encoderSpecifications);
 
-#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 150000
-    if (__builtin_available(macOS 15, *))
-    {
-        // Control spatial adaptation of the quantization parameter (QP) based on per-frame statistics.
-        if (pv->settings.disableSpatialAdaptiveQP == kCFBooleanTrue)
-        {
-            int32_t spatialAdaptiveQP = kVTQPModulationLevel_Disable;
-            CFNumberRef spatialAdaptiveQPNumber = CFNumberCreate( kCFAllocatorDefault, kCFNumberSInt32Type, &spatialAdaptiveQP );
-            err = VTSessionSetProperty(pv->session, kVTCompressionPropertyKey_SpatialAdaptiveQPLevel , spatialAdaptiveQPNumber);
-            CFRelease(spatialAdaptiveQPNumber );
-            if (err != noErr)
-            {
-                hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_SpatialAdaptiveQPLevel failed (%d)",err);
-            }
-        }
-
-        // Requests that the encoder retain the specified number of frames during encoding.
-        if (pv->settings.lookAheadFrameCount >= 0)
-        {
-            cfValue = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType,
-                                     &pv->settings.lookAheadFrameCount);
-            err = VTSessionSetProperty(pv->session,
-                                       kVTCompressionPropertyKey_SuggestedLookAheadFrameCount,
-                                       cfValue);
-            CFRelease(cfValue);
-            if (err != noErr)
-            {
-                hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_SuggestedLookAheadFrameCount failed");
-            }
-        }
-    }
-#endif
-
     // Offline encoders (such as Handbrake) should set RealTime property to False, as it disconnects the relationship
     // between encoder speed and target video frame rate, explicitly setting RealTime to false encourages VideoToolbox
     // to use the fastest mode, while adhering to the required output quality/bitrate and favorQualityOverSpeed settings
-    err = VTSessionSetProperty(pv->session, kVTCompressionPropertyKey_RealTime , kCFBooleanFalse);
-    if (err != noErr)
-    {
-        hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_RealTime failed");
-    }
-
-    err = VTSessionSetProperty(pv->session,
-                               kVTCompressionPropertyKey_AllowTemporalCompression,
-                               pv->settings.allowTemporalCompression);
-    if (err != noErr)
-    {
-        hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_AllowTemporalCompression failed");
-    }
+    hb_vt_set_property(pv->session,
+                       kVTCompressionPropertyKey_RealTime,
+                       kCFBooleanFalse);
+
+    hb_vt_set_property(pv->session,
+                       kVTCompressionPropertyKey_AllowTemporalCompression,
+                       pv->settings.allowTemporalCompression);
+
+    hb_vt_set_property(pv->session,
+                       kVTCompressionPropertyKey_AllowFrameReordering,
+                       pv->settings.allowFrameReordering);
 
-    err = VTSessionSetProperty(pv->session,
-                               kVTCompressionPropertyKey_AllowFrameReordering,
-                               pv->settings.allowFrameReordering);
-    if (err != noErr)
-    {
-        hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_AllowFrameReordering failed");
-    }
+    cfValue = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType,
+                             &pv->settings.maxKeyFrameInterval);
+    hb_vt_set_property(pv->session,
+                       kVTCompressionPropertyKey_MaxKeyFrameInterval,
+                       cfValue);
+    CFRelease(cfValue);
 
     if (__builtin_available(macOS 11, *))
     {
         if (supportedProps != NULL && CFDictionaryContainsKey(supportedProps, kVTCompressionPropertyKey_PrioritizeEncodingSpeedOverQuality))
         {
-            err = VTSessionSetProperty(pv->session,
-                                       kVTCompressionPropertyKey_PrioritizeEncodingSpeedOverQuality,
-                                       pv->settings.prioritizeEncodingSpeedOverQuality);
-            if (err != noErr)
-            {
-                hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_PrioritizeEncodingSpeedOverQuality failed");
-            }
+            hb_vt_set_property(pv->session,
+                               kVTCompressionPropertyKey_PrioritizeEncodingSpeedOverQuality,
+                               pv->settings.prioritizeEncodingSpeedOverQuality);
         }
     }
 
-    cfValue = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType,
-                             &pv->settings.maxKeyFrameInterval);
-    err = VTSessionSetProperty(pv->session,
-                               kVTCompressionPropertyKey_MaxKeyFrameInterval,
-                               cfValue);
-    CFRelease(cfValue);
-    if (err != noErr)
-    {
-        hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_MaxKeyFrameInterval failed");
-    }
-
     if (__builtin_available(macOS 12, *))
     {
         if (pv->settings.maxAllowedFrameQP > -1)
         {
             cfValue = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType,
                                      &pv->settings.maxAllowedFrameQP);
-            err = VTSessionSetProperty(pv->session,
-                                       kVTCompressionPropertyKey_MaxAllowedFrameQP,
-                                       cfValue);
+            hb_vt_set_property(pv->session,
+                               kVTCompressionPropertyKey_MaxAllowedFrameQP,
+                               cfValue);
             CFRelease(cfValue);
-            if (err != noErr)
-            {
-                hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_MaxAllowedFrameQP failed");
-            }
         }
     }
 
@@ -1043,28 +1233,20 @@ static OSStatus init_vtsession(hb_work_o
         {
             cfValue = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType,
                                      &pv->settings.minAllowedFrameQP);
-            err = VTSessionSetProperty(pv->session,
-                                       kVTCompressionPropertyKey_MinAllowedFrameQP,
-                                       cfValue);
+            hb_vt_set_property(pv->session,
+                               kVTCompressionPropertyKey_MinAllowedFrameQP,
+                               cfValue);
             CFRelease(cfValue);
-            if (err != noErr)
-            {
-                hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_MinAllowedFrameQP failed");
-            }
         }
 
         if (pv->settings.maxReferenceBufferCount > -1)
         {
             cfValue = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType,
                                      &pv->settings.maxReferenceBufferCount);
-            err = VTSessionSetProperty(pv->session,
-                                       kVTCompressionPropertyKey_ReferenceBufferCount,
-                                       cfValue);
+            hb_vt_set_property(pv->session,
+                               kVTCompressionPropertyKey_ReferenceBufferCount,
+                               cfValue);
             CFRelease(cfValue);
-            if (err != noErr)
-            {
-                hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_ReferenceBufferCount failed");
-            }
         }
     }
 
@@ -1072,15 +1254,39 @@ static OSStatus init_vtsession(hb_work_o
     {
         cfValue = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType,
                                  &pv->settings.maxFrameDelayCount);
-        err = VTSessionSetProperty(pv->session,
-                                   kVTCompressionPropertyKey_MaxFrameDelayCount,
-                                   cfValue);
+        hb_vt_set_property(pv->session,
+                           kVTCompressionPropertyKey_MaxFrameDelayCount,
+                           cfValue);
         CFRelease(cfValue);
-        if (err != noErr)
+    }
+
+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 150000
+    if (__builtin_available(macOS 15, *))
+    {
+        // Control spatial adaptation of the quantization parameter (QP) based on per-frame statistics.
+        if (pv->settings.disableSpatialAdaptiveQP == kCFBooleanTrue)
         {
-            hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_MaxFrameDelayCount failed");
+            int32_t spatialAdaptiveQP = kVTQPModulationLevel_Disable;
+            cfValue = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type,
+                                     &spatialAdaptiveQP);
+            hb_vt_set_property(pv->session,
+                               kVTCompressionPropertyKey_SpatialAdaptiveQPLevel,
+                               cfValue);
+            CFRelease(cfValue);
+        }
+
+        // Requests that the encoder retain the specified number of frames during encoding.
+        if (pv->settings.lookAheadFrameCount >= 0)
+        {
+            cfValue = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType,
+                                     &pv->settings.lookAheadFrameCount);
+            hb_vt_set_property(pv->session,
+                               kVTCompressionPropertyKey_SuggestedLookAheadFrameCount,
+                               cfValue);
+            CFRelease(cfValue);
         }
     }
+#endif
 
     if (
 #if defined(__aarch64__)
@@ -1089,24 +1295,19 @@ static OSStatus init_vtsession(hb_work_o
         pv->settings.vbv.maxrate > 0 &&
         pv->settings.vbv.bufsize > 0)
     {
-        set_data_rate_limits(pv->session, pv->settings.vbv.bufsize, pv->settings.vbv.maxrate);
+        hb_vt_set_data_rate_limits(pv->session, pv->settings.vbv.bufsize, pv->settings.vbv.maxrate);
     }
 
     if (pv->settings.fieldDetail != HB_VT_FIELDORDER_PROGRESSIVE)
     {
         int count = 2;
         cfValue = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &count);
-        err = VTSessionSetProperty(pv->session,
-                                   kVTCompressionPropertyKey_FieldCount,
-                                   cfValue);
+        hb_vt_set_property(pv->session,
+                           kVTCompressionPropertyKey_FieldCount,
+                           cfValue);
         CFRelease(cfValue);
-        if (err != noErr)
-        {
-            hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_FieldCount failed");
-        }
 
         CFStringRef cfStringValue = NULL;
-
         switch (pv->settings.fieldDetail)
         {
             case HB_VT_FIELDORDER_BFF:
@@ -1117,98 +1318,57 @@ static OSStatus init_vtsession(hb_work_o
                 cfStringValue = kCMFormatDescriptionFieldDetail_TemporalTopFirst;
                 break;
         }
-        err = VTSessionSetProperty(pv->session,
-                                   kVTCompressionPropertyKey_FieldDetail,
-                                   cfStringValue);
-        if (err != noErr)
-        {
-            hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_FieldDetail failed");
-        }
+        hb_vt_set_property(pv->session,
+                           kVTCompressionPropertyKey_FieldDetail,
+                           cfStringValue);
     }
 
-    err = VTSessionSetProperty(pv->session,
-                               kVTCompressionPropertyKey_ColorPrimaries,
-                               hb_cv_colr_pri_xlat(pv->settings.color.prim));
-    if (err != noErr)
-    {
-        hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_ColorPrimaries failed");
-    }
-    err = VTSessionSetProperty(pv->session,
-                               kVTCompressionPropertyKey_TransferFunction,
-                               hb_cv_colr_tra_xlat(pv->settings.color.transfer));
-    if (err != noErr)
-    {
-        hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_TransferFunction failed");
-    }
+    hb_vt_set_property(pv->session,
+                       kVTCompressionPropertyKey_ColorPrimaries,
+                       hb_cv_colr_pri_xlat(pv->settings.color.prim));
+    hb_vt_set_property(pv->session,
+                       kVTCompressionPropertyKey_TransferFunction,
+                       hb_cv_colr_tra_xlat(pv->settings.color.transfer));
     CFNumberRef gamma = hb_cv_colr_gamma_xlat(pv->settings.color.transfer);
-    err = VTSessionSetProperty(pv->session,
-                               CFSTR("GammaLevel"),
-                               gamma);
     if (gamma)
     {
+        hb_vt_set_property(pv->session,
+                           CFSTR("GammaLevel"),
+                           gamma);
         CFRelease(gamma);
     }
-
-    if (err != noErr)
-    {
-        hb_log("VTSessionSetProperty: GammaLevel failed");
-    }
-    err = VTSessionSetProperty(pv->session,
-                               kVTCompressionPropertyKey_YCbCrMatrix,
-                               hb_cv_colr_mat_xlat(pv->settings.color.matrix));
-    if (err != noErr)
-    {
-        hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_YCbCrMatrix failed");
-    }
-    err = VTSessionSetProperty(pv->session,
-                               CFSTR("ChromaLocationTopField"),
-                               hb_cv_chroma_loc_xlat(pv->settings.color.chromaLocation));
-    if (err != noErr)
-    {
-        hb_log("VTSessionSetProperty: ChromaLocationTopField failed");
-    }
-    err = VTSessionSetProperty(pv->session,
-                                   CFSTR("ChromaLocationBottomField"),
-                                   hb_cv_chroma_loc_xlat(pv->settings.color.chromaLocation));
-    if (err != noErr)
-    {
-        hb_log("VTSessionSetProperty: ChromaLocationBottomField failed");
-    }
+    hb_vt_set_property(pv->session,
+                       kVTCompressionPropertyKey_YCbCrMatrix,
+                       hb_cv_colr_mat_xlat(pv->settings.color.matrix));
+    hb_vt_set_property(pv->session,
+                       CFSTR("ChromaLocationTopField"),
+                       hb_cv_chroma_loc_xlat(pv->settings.color.chromaLocation));
+    hb_vt_set_property(pv->session,
+                       CFSTR("ChromaLocationBottomField"),
+                       hb_cv_chroma_loc_xlat(pv->settings.color.chromaLocation));
 
     if (supportedProps != NULL && CFDictionaryContainsKey(supportedProps, kVTCompressionPropertyKey_MasteringDisplayColorVolume) &&
         pv->settings.color.masteringDisplay != NULL)
     {
-        err = VTSessionSetProperty(pv->session,
-                                   kVTCompressionPropertyKey_MasteringDisplayColorVolume,
-                                   pv->settings.color.masteringDisplay);
-        if (err != noErr)
-        {
-            hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_MasteringDisplayColorVolume failed");
-        }
+        hb_vt_set_property(pv->session,
+                           kVTCompressionPropertyKey_MasteringDisplayColorVolume,
+                           pv->settings.color.masteringDisplay);
     }
 
     if (supportedProps != NULL && CFDictionaryContainsKey(supportedProps, kVTCompressionPropertyKey_ContentLightLevelInfo) &&
         pv->settings.color.contentLightLevel != NULL)
     {
-        err = VTSessionSetProperty(pv->session,
-                                   kVTCompressionPropertyKey_ContentLightLevelInfo,
-                                   pv->settings.color.contentLightLevel);
-        if (err != noErr)
-        {
-            hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_ContentLightLevelInfo failed");
-        }
+        hb_vt_set_property(pv->session,
+                           kVTCompressionPropertyKey_ContentLightLevelInfo,
+                           pv->settings.color.contentLightLevel);
     }
 
     if (supportedProps != NULL && CFDictionaryContainsKey(supportedProps, CFSTR("AmbientViewingEnvironment")) &&
         pv->settings.color.ambientViewingEnviroment != NULL)
     {
-        err = VTSessionSetProperty(pv->session,
-                                   CFSTR("AmbientViewingEnvironment"),
-                                   pv->settings.color.ambientViewingEnviroment);
-        if (err != noErr)
-        {
-            hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_AmbientViewingEnvironment failed");
-        }
+        hb_vt_set_property(pv->session,
+                           CFSTR("AmbientViewingEnvironment"),
+                           pv->settings.color.ambientViewingEnviroment);
     }
 
     if (__builtin_available(macOS 11.0, *))
@@ -1220,24 +1380,16 @@ static OSStatus init_vtsession(hb_work_o
             // to avoid having two sets of RPUs per frame.
             if (supportedProps != NULL && CFDictionaryContainsKey(supportedProps, kVTCompressionPropertyKey_HDRMetadataInsertionMode))
             {
-                err = VTSessionSetProperty(pv->session,
-                                           kVTCompressionPropertyKey_HDRMetadataInsertionMode,
-                                           kVTHDRMetadataInsertionMode_None);
-                if (err != noErr)
-                {
-                    hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_HDRMetadataInsertionMode failed");
-                }
+                hb_vt_set_property(pv->session,
+                                   kVTCompressionPropertyKey_HDRMetadataInsertionMode,
+                                   kVTHDRMetadataInsertionMode_None);
             }
 
             if (supportedProps != NULL && CFDictionaryContainsKey(supportedProps, kVTCompressionPropertyKey_PreserveDynamicHDRMetadata))
             {
-                err = VTSessionSetProperty(pv->session,
-                                           kVTCompressionPropertyKey_PreserveDynamicHDRMetadata,
-                                           pv->settings.preserveDynamicHDRMetadata);
-                if (err != noErr)
-                {
-                    hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_PreserveDynamicHDRMetadata failed");
-                }
+                hb_vt_set_property(pv->session,
+                                   kVTCompressionPropertyKey_PreserveDynamicHDRMetadata,
+                                   pv->settings.preserveDynamicHDRMetadata);
             }
         }
     }
@@ -1257,88 +1409,60 @@ static OSStatus init_vtsession(hb_work_o
     CFDictionaryAddValue(pixelAspectRatio,
                          kCMFormatDescriptionKey_PixelAspectRatioVerticalSpacing,
                          parDen);
-    err = VTSessionSetProperty(pv->session,
-                               kVTCompressionPropertyKey_PixelAspectRatio,
-                               pixelAspectRatio);
+
+    hb_vt_set_property(pv->session,
+                       kVTCompressionPropertyKey_PixelAspectRatio,
+                       pixelAspectRatio);
     CFRelease(parNum);
     CFRelease(parDen);
     CFRelease(pixelAspectRatio);
-    if (err != noErr)
-    {
-        hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_PixelAspectRatio failed");
-    }
 
     cfValue = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType,
                              &pv->settings.expectedFrameRate);
-    err = VTSessionSetProperty(pv->session,
-                               kVTCompressionPropertyKey_ExpectedFrameRate,
-                               cfValue);
+    hb_vt_set_property(pv->session,
+                       kVTCompressionPropertyKey_ExpectedFrameRate,
+                       cfValue);
     CFRelease(cfValue);
-    if (err != noErr)
-    {
-        hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_ExpectedFrameRate failed");
-    }
 
     if (pv->settings.quality > -1)
     {
         cfValue = CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType,
                                  &pv->settings.quality);
-        err = VTSessionSetProperty(pv->session,
-                                   kVTCompressionPropertyKey_Quality,
-                                   cfValue);
+        hb_vt_set_property(pv->session,
+                           kVTCompressionPropertyKey_Quality,
+                           cfValue);
         CFRelease(cfValue);
-        if (err != noErr)
-        {
-            hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_Quality failed");
-        }
     }
     else
     {
         cfValue = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType,
                                  &pv->settings.averageBitRate);
-        err = VTSessionSetProperty(pv->session,
-                                   kVTCompressionPropertyKey_AverageBitRate,
-                                   cfValue);
+        hb_vt_set_property(pv->session,
+                           kVTCompressionPropertyKey_AverageBitRate,
+                           cfValue);
         CFRelease(cfValue);
-        if (err != noErr)
-        {
-            hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_AverageBitRate failed");
-        }
-
     }
 
-    err = VTSessionSetProperty(pv->session,
-                               kVTCompressionPropertyKey_ProfileLevel,
-                               pv->settings.profileLevel);
-    if (err != noErr)
-    {
-        hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_ProfileLevel failed");
-    }
+    hb_vt_set_property(pv->session,
+                       kVTCompressionPropertyKey_ProfileLevel,
+                       pv->settings.profileLevel);
 
     if (pv->settings.codec == kCMVideoCodecType_H264)
     {
         if (pv->settings.h264.entropyMode)
         {
-            err = VTSessionSetProperty(pv->session,
-                                       kVTCompressionPropertyKey_H264EntropyMode,
-                                       pv->settings.h264.entropyMode);
-            if (err != noErr)
-            {
-                hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_H264EntropyMode failed");
-            }
+            hb_vt_set_property(pv->session,
+                               kVTCompressionPropertyKey_H264EntropyMode,
+                               pv->settings.h264.entropyMode);
         }
         if (pv->settings.h264.maxSliceBytes)
         {
             cfValue = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType,
                                      &pv->settings.h264.maxSliceBytes);
-            err = VTSessionSetProperty(pv->session,
-                                       kVTCompressionPropertyKey_MaxH264SliceBytes,
-                                       cfValue);
+            hb_vt_set_property(pv->session,
+                               kVTCompressionPropertyKey_MaxH264SliceBytes,
+                               cfValue);
             CFRelease(cfValue);
-            if (err != noErr)
-            {
-                hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_MaxH264SliceBytes failed");
-            }
         }
     }
 
@@ -1350,36 +1474,38 @@ static OSStatus init_vtsession(hb_work_o
     // Multi-pass
     if (job->pass_id == HB_PASS_ENCODE_ANALYSIS)
     {
-        char *filename = hb_get_temporary_filename("videotoolbox.log");
+        char *filename = hb_get_temporary_filename("videotoolbox.log");;
+
+        CFURLRef url = NULL;
+        if (filename)
+        {
+            url = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault, (const UInt8 *)filename,
+                                                          strlen(filename), false);
+            free(filename);
+        }
+
+        if (url == NULL)
+        {
+            return -1;
+        }
 
-        CFStringRef path = CFStringCreateWithCString(kCFAllocatorDefault, filename, kCFStringEncodingUTF8);
-        CFURLRef url = CFURLCreateWithFileSystemPath(NULL, path, kCFURLPOSIXPathStyle, FALSE);
         err = VTMultiPassStorageCreate(kCFAllocatorDefault, url, kCMTimeRangeInvalid, NULL, &pv->passStorage);
+        CFRelease(url);
 
         if (err != noErr)
         {
             return err;
         }
-        else
-        {
-            err = VTSessionSetProperty(pv->session,
-                                       kVTCompressionPropertyKey_MultiPassStorage,
-                                       pv->passStorage);
-            if (err != noErr)
-            {
-                hb_log("VTSessionSetProperty: kVTCompressionPropertyKey_MultiPassStorage failed");
-            }
 
-            err =  VTCompressionSessionBeginPass(pv->session, 0, 0);
-            if (err != noErr)
-            {
-                hb_log("VTCompressionSessionBeginPass failed");
-            }
-        }
+        hb_vt_set_property(pv->session,
+                           kVTCompressionPropertyKey_MultiPassStorage,
+                           pv->passStorage);
 
-        CFRelease(url);
-        CFRelease(path);
-        free(filename);
+        err = VTCompressionSessionBeginPass(pv->session, 0, 0);
+        if (err != noErr)
+        {
+            hb_log("VTCompressionSessionBeginPass failed");
+        }
     }
 
     err = VTCompressionSessionPrepareToEncodeFrames(pv->session);
@@ -1412,7 +1538,7 @@ static OSStatus init_vtsession(hb_work_o
     return err;
 }
 
-static void set_cookie(hb_work_object_t *w, CMFormatDescriptionRef format)
+static void hb_vt_set_cookie(hb_work_object_t *w, CMFormatDescriptionRef format)
 {
     CFDictionaryRef extentions = CMFormatDescriptionGetExtensions(format);
     if (!extentions)
@@ -1441,16 +1567,16 @@ static void set_cookie(hb_work_object_t
     }
 }
 
-static OSStatus create_cookie(hb_work_object_t *w, hb_job_t *job, hb_work_private_t *pv)
+static OSStatus hb_vt_create_cookie(hb_work_object_t *w, hb_job_t *job, hb_work_private_t *pv)
 {
     OSStatus err;
     CVPixelBufferRef pix_buf = NULL;
     CVPixelBufferPoolRef pool = NULL;
 
-    err = init_vtsession(w, job, pv, 1);
+    err = hb_vt_init_session(w, job, pv, 1);
     if (err != noErr)
     {
-        return err;
+        goto fail;
     }
 
     pool = VTCompressionSessionGetPixelBufferPool(pv->session);
@@ -1458,7 +1584,8 @@ static OSStatus create_cookie(hb_work_ob
     if (pool == NULL)
     {
         hb_log("VTCompressionSession: VTCompressionSessionGetPixelBufferPool error");
-        return -1;
+        err = -1;
+        goto fail;
     }
 
     err = CVPixelBufferPoolCreatePixelBuffer(NULL, pool, &pix_buf);
@@ -1505,7 +1632,7 @@ static OSStatus create_cookie(hb_work_ob
         {
             pv->format = format;
             CFRetain(pv->format);
-            set_cookie(w, format);
+            hb_vt_set_cookie(w, format);
         }
         CFRelease(sampleBuffer);
     }
@@ -1518,8 +1645,14 @@ fail:
         VTMultiPassStorageClose(pv->passStorage);
         CFRelease(pv->passStorage);
     }
-    CFRelease(pv->session);
-    CFRelease(pv->queue);
+    if (pv->session)
+    {
+        CFRelease(pv->session);
+    }
+    if (pv->queue)
+    {
+        CFRelease(pv->queue);
+    }
     pv->session = NULL;
     pv->passStorage = NULL;
     pv->queue = NULL;
@@ -1527,19 +1660,20 @@ fail:
     return err;
 }
 
-static OSStatus reuse_vtsession(hb_work_object_t *w, hb_job_t * job, hb_work_private_t *pv)
+static OSStatus hb_vt_reuse_session(hb_work_object_t *w, hb_job_t * job, hb_work_private_t *pv)
 {
     OSStatus err = noErr;
 
     hb_interjob_t *interjob = hb_interjob_get(job->h);
-    vt_interjob_t *context = interjob->context;
+    vt_interjob_t *context  = interjob->context;
 
-    set_cookie(w, context->format);
+    hb_vt_set_cookie(w, context->format);
 
-    pv->session = context->session;
+    pv->session     = context->session;
     pv->passStorage = context->passStorage;
-    pv->queue = context->queue;
-    pv->format = context->format;
+    pv->queue       = context->queue;
+    pv->format      = context->format;
+    job->areBframes = context->areBframes;
 
     if (err != noErr)
     {
@@ -1576,24 +1710,6 @@ static OSStatus reuse_vtsession(hb_work_
         return err;
     }
 
-    CFBooleanRef allowFrameReordering;
-    err = VTSessionCopyProperty(pv->session,
-                                kVTCompressionPropertyKey_AllowFrameReordering,
-                                kCFAllocatorDefault,
-                                &allowFrameReordering);
-    if (err != noErr)
-    {
-        hb_log("VTSessionCopyProperty: kVTCompressionPropertyKey_AllowFrameReordering failed");
-    }
-    else
-    {
-        if (CFBooleanGetValue(allowFrameReordering))
-        {
-            job->areBframes = job->vcodec == HB_VCODEC_VT_H265 || job->vcodec == HB_VCODEC_VT_H265_10BIT ? 2 : 1;
-        }
-        CFRelease(allowFrameReordering);
-    }
-
     free(context);
     interjob->context = NULL;
 
@@ -1604,6 +1720,11 @@ int encvt_init(hb_work_object_t *w, hb_j
 {
     OSStatus err;
     hb_work_private_t *pv = calloc(1, sizeof(hb_work_private_t));
+    if (pv == NULL)
+    {
+        *job->die = 1;
+        return -1;
+    }
     w->private_data = pv;
 
     pv->job = job;
@@ -1623,11 +1744,12 @@ int encvt_init(hb_work_object_t *w, hb_j
         return -1;
     }
 
+    pv->attachments = hb_vt_attachments_xlat(pv->job);
     pv->remainingPasses = job->pass_id == HB_PASS_ENCODE_ANALYSIS ? 1 : 0;
 
     if (job->pass_id != HB_PASS_ENCODE_FINAL)
     {
-        err = create_cookie(w, job, pv);
+        err = hb_vt_create_cookie(w, job, pv);
         if (err != noErr)
         {
             hb_log("VTCompressionSession: Magic Cookie Error err=%"PRId64"", (int64_t)err);
@@ -1637,7 +1759,7 @@ int encvt_init(hb_work_object_t *w, hb_j
 
         // Read the actual level and tier and set
         // the Dolby Vision level and data limits
-        if (job->passthru_dynamic_hdr_metadata & DOVI)
+        if (job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_DOVI)
         {
             int level_idc, high_tier;
             hb_parse_h265_extradata(*w->extradata, &level_idc, &high_tier);
@@ -1674,7 +1796,7 @@ int encvt_init(hb_work_object_t *w, hb_j
             }
         }
 
-        err = init_vtsession(w, job, pv, 0);
+        err = hb_vt_init_session(w, job, pv, 0);
         if (err != noErr)
         {
             hb_log("VTCompressionSession: Error creating a VTCompressionSession err=%"PRId64"", (int64_t)err);
@@ -1684,7 +1806,7 @@ int encvt_init(hb_work_object_t *w, hb_j
     }
     else
     {
-        err = reuse_vtsession(w, job, pv);
+        err = hb_vt_reuse_session(w, job, pv);
         if (err != noErr)
         {
             hb_log("VTCompressionSession: Error reusing a VTCompressionSession err=%"PRId64"", (int64_t)err);
@@ -1702,7 +1824,6 @@ void encvt_close(hb_work_object_t * w)
 
     if (pv == NULL)
     {
-        // Not initialized
         return;
     }
 
@@ -1760,245 +1881,20 @@ void encvt_close(hb_work_object_t * w)
     {
         CFRelease(pv->settings.color.ambientViewingEnviroment);
     }
-
-    free(pv);
-    w->private_data = NULL;
-}
-
-static void insert_dynamic_metadata(hb_work_private_t *pv, CMSampleBufferRef sampleBuffer, hb_buffer_t **buf)
-{
-    if (pv->job->passthru_dynamic_hdr_metadata == 0)
+    if (pv->attachments)
     {
-        return;
+        CFRelease(pv->attachments);
     }
 
-    if (pv->nal_length_size == 0)
-    {
-        pv->nal_length_size = hb_vt_get_nal_length_size(sampleBuffer, pv->settings.codec);
-    }
-
-    if (pv->nal_length_size > 4)
-    {
-        hb_log("VTCompressionSession: unknown nal length size");
-        return;
-    }
-
-    hb_buffer_t *buf_in = *buf;
-    hb_sei_t seis[4];
-    size_t seis_count = 0;
-
-    if (buf_in->s.frametype == HB_FRAME_IDR)
-    {
-        if (pv->settings.color.contentLightLevel)
-        {
-            const uint8_t *coll_data = CFDataGetBytePtr(pv->settings.color.contentLightLevel);
-            size_t coll_size = CFDataGetLength(pv->settings.color.contentLightLevel);
-
-            seis[seis_count].type = HB_CONTENT_LIGHT_LEVEL_INFO;
-            seis[seis_count].payload = coll_data;
-            seis[seis_count].payload_size = coll_size;
-
-            seis_count += 1;
-        }
-
-        if (pv->settings.color.masteringDisplay)
-        {
-            const uint8_t *mastering_data = CFDataGetBytePtr(pv->settings.color.masteringDisplay);
-            size_t mastering_size = CFDataGetLength(pv->settings.color.masteringDisplay);
-
-            seis[seis_count].type = HB_MASTERING_DISPLAY_INFO;
-            seis[seis_count].payload = mastering_data;
-            seis[seis_count].payload_size = mastering_size;
-
-            seis_count += 1;
-        }
-    }
-
-    if (pv->job->passthru_dynamic_hdr_metadata & HDR_10_PLUS)
-    {
-        CFDataRef hdrPlus = CMGetAttachment(sampleBuffer, CFSTR("HB_HDR_PLUS"), NULL);
-        if (hdrPlus != NULL)
-        {
-            const uint8_t *sei_data = CFDataGetBytePtr(hdrPlus);
-            size_t sei_size = CFDataGetLength(hdrPlus);
-
-            seis[seis_count].type = HB_USER_DATA_REGISTERED_ITU_T_T35;
-            seis[seis_count].payload = sei_data;
-            seis[seis_count].payload_size = sei_size;
-
-            seis_count += 1;
-        }
-    }
-
-    hb_nal_t nals[1];
-    size_t nals_count = 0;
-
-    if (pv->job->passthru_dynamic_hdr_metadata & DOVI)
-    {
-        CFDataRef rpu = CMGetAttachment(sampleBuffer, CFSTR("HB_DOVI_RPU"), NULL);
-        if (rpu != NULL)
-        {
-            const uint8_t *rpu_data = CFDataGetBytePtr(rpu);
-            size_t rpu_size = CFDataGetLength(rpu);
-
-            nals[nals_count].type = HB_HEVC_NAL_UNIT_UNSPECIFIED;
-            nals[nals_count].payload = rpu_data;
-            nals[nals_count].payload_size = rpu_size;
-
-            nals_count += 1;
-        }
-    }
-
-    if (seis_count || nals_count)
-    {
-        hb_buffer_t *out = hb_isomp4_hevc_nal_bitstream_insert_payloads(buf_in->data, buf_in->size,
-                                                                        seis, seis_count,
-                                                                        nals, nals_count,
-                                                                        pv->nal_length_size);
-        if (out)
-        {
-            out->f = buf_in->f;
-            out->s = buf_in->s;
-            hb_buffer_close(buf);
-            *buf = out;
-        }
-    }
-}
-
-static void set_frametype(CMSampleBufferRef sampleBuffer, hb_buffer_t *buf)
-{
-    buf->s.frametype = HB_FRAME_IDR;
-    buf->s.flags |= HB_FLAG_FRAMETYPE_REF;
-
-    CFArrayRef attachmentsArray = CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, 0);
-    if (CFArrayGetCount(attachmentsArray))
-    {
-        CFDictionaryRef dict = CFArrayGetValueAtIndex(attachmentsArray, 0);
-        CFBooleanRef notSync;
-        if (CFDictionaryGetValueIfPresent(dict, kCMSampleAttachmentKey_NotSync,(const void **) &notSync))
-        {
-            Boolean notSyncValue = CFBooleanGetValue(notSync);
-            if (notSyncValue)
-            {
-                CFBooleanRef b;
-                if (CFDictionaryGetValueIfPresent(dict, kCMSampleAttachmentKey_PartialSync, NULL))
-                {
-                    buf->s.frametype = HB_FRAME_I;
-                }
-                else if (CFDictionaryGetValueIfPresent(dict, kCMSampleAttachmentKey_IsDependedOnByOthers,(const void **) &b))
-                {
-                    Boolean bv = CFBooleanGetValue(b);
-                    if (bv)
-                    {
-                        buf->s.frametype = HB_FRAME_P;
-                    }
-                    else
-                    {
-                        buf->s.frametype = HB_FRAME_B;
-                        buf->s.flags &= ~HB_FLAG_FRAMETYPE_REF;
-                    }
-                }
-                else
-                {
-                   buf->s.frametype = HB_FRAME_P;
-                }
-            }
-        }
-    }
-}
-
-static void set_timestamps(hb_work_private_t *pv, CMSampleBufferRef sampleBuffer, hb_buffer_t *buf)
-{
-    CMTime presentationTimeStamp = CMSampleBufferGetPresentationTimeStamp(sampleBuffer);
-    CMTime duration = CMSampleBufferGetDuration(sampleBuffer);
-
-    buf->s.start = presentationTimeStamp.value;
-    buf->s.stop  = presentationTimeStamp.value + buf->s.duration;
-    buf->s.duration = duration.value;
-
-    // Use the cached frame info to get the start time of Nth frame
-    // Note that start Nth frame != start time this buffer since the
-    // output buffers have rearranged start times.
-    if (pv->frameno_out < pv->job->areBframes)
-    {
-        buf->s.renderOffset = get_frame_start(pv, pv->frameno_out) - pv->dts_delay;
-    }
-    else
-    {
-        buf->s.renderOffset = get_frame_start(pv, pv->frameno_out - pv->job->areBframes);
-    }
-    pv->frameno_out++;
-}
-
-static hb_buffer_t * extract_buf(CMSampleBufferRef sampleBuffer, hb_work_object_t *w)
-{
-    OSStatus err;
-    hb_work_private_t *pv = w->private_data;
-    hb_buffer_t *buf = NULL;
-
-    CMItemCount samplesNum = CMSampleBufferGetNumSamples(sampleBuffer);
-    if (samplesNum > 1)
-    {
-        hb_log("VTCompressionSession: more than 1 sample in sampleBuffer = %ld", samplesNum);
-    }
-
-    CMBlockBufferRef buffer = CMSampleBufferGetDataBuffer(sampleBuffer);
-    if (buffer)
-    {
-        size_t sampleSize = CMBlockBufferGetDataLength(buffer);
-        Boolean isContiguous = CMBlockBufferIsRangeContiguous(buffer, 0, sampleSize);
-
-        if (isContiguous)
-        {
-            size_t lengthAtOffsetOut, totalLengthOut;
-            char * _Nullable dataPointerOut;
-
-            buf = hb_buffer_wrapper_init();
-            err = CMBlockBufferGetDataPointer(buffer, 0, &lengthAtOffsetOut, &totalLengthOut, &dataPointerOut);
-            if (err != kCMBlockBufferNoErr)
-            {
-                hb_log("VTCompressionSession: CMBlockBufferGetDataPointer error");
-            }
-            buf->data = (uint8_t *)dataPointerOut;
-            buf->size = totalLengthOut;
-            buf->storage = sampleBuffer;
-            buf->storage_type = COREMEDIA;
-            CFRetain(sampleBuffer);
-        }
-        else
-        {
-            buf = hb_buffer_init(sampleSize);
-            err = CMBlockBufferCopyDataBytes(buffer, 0, sampleSize, buf->data);
-            if (err != kCMBlockBufferNoErr)
-            {
-                hb_log("VTCompressionSession: CMBlockBufferCopyDataBytes error");
-            }
-        }
-
-        set_frametype(sampleBuffer, buf);
-        set_timestamps(pv, sampleBuffer, buf);
-        insert_dynamic_metadata(pv, sampleBuffer, &buf);
-
-        if (buf->s.frametype == HB_FRAME_IDR)
-        {
-            hb_chapter_dequeue(pv->chapter_queue, buf);
-        }
-    }
-
-    return buf;
+    free(pv);
+    w->private_data = NULL;
 }
 
-static hb_buffer_t *vt_encode(hb_work_object_t *w, hb_buffer_t *in)
+static void hb_vt_send(hb_work_private_t *pv, hb_buffer_t *in)
 {
-    OSStatus err;
-    hb_work_private_t *pv = w->private_data;
-    hb_job_t *job = pv->job;
-
-    // Create a CVPixelBuffer to wrap the frame data
-    CVPixelBufferRef pix_buffer = NULL;
-    err = wrap_buf(pv, in, &pix_buffer);
+    CVPixelBufferRef pix_buf = hb_vt_get_pix_buf(pv, in);
 
-    if (kCVReturnSuccess != err)
+    if (pix_buf == NULL)
     {
         hb_buffer_close(&in);
         hb_log("VTCompressionSession: CVPixelBuffer error");
@@ -2006,7 +1902,7 @@ static hb_buffer_t *vt_encode(hb_work_ob
     else
     {
         CFDictionaryRef frameProperties = NULL;
-        if (in->s.new_chap && job->chapter_markers)
+        if (in->s.new_chap && pv->job->chapter_markers)
         {
             // macOS Sonoma has got an unfixed bug that makes the whole
             // system crash and restart on M* Ultra if we force a keyframe
@@ -2023,22 +1919,24 @@ static hb_buffer_t *vt_encode(hb_work_ob
             hb_chapter_enqueue(pv->chapter_queue, in);
         }
 
+        hb_cv_set_attachments(pix_buf, pv->attachments);
+
         // VideoToolbox DTS are greater than PTS
         // So we remember the PTS values and compute DTS ourselves.
-        save_frame_info(pv, in);
-        compute_dts_offset(pv, in);
+        hb_vt_save_frame_info(pv, in);
+        hb_vt_compute_dts_offset(pv, in);
         pv->frameno_in++;
 
         // Send the frame to be encoded
-        err = VTCompressionSessionEncodeFrame(
-                                              pv->session,
-                                              pix_buffer,
-                                              CMTimeMake(in->s.start, pv->settings.timescale),
-                                              CMTimeMake(in->s.duration, pv->settings.timescale),
-                                              frameProperties,
-                                              in,
-                                              NULL);
-        CVPixelBufferRelease(pix_buffer);
+        OSStatus err = VTCompressionSessionEncodeFrame(
+                                                       pv->session,
+                                                       pix_buf,
+                                                       CMTimeMake(in->s.start, pv->settings.timescale),
+                                                       CMTimeMake(in->s.duration, pv->settings.timescale),
+                                                       frameProperties,
+                                                       in,
+                                                       NULL);
+        CVPixelBufferRelease(pix_buf);
 
         if (err)
         {
@@ -2050,102 +1948,112 @@ static hb_buffer_t *vt_encode(hb_work_ob
             CFRelease(frameProperties);
         }
     }
+}
 
+static hb_buffer_t * hb_vt_receive(hb_work_private_t *pv)
+{
     if (pv->frameno_in <= pv->job->areBframes)
     {
-        // dts_delay not yet set. queue up buffers till it is set.
+        // dts_delay not yet set. Queue up buffers till it is set
         return NULL;
     }
 
-    // Return a frame if ready
     CMSampleBufferRef sampleBuffer = (CMSampleBufferRef)CMSimpleQueueDequeue(pv->queue);
-    hb_buffer_t       *buf_out = NULL;
+    hb_buffer_t      *buf_out = NULL;
 
     if (sampleBuffer)
     {
-        buf_out = extract_buf(sampleBuffer, w);
+        buf_out = hb_vt_get_buf(sampleBuffer, pv);
         CFRelease(sampleBuffer);
     }
-
     return buf_out;
 }
 
-int encvt_work(hb_work_object_t *w, hb_buffer_t **buf_in, hb_buffer_t **buf_out)
+static void hb_vt_encode(hb_work_private_t *pv, hb_buffer_t *in, hb_buffer_list_t *list)
 {
-    hb_work_private_t *pv = w->private_data;
-    hb_buffer_t *in = *buf_in;
+    hb_vt_send(pv, in);
 
-    if (in->s.flags & HB_BUF_FLAG_EOF)
+    hb_buffer_t *out;
+    while ((out = hb_vt_receive(pv)))
     {
-        // EOF on input. Flush any frames still in the decoder then
-        // send the eof downstream to tell the muxer we're done.
-        CMSampleBufferRef sampleBuffer = NULL;
-        hb_buffer_list_t list;
+        hb_buffer_list_append(list, out);
+    }
+}
+
+static void hb_vt_flush(hb_work_private_t *pv, hb_buffer_t *in, hb_buffer_list_t *list)
+{
+    VTCompressionSessionCompleteFrames(pv->session, kCMTimeIndefinite);
 
-        hb_buffer_list_clear(&list);
-        VTCompressionSessionCompleteFrames(pv->session, kCMTimeIndefinite);
+    hb_buffer_t *out;
+    while ((out = hb_vt_receive(pv)))
+    {
+        hb_buffer_list_append(list, out);
+    }
 
-        while ((sampleBuffer = (CMSampleBufferRef) CMSimpleQueueDequeue(pv->queue)))
-        {
-            hb_buffer_t *buf = extract_buf(sampleBuffer, w);
-            CFRelease(sampleBuffer);
+    // Passthru the EOF to the end of the chain
+    hb_buffer_list_append(list, in);
+}
 
-            if (buf)
-            {
-                hb_buffer_list_append(&list, buf);
-            }
-            else
-            {
-                break;
-            }
+static void hb_vt_end_pass(hb_work_private_t *pv)
+{
+    if (pv->job->pass_id == HB_PASS_ENCODE_ANALYSIS)
+    {
+        OSStatus err = noErr;
+        Boolean furtherPassesRequestedOut;
+        err = VTCompressionSessionEndPass(pv->session,
+                                          &furtherPassesRequestedOut,
+                                          0);
+        if (err != noErr)
+        {
+            hb_log("VTCompressionSessionEndPass error");
+        }
+        if (furtherPassesRequestedOut == false)
+        {
+            hb_log("VTCompressionSessionEndPass: no additional pass requested");
         }
 
-        // add the EOF to the end of the chain
-        hb_buffer_list_append(&list, in);
+        // Save the sessions and the related context for the next pass
+        vt_interjob_t *context = (vt_interjob_t *)malloc(sizeof(vt_interjob_t));
+        context->session     = pv->session;
+        context->passStorage = pv->passStorage;
+        context->queue       = pv->queue;
+        context->format      = pv->format;
+        context->areBframes  = pv->job->areBframes;
 
-        *buf_out = hb_buffer_list_clear(&list);
-        *buf_in = NULL;
+        hb_interjob_t *interjob = hb_interjob_get(pv->job->h);
+        interjob->context = context;
+    }
+    else if (pv->job->pass_id == HB_PASS_ENCODE_FINAL)
+    {
+        VTCompressionSessionEndPass(pv->session, NULL, 0);
+    }
+}
 
-        hb_job_t *job = pv->job;
+int encvt_work(hb_work_object_t *w, hb_buffer_t **buf_in, hb_buffer_t **buf_out)
+{
+    hb_work_private_t *pv = w->private_data;
+    hb_buffer_t *in = *buf_in;
+    hb_buffer_list_t list;
 
-        if (job->pass_id == HB_PASS_ENCODE_ANALYSIS)
-        {
-            OSStatus err = noErr;
-            Boolean furtherPassesRequestedOut;
-            err = VTCompressionSessionEndPass(pv->session,
-                                              &furtherPassesRequestedOut,
-                                              0);
-            if (err != noErr)
-            {
-                hb_log("VTCompressionSessionEndPass error");
-            }
-            if (furtherPassesRequestedOut == false)
-            {
-                hb_log("VTCompressionSessionEndPass: no additional pass requested");
-            }
+    // Take ownership of the input buffer, avoid a memcpy
+    *buf_in = NULL;
+    hb_buffer_list_clear(&list);
 
-            // Save the sessions and the related context
-            // for the next pass.
-            vt_interjob_t *context = (vt_interjob_t *)malloc(sizeof(vt_interjob_t));
-            context->session = pv->session;
-            context->passStorage = pv->passStorage;
-            context->queue = pv->queue;
-            context->format = pv->format;
+    if (in->s.flags & HB_BUF_FLAG_EOF)
+    {
+        // EOF on input. Flush any frames still in the decoder then
+        // send the eof downstream to tell the muxer we're done.
+        hb_vt_flush(pv, in, &list);
+        *buf_out = hb_buffer_list_clear(&list);
 
-            hb_interjob_t *interjob = hb_interjob_get(job->h);
-            interjob->context = context;
-        }
-        else if (job->pass_id == HB_PASS_ENCODE_FINAL)
-        {
-            VTCompressionSessionEndPass(pv->session, NULL, 0);
-        }
+        hb_vt_end_pass(pv);
 
         return HB_WORK_DONE;
     }
 
     // Not EOF - encode the packet
-    *buf_out = vt_encode(w, in);
-    // Take ownership of the input buffer, avoid a memcpy
-    *buf_in = NULL;
+    hb_vt_encode(pv, in, &list);
+    *buf_out = hb_buffer_list_clear(&list);
+
     return HB_WORK_OK;
 }
diff -Naupr a/libhb/platform/macosx/grayscale_vt.m b/libhb/platform/macosx/grayscale_vt.m
--- a/libhb/platform/macosx/grayscale_vt.m	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/grayscale_vt.m	2025-03-31 11:55:35.247884328 +0200
@@ -1,6 +1,6 @@
 /* grayscale_vt.m
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -196,13 +196,13 @@ static hb_buffer_t * filter_frame(hb_fil
             continue;
         }
 
-        format[i] = hb_metal_pix_fmt_from_component(comp, &channels);
+        format[i] = hb_metal_pix_fmt_from_component(comp, 0, &channels);
         if (format[i] == MTLPixelFormatInvalid)
         {
             goto fail;
         }
 
-        src[i]     = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_src, i, format[i]);
+        src[i]     = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_src, i, channels, format[i]);
         tex_src[i] = CVMetalTextureGetTexture(src[i]);
     }
 
@@ -214,7 +214,7 @@ static hb_buffer_t * filter_frame(hb_fil
             continue;
         }
 
-        CVMetalTextureRef dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, i, format[i]);
+        CVMetalTextureRef dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, i, channels, format[i]);
         id<MTLTexture> tex_dest = CVMetalTextureGetTexture(dest);
 
         call_kernel(pv, tex_dest, tex_src, i);
@@ -230,7 +230,9 @@ static hb_buffer_t * filter_frame(hb_fil
         }
     }
 
+#if defined(HB_VT_PROPAGATE_ATTACHMENTS)
     CVBufferPropagateAttachments(cv_src, cv_dest);
+#endif
 
     out = hb_buffer_wrapper_init();
     out->storage_type      = COREMEDIA;
diff -Naupr a/libhb/platform/macosx/lapsharp_vt.m b/libhb/platform/macosx/lapsharp_vt.m
--- a/libhb/platform/macosx/lapsharp_vt.m	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/lapsharp_vt.m	2025-03-31 11:55:35.247884328 +0200
@@ -1,6 +1,6 @@
 /* lapsharp_vt.m
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -339,14 +339,14 @@ static hb_buffer_t * filter_frame(hb_fil
         }
 
         int channels;
-        const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, &channels);
+        const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, 0, &channels);
         if (format == MTLPixelFormatInvalid)
         {
             goto fail;
         }
 
-        CVMetalTextureRef src  = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_src, i, format);
-        CVMetalTextureRef dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, i, format);
+        CVMetalTextureRef src  = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_src, i, channels, format);
+        CVMetalTextureRef dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, i, channels, format);
 
         id<MTLTexture> tex_src  = CVMetalTextureGetTexture(src);
         id<MTLTexture> tex_dest = CVMetalTextureGetTexture(dest);
@@ -357,7 +357,9 @@ static hb_buffer_t * filter_frame(hb_fil
         CFRelease(dest);
     }
 
+#if defined(HB_VT_PROPAGATE_ATTACHMENTS)
     CVBufferPropagateAttachments(cv_src, cv_dest);
+#endif
 
     out = hb_buffer_wrapper_init();
     out->storage_type      = COREMEDIA;
diff -Naupr a/libhb/platform/macosx/metal_utils.h b/libhb/platform/macosx/metal_utils.h
--- a/libhb/platform/macosx/metal_utils.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/metal_utils.h	2025-03-31 11:55:35.247884328 +0200
@@ -1,6 +1,6 @@
 /* utils.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -50,11 +50,14 @@ void hb_metal_compute_encoder_dispatch_f
                                                               NSUInteger width, NSUInteger height,
                                                               NSUInteger w, NSUInteger h);
 
-MTLPixelFormat hb_metal_pix_fmt_from_component(const AVComponentDescriptor *comp, int *channels_out);
+MTLPixelFormat hb_metal_pix_fmt_from_component(const AVComponentDescriptor *comp,
+                                               int readwrite,
+                                               int *channels_out);
 
 CVMetalTextureRef hb_metal_create_texture_from_pixbuf(CVMetalTextureCacheRef textureCache,
                                                CVPixelBufferRef pixbuf,
                                                int plane,
+                                               int channels,
                                                MTLPixelFormat format);
 
 int hb_metal_add_pipeline(hb_metal_context_t *ctx, const char *function_name,
diff -Naupr a/libhb/platform/macosx/metal_utils.m b/libhb/platform/macosx/metal_utils.m
--- a/libhb/platform/macosx/metal_utils.m	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/metal_utils.m	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* utils.m
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -141,7 +141,7 @@ int hb_metal_add_pipeline(hb_metal_conte
     }
     if (!ctx->functions[index])
     {
-        hb_error("metal: failed to create Metal function");
+        hb_error("metal: failed to create Metal function: %s", err.description.UTF8String);
         return -1;
     }
     ctx->pipelines[index] = [ctx->device newComputePipelineStateWithFunction:ctx->functions[index] error:&err];
@@ -151,7 +151,6 @@ int hb_metal_add_pipeline(hb_metal_conte
         return -1;
     }
     return 0;
-
 }
 
 void hb_metal_context_close(hb_metal_context_t **_ctx)
@@ -229,27 +228,49 @@ void hb_metal_compute_encoder_dispatch_f
     [encoder dispatchThreadgroups:threadgroups threadsPerThreadgroup:threadsPerThreadgroup];
 }
 
-MTLPixelFormat hb_metal_pix_fmt_from_component(const AVComponentDescriptor *comp, int *channels_out)
+MTLPixelFormat hb_metal_pix_fmt_from_component(const AVComponentDescriptor *comp, int readwrite, int *channels_out)
 {
     MTLPixelFormat format;
     int pixel_size = (comp->depth + comp->shift) / 8;
     int channels = comp->step / pixel_size;
+
     if (pixel_size > 2 || channels > 2)
     {
         hb_log("metal: unsupported pixel format");
         return MTLPixelFormatInvalid;
     }
-    switch (pixel_size)
+
+    // Metal has additional limitation in
+    // readwrite pixel formats
+    if (readwrite)
     {
-        case 1:
-            format = channels == 1 ? MTLPixelFormatR8Unorm : MTLPixelFormatRG8Unorm;
-            break;
-        case 2:
-            format = channels == 1 ? MTLPixelFormatR16Unorm : MTLPixelFormatRG16Unorm;
-            break;
-        default:
-            hb_log("metal: unsupported pixel format");
-            return MTLPixelFormatInvalid;
+        switch (pixel_size)
+        {
+            case 1:
+                format = MTLPixelFormatR8Uint;
+                break;
+            case 2:
+                format = MTLPixelFormatR16Uint;
+                break;
+            default:
+                hb_log("metal: unsupported pixel format");
+                return MTLPixelFormatInvalid;
+        }
+    }
+    else
+    {
+        switch (pixel_size)
+        {
+            case 1:
+                format = channels == 1 ? MTLPixelFormatR8Unorm : MTLPixelFormatRG8Unorm;
+                break;
+            case 2:
+                format = channels == 1 ? MTLPixelFormatR16Unorm : MTLPixelFormatRG16Unorm;
+                break;
+            default:
+                hb_log("metal: unsupported pixel format");
+                return MTLPixelFormatInvalid;
+        }
     }
 
     *channels_out = channels;
@@ -259,22 +280,36 @@ MTLPixelFormat hb_metal_pix_fmt_from_com
 CVMetalTextureRef hb_metal_create_texture_from_pixbuf(CVMetalTextureCacheRef textureCache,
                                                CVPixelBufferRef pixbuf,
                                                int plane,
+                                               int channels,
                                                MTLPixelFormat format)
 {
     CVMetalTextureRef tex = NULL;
     CVReturn ret;
 
+    int width  = CVPixelBufferGetWidthOfPlane(pixbuf, plane);
+    int height = CVPixelBufferGetHeightOfPlane(pixbuf, plane);
+
+    if (channels == 2)
+    {
+        if (format == MTLPixelFormatR8Uint ||
+            format == MTLPixelFormatR16Uint)
+        {
+            width *= channels;
+        }
+    }
+
     ret = CVMetalTextureCacheCreateTextureFromImage(
         NULL,
         textureCache,
         pixbuf,
         NULL,
         format,
-        CVPixelBufferGetWidthOfPlane(pixbuf, plane),
-        CVPixelBufferGetHeightOfPlane(pixbuf, plane),
+        width,
+        height,
         plane,
         &tex
     );
+
     if (ret != kCVReturnSuccess)
     {
         hb_log("metal: failed to create CVMetalTexture from image: %d", ret);
diff -Naupr a/libhb/platform/macosx/motion_metric_vt.m b/libhb/platform/macosx/motion_metric_vt.m
--- a/libhb/platform/macosx/motion_metric_vt.m	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/motion_metric_vt.m	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* motion_metric_vt.m
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -122,14 +122,14 @@ static float motion_metric(hb_motion_met
     const AVComponentDescriptor *comp = &pv->desc->comp[0];
 
     int channels;
-    const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, &channels);
+    const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, 0, &channels);
     if (format == MTLPixelFormatInvalid)
     {
         goto fail;
     }
 
-    CVMetalTextureRef ref_a = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_a, 0, format);
-    CVMetalTextureRef ref_b = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_b, 0, format);
+    CVMetalTextureRef ref_a = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_a, 0, channels, format);
+    CVMetalTextureRef ref_b = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_b, 0, channels, format);
 
     id<MTLTexture> tex_a = CVMetalTextureGetTexture(ref_a);
     id<MTLTexture> tex_b = CVMetalTextureGetTexture(ref_b);
diff -Naupr a/libhb/platform/macosx/pad_vt.m b/libhb/platform/macosx/pad_vt.m
--- a/libhb/platform/macosx/pad_vt.m	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/pad_vt.m	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* pad_vt.m
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -265,14 +265,14 @@ static hb_buffer_t * filter_frame(hb_fil
         }
 
         int channels;
-        const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, &channels);
+        const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, 0, &channels);
         if (format == MTLPixelFormatInvalid)
         {
             goto fail;
         }
 
-        CVMetalTextureRef src  = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_src, i, format);
-        CVMetalTextureRef dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, i, format);
+        CVMetalTextureRef src  = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_src, i, channels, format);
+        CVMetalTextureRef dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, i, channels, format);
 
         id<MTLTexture> tex_src  = CVMetalTextureGetTexture(src);
         id<MTLTexture> tex_dest = CVMetalTextureGetTexture(dest);
@@ -283,7 +283,9 @@ static hb_buffer_t * filter_frame(hb_fil
         CFRelease(dest);
     }
 
+#if defined(HB_VT_PROPAGATE_ATTACHMENTS)
     CVBufferPropagateAttachments(cv_src, cv_dest);
+#endif
 
     out = hb_buffer_wrapper_init();
     out->storage_type      = COREMEDIA;
diff -Naupr a/libhb/platform/macosx/prefilter_vt.c b/libhb/platform/macosx/prefilter_vt.c
--- a/libhb/platform/macosx/prefilter_vt.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/prefilter_vt.c	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* prefilter_vt.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/platform/macosx/rotate_vt.c b/libhb/platform/macosx/rotate_vt.c
--- a/libhb/platform/macosx/rotate_vt.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/rotate_vt.c	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* rotate_vt.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -18,6 +18,7 @@ struct hb_filter_private_s
     VTPixelRotationSessionRef session;
 #pragma GCC diagnostic pop
     CVPixelBufferPoolRef      pool;
+    CFDictionaryRef           attachments;
 
     hb_filter_init_t          input;
     hb_filter_init_t          output;
@@ -136,6 +137,15 @@ static int rotate_vt_init(hb_filter_obje
         return -1;
     }
 
+    CFMutableDictionaryRef attachments = CFDictionaryCreateMutable(NULL, 0,
+                                                                   &kCFTypeDictionaryKeyCallBacks,
+                                                                   &kCFTypeDictionaryValueCallBacks);
+    hb_cv_add_color_tag(attachments,
+                        init->color_prim, init->color_transfer,
+                        init->color_matrix, init->chroma_location);
+    pv->attachments = attachments;
+
+
     init->geometry.width  = width;
     init->geometry.height = height;
     init->geometry.par    = par;
@@ -166,6 +176,10 @@ static void rotate_vt_close(hb_filter_ob
     {
         CVPixelBufferPoolRelease(pv->pool);
     }
+    if (pv->attachments)
+    {
+        CFRelease(pv->attachments);
+    }
 
     free(pv);
     filter->private_data = NULL;
@@ -194,6 +208,7 @@ static int rotate_vt_work(hb_filter_obje
         hb_log("rotate_vt: extract_buf failed");
         return HB_FILTER_FAILED;
     }
+    hb_cv_set_attachments(source_buf, pv->attachments);
 
     CVPixelBufferRef dest_buf = NULL;
     err = CVPixelBufferPoolCreatePixelBuffer(kCFAllocatorDefault, pv->pool, &dest_buf);
diff -Naupr a/libhb/platform/macosx/shaders/blend_vt.metal b/libhb/platform/macosx/shaders/blend_vt.metal
--- a/libhb/platform/macosx/shaders/blend_vt.metal	1970-01-01 01:00:00.000000000 +0100
+++ b/libhb/platform/macosx/shaders/blend_vt.metal	2025-03-31 11:55:35.248884310 +0200
@@ -0,0 +1,213 @@
+/* blend_vt.metal
+
+   Copyright (c) 2003-2025 HandBrake Team
+
+   This file is part of the HandBrake source code
+   Homepage: <http://handbrake.fr/>.
+   It may be used under the terms of the GNU General Public License v2.
+   For full terms see the file COPYING file or visit http://www.gnu.org/licenses/gpl-2.0.html
+ */
+
+#include <metal_stdlib>
+#include <metal_integer>
+#include <metal_texture>
+
+/*
+ * Parameters
+ */
+
+constant uint16_t plane      [[function_constant(0)]];
+constant uint16_t channels   [[function_constant(1)]];
+constant uint16_t subw       [[function_constant(2)]];
+constant uint16_t subh       [[function_constant(3)]];
+constant uint16_t osubw      [[function_constant(4)]];
+constant uint16_t osubh      [[function_constant(5)]];
+constant uint16_t shift      [[function_constant(6)]];
+constant uint32_t maxv       [[function_constant(7)]];
+constant bool subsample      [[function_constant(8)]];
+
+struct params {
+    uint16_t x;
+    uint16_t y;
+    uint16_t xc;
+    uint16_t yc;
+    uint16_t width;
+    uint16_t height;
+};
+
+using namespace metal;
+
+/*
+ * Blend helpers
+ */
+
+template <typename T>
+T blend_pixel(T y_out, T y_in, T a_in)
+{
+    return ((uint32_t)y_out * (maxv - a_in) + (uint32_t)y_in * a_in) / maxv;
+}
+
+template <typename T>
+T pos_dst_y(T pos, uint16_t x, uint16_t y)
+{
+    return T(pos.x + x, pos.y + y);
+}
+
+template <typename T>
+T pos_dst_u(T pos, uint16_t x, uint16_t y)
+{
+    return T((pos.x + (x >> subw)) * channels,
+              pos.y + (y >> subh));
+}
+
+template <typename T>
+T pos_dst_v(T pos, uint16_t x, uint16_t y)
+{
+    return T((pos.x + (x >> subw)) * channels + 1,
+              pos.y + (y >> subh));
+}
+
+template <typename T>
+T pos_uv_subsample(T pos, uint16_t x, uint16_t y)
+{
+    uint16_t uvsubw = subw - osubw;
+    uint16_t uvsubh = subh - osubh;
+
+    return T((pos.x << uvsubw) + (x >> osubw),
+             (pos.y << uvsubh) + (y >> osubh));
+}
+
+template <typename T>
+T pos_a(T pos, uint16_t x, uint16_t y)
+{
+    return ushort2((pos.x << subw) + x, (pos.y << subh) + y);
+}
+
+template <typename T>
+T blend_pixel_y(
+    texture2d<T, access::read_write> dst,
+    texture2d<T, access::read> overlay_y,
+    texture2d<T, access::read> overlay_a,
+    constant params& p,
+    ushort2 pos)
+{
+    ushort2 pos_ya = pos_dst_y(pos, p.x, p.y);
+
+    T y_in  = overlay_y.read(pos_ya).x << shift;
+    T a_in  = overlay_a.read(pos_ya).x << shift;
+    T y_out = dst.read(pos_ya).x;
+
+    return blend_pixel(y_out, y_in, a_in);
+}
+
+template <typename T, typename V>
+V blend_pixel_uv(
+    texture2d<T, access::read_write> dst,
+    texture2d<T, access::read> overlay_u,
+    texture2d<T, access::read> overlay_v,
+    texture2d<T, access::read> overlay_a,
+    constant params& p,
+    ushort2 pos)
+{
+    ushort2 pos_uv = ushort2(pos.x + (p.x >> osubw), pos.y + (p.y >> osubh));
+    T u_in = overlay_u.read(pos_uv).x << shift;
+    T v_in = overlay_v.read(pos_uv).x << shift;
+
+    T u_out = dst.read(pos_dst_u(pos, p.x, p.y)).x;
+    T v_out = dst.read(pos_dst_v(pos, p.x, p.y)).x;
+    T a_in = overlay_a.read(pos_a(pos, p.x, p.y)).x << shift;
+
+    return V(blend_pixel(u_out, u_in, a_in),
+             blend_pixel(v_out, v_in, a_in));
+}
+
+template <typename T, typename V>
+V blend_subsample_pixel_uv(
+    texture2d<T, access::read_write> dst,
+    texture2d<T, access::read> overlay_u,
+    texture2d<T, access::read> overlay_v,
+    texture2d<T, access::read> overlay_a,
+    constant uint *chroma_coeffs,
+    constant params& p,
+    ushort2 pos)
+{
+    T u_out = dst.read(pos_dst_u(pos, p.xc, p.yc)).x;
+    T v_out = dst.read(pos_dst_v(pos, p.xc, p.yc)).x;
+
+    // Perform chromaloc-aware subsampling and blending
+    uint32_t accu_a = 0, accu_b = 0, accu_c = 0;
+    ushort2 pos_uv = pos_uv_subsample(pos, p.xc, p.yc);
+
+    for (uint16_t yz = 0; yz < 1 << subh; yz++) {
+        for (uint16_t xz = 0; xz < 1 << subw; xz++) {
+            // Weight of the current chroma sample
+            uint32_t coeff = *(chroma_coeffs + xz) * *(chroma_coeffs + 4 + yz);
+            uint32_t res_u = u_out;
+            uint32_t res_v = v_out;
+
+            // Chroma sampled area overlap with bitmap
+            if ((pos.x > 0 || p.xc == p.x) && pos.x < p.width &&
+                (pos.y > 0 || p.yc == p.y) && pos.y < p.height) {
+                ushort2 offset = ushort2(xz, yz);
+                T a_in = overlay_a.read(pos_a(pos, p.xc, p.yc) + offset).x << shift;
+                T u_in = overlay_u.read(pos_uv + offset).x << shift;
+                T v_in = overlay_v.read(pos_uv + offset).x << shift;
+
+                res_u *= (maxv - a_in);
+                res_u  = (res_u + ((uint32_t)u_in) * a_in + (maxv >> 1)) / maxv;
+
+                res_v *= (maxv - a_in);
+                res_v  = (res_v + ((uint32_t)v_in) * a_in + (maxv >> 1)) / maxv;
+            }
+
+            // Accumulate
+            accu_a += coeff * res_u;
+            accu_b += coeff * res_v;
+            accu_c += coeff;
+        }
+    }
+
+    if (accu_c) {
+        return V((accu_a + (accu_c >> 1)) / accu_c,
+                 (accu_b + (accu_c >> 1)) / accu_c);
+    }
+    else {
+        return V(u_out, v_out);
+    }
+}
+
+/*
+ * Kernel dispatch
+ */
+
+kernel void blend(
+    texture2d<ushort, access::read_write> dst [[texture(0)]],
+    texture2d<ushort, access::read> overlay_y [[texture(1)]],
+    texture2d<ushort, access::read> overlay_u [[texture(2)]],
+    texture2d<ushort, access::read> overlay_v [[texture(3)]],
+    texture2d<ushort, access::read> overlay_a [[texture(4)]],
+    constant uint *chroma_coeffs [[buffer(0)]],
+    constant params& p           [[buffer(1)]],
+    ushort2 pos [[thread_position_in_grid]])
+{
+    if (plane == 0) {
+        ushort value = blend_pixel_y(dst, overlay_y, overlay_a,
+                                     p, pos);
+        dst.write(value, pos_dst_y(pos, p.x, p.y));
+    }
+    else {
+        ushort2 value;
+        if (subsample) {
+            value = blend_subsample_pixel_uv<ushort, ushort2>(dst, overlay_u,
+                                                              overlay_v, overlay_a,
+                                                              chroma_coeffs, p, pos);
+        }
+        else {
+            value = blend_pixel_uv<ushort, ushort2>(dst, overlay_u,
+                                                    overlay_v, overlay_a,
+                                                    p, pos);
+        }
+        dst.write(value.x, pos_dst_u(pos, p.x, p.y));
+        dst.write(value.y, pos_dst_v(pos, p.x, p.y));
+    }
+}
diff -Naupr a/libhb/platform/macosx/shaders/bwdif_vt.metal b/libhb/platform/macosx/shaders/bwdif_vt.metal
--- a/libhb/platform/macosx/shaders/bwdif_vt.metal	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/shaders/bwdif_vt.metal	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* bwdif.metal
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    Copyright (c) 2019 Philip Langdale <philipl@overt.org>
 
    port of FFmpeg vf_bwdif_cuda.
diff -Naupr a/libhb/platform/macosx/shaders/chroma_smooth_vt.metal b/libhb/platform/macosx/shaders/chroma_smooth_vt.metal
--- a/libhb/platform/macosx/shaders/chroma_smooth_vt.metal	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/shaders/chroma_smooth_vt.metal	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* chroma_smooth.metal
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
 
    port of FFmpeg unsharp.cl.
 
diff -Naupr a/libhb/platform/macosx/shaders/comb_detect_vt.metal b/libhb/platform/macosx/shaders/comb_detect_vt.metal
--- a/libhb/platform/macosx/shaders/comb_detect_vt.metal	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/shaders/comb_detect_vt.metal	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* comb_detect.metal
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
 
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
diff -Naupr a/libhb/platform/macosx/shaders/grayscale_vt.metal b/libhb/platform/macosx/shaders/grayscale_vt.metal
--- a/libhb/platform/macosx/shaders/grayscale_vt.metal	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/shaders/grayscale_vt.metal	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* grayscale.metal
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    Copyright (c) 2021 Paul B Mahol
 
    port of vf_monochrome FFmpeg.
diff -Naupr a/libhb/platform/macosx/shaders/lapsharp_vt.metal b/libhb/platform/macosx/shaders/lapsharp_vt.metal
--- a/libhb/platform/macosx/shaders/lapsharp_vt.metal	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/shaders/lapsharp_vt.metal	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* lapsharp.metal
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
 
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
diff -Naupr a/libhb/platform/macosx/shaders/motion_metric_vt.metal b/libhb/platform/macosx/shaders/motion_metric_vt.metal
--- a/libhb/platform/macosx/shaders/motion_metric_vt.metal	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/shaders/motion_metric_vt.metal	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* motion_metric_vt.metal
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
 
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
diff -Naupr a/libhb/platform/macosx/shaders/pad_vt.metal b/libhb/platform/macosx/shaders/pad_vt.metal
--- a/libhb/platform/macosx/shaders/pad_vt.metal	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/shaders/pad_vt.metal	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* pad.metal
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
 
    port of FFmpeg pad.cl.
 
diff -Naupr a/libhb/platform/macosx/shaders/unsharp_vt.metal b/libhb/platform/macosx/shaders/unsharp_vt.metal
--- a/libhb/platform/macosx/shaders/unsharp_vt.metal	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/shaders/unsharp_vt.metal	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* unsharp.metal
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
 
    port of FFmpeg unsharp.cl.
 
diff -Naupr a/libhb/platform/macosx/unsharp_vt.m b/libhb/platform/macosx/unsharp_vt.m
--- a/libhb/platform/macosx/unsharp_vt.m	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/unsharp_vt.m	2025-03-31 11:55:35.248884310 +0200
@@ -1,7 +1,7 @@
 /* unsharp_vt.m
 
    Copyright (c) 2002 Rmi Guyomarch <rguyom at pobox.com>
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -325,14 +325,14 @@ static hb_buffer_t * filter_frame(hb_fil
         }
 
         int channels;
-        const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, &channels);
+        const MTLPixelFormat format = hb_metal_pix_fmt_from_component(comp, 0, &channels);
         if (format == MTLPixelFormatInvalid)
         {
             goto fail;
         }
 
-        CVMetalTextureRef src  = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_src, i, format);
-        CVMetalTextureRef dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, i, format);
+        CVMetalTextureRef src  = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_src, i, channels, format);
+        CVMetalTextureRef dest = hb_metal_create_texture_from_pixbuf(pv->mtl->cache, cv_dest, i, channels, format);
 
         id<MTLTexture> tex_src  = CVMetalTextureGetTexture(src);
         id<MTLTexture> tex_dest = CVMetalTextureGetTexture(dest);
@@ -343,7 +343,9 @@ static hb_buffer_t * filter_frame(hb_fil
         CFRelease(dest);
     }
 
+#if defined(HB_VT_PROPAGATE_ATTACHMENTS)
     CVBufferPropagateAttachments(cv_src, cv_dest);
+#endif
 
     out = hb_buffer_wrapper_init();
     out->storage_type = COREMEDIA;
diff -Naupr a/libhb/platform/macosx/vt_common.c b/libhb/platform/macosx/vt_common.c
--- a/libhb/platform/macosx/vt_common.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/vt_common.c	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* vt_common.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -255,6 +255,26 @@ const int* hb_vt_get_pix_fmts(int encode
     return NULL;
 }
 
+int hb_vt_get_best_pix_fmt(int encoder, const char *profile)
+{
+    switch (encoder)
+    {
+        case HB_VCODEC_VT_H264:
+        case HB_VCODEC_VT_H265:
+            return AV_PIX_FMT_NV12;
+        case HB_VCODEC_VT_H265_10BIT:
+            if (!strcasecmp(profile, "main422-10"))
+            {
+                return AV_PIX_FMT_P210;
+            }
+            else
+            {
+                return AV_PIX_FMT_P010;
+            }
+    }
+    return AV_PIX_FMT_NV12;
+}
+
 const char* const* hb_vt_preset_get_names(int encoder)
 {
     return vt_h26x_preset_name;
@@ -407,7 +427,6 @@ int hb_vt_are_filters_supported(hb_list_
             case HB_FILTER_DEBLOCK:
             case HB_FILTER_DENOISE:
             case HB_FILTER_NLMEANS:
-            case HB_FILTER_RENDER_SUB:
             case HB_FILTER_COLORSPACE:
             case HB_FILTER_FORMAT:
                 supported = 0;
@@ -484,5 +503,18 @@ void hb_vt_setup_hw_filters(hb_job_t *jo
         replace_filter(job, HB_FILTER_GRAYSCALE, HB_FILTER_GRAYSCALE_VT);
         replace_filter(job, HB_FILTER_LAPSHARP, HB_FILTER_LAPSHARP_VT);
         replace_filter(job, HB_FILTER_UNSHARP, HB_FILTER_UNSHARP_VT);
+
+        int count = hb_list_count(job->list_filter);
+        if (count)
+        {
+            // Avoid an additional VTPixelTransferSession, when possible
+            // do the scale and pixel format conversion in one pass
+            hb_filter_object_t *last = hb_list_item(job->list_filter, count - 1);
+            if (last->id == HB_FILTER_CROP_SCALE_VT)
+            {
+                int pix_fmt = hb_vt_get_best_pix_fmt(job->vcodec, job->encoder_profile);
+                hb_dict_set(last->settings, "format", hb_value_int(pix_fmt));
+            }
+        }
     }
 }
diff -Naupr a/libhb/platform/macosx/vt_common.h b/libhb/platform/macosx/vt_common.h
--- a/libhb/platform/macosx/vt_common.h	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/platform/macosx/vt_common.h	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* vt_common.h
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -14,6 +14,7 @@ int hb_vt_is_constant_quality_available(
 int hb_vt_is_multipass_available(int encoder);
 
 const int * hb_vt_get_pix_fmts(int encoder);
+int hb_vt_get_best_pix_fmt(int encoder, const char *profile);
 
 const char * const * hb_vt_preset_get_names(int encoder);
 const char * const * hb_vt_profile_get_names(int encoder);
diff -Naupr a/libhb/ports.c b/libhb/ports.c
--- a/libhb/ports.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/ports.c	2025-03-31 11:55:35.248884310 +0200
@@ -1,6 +1,6 @@
 /* ports.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -70,6 +70,7 @@
 #endif
 
 #ifdef __APPLE__
+#include <CoreServices/CoreServices.h>
 #include <IOKit/pwr_mgt/IOPMLib.h>
 #endif
 
@@ -1177,6 +1178,28 @@ void hb_net_close( hb_net_t ** _n )
 }
 
 /************************************************************************
+* OS Backup Include / Exclude
+***********************************************************************/
+
+void hb_system_backup_set_excluded(const char *path, int exclude)
+{
+#ifdef __APPLE__
+    if (path != NULL)
+    {
+        CFURLRef url = CFURLCreateFromFileSystemRepresentation(kCFAllocatorDefault,
+                                                               (const UInt8 *)path,
+                                                               strlen(path),
+                                                               false);
+        if (url != NULL)
+        {
+            CSBackupSetItemExcluded(url, exclude, false);
+            CFRelease(url);
+        }
+    }
+#endif
+}
+
+/************************************************************************
 * OS Sleep Allow / Prevent
 ***********************************************************************/
 
diff -Naupr a/libhb/preset.c b/libhb/preset.c
--- a/libhb/preset.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/preset.c	2025-03-31 11:55:35.249884293 +0200
@@ -1,6 +1,6 @@
 /* preset.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -2050,7 +2050,25 @@ int hb_preset_apply_video(const hb_dict_
                     hb_value_xform(hb_dict_get(preset, "VideoTurboMultiPass"),
                                     HB_VALUE_TYPE_BOOL));
     }
-    
+
+    if ((value = hb_dict_get(preset, "VideoPasshtruHDRDynamicMetadata")) != NULL)
+    {
+        int hdr_dynamic_metadata = HB_HDR_DYNAMIC_METADATA_ALL;
+        if (!strcasecmp(hb_value_get_string(value), "off"))
+        {
+            hdr_dynamic_metadata = HB_HDR_DYNAMIC_METADATA_NONE;
+        }
+        else if (!strcasecmp(hb_value_get_string(value), "hdr10plus"))
+        {
+            hdr_dynamic_metadata = HB_HDR_DYNAMIC_METADATA_HDR10PLUS;
+        }
+        else if (!strcasecmp(hb_value_get_string(value), "dolbyvision"))
+        {
+            hdr_dynamic_metadata = HB_HDR_DYNAMIC_METADATA_DOVI;
+        }
+        hb_dict_set(video_dict, "PasshtruHDRDynamicMetadata", hb_value_int(hdr_dynamic_metadata));
+    }
+
     if ((value = hb_dict_get(preset, "VideoHWDecode")) != NULL)
     {
         hb_dict_set(video_dict, "HardwareDecode", hb_value_xform(value, HB_VALUE_TYPE_INT));
@@ -2956,6 +2974,43 @@ static void und_to_any(hb_value_array_t
     }
 }
 
+static void import_av1_preset_settings_63_0_0(hb_value_t *preset)
+{
+    const char *enc = hb_dict_get_string(preset, "VideoEncoder");
+    int codec = hb_video_encoder_get_from_name(enc);
+
+    if (codec == HB_VCODEC_SVT_AV1 || codec == HB_VCODEC_SVT_AV1_10BIT)
+    {
+        const char *value = hb_dict_get_string(preset, "VideoPreset");
+        int video_preset = value ? atoi(value) : 0;
+
+        if (video_preset > 10)
+        {
+            hb_dict_set_string(preset, "VideoPreset", "10");
+        }
+    }
+}
+
+static void import_svt_av1_tune_61_0_0(hb_value_t *preset)
+{
+    const char *enc = hb_dict_get_string(preset, "VideoEncoder");
+    int codec = hb_video_encoder_get_from_name(enc);
+
+    if (codec == HB_VCODEC_SVT_AV1 || codec == HB_VCODEC_SVT_AV1_10BIT)
+    {
+        const char *tune = hb_dict_get_string(preset, "VideoTune");
+        if (tune == NULL || strlen(tune) == 0)
+        {
+            hb_dict_set_string(preset, "VideoTune", "vq");
+        }
+    }
+}
+
+static void import_dynamic_metadata_preset_settings_60_0_0(hb_value_t *preset)
+{
+    hb_dict_set_string(preset, "VideoPasshtruHDRDynamicMetadata", "all");
+}
+
 static void import_passthru_preset_settings_57_0_0(hb_value_t *preset)
 {
     int passthru = hb_dict_get_bool(preset, "MetadataPassthrough");
@@ -3711,9 +3766,31 @@ static void import_video_0_0_0(hb_value_
     }
 }
 
+
+static void import_63_0_0(hb_value_t *preset)
+{
+    import_av1_preset_settings_63_0_0(preset);
+}
+
+static void import_61_0_0(hb_value_t *preset)
+{
+    import_svt_av1_tune_61_0_0(preset);
+
+    import_63_0_0(preset);
+}
+
+static void import_60_0_0(hb_value_t *preset)
+{
+    import_dynamic_metadata_preset_settings_60_0_0(preset);
+
+    import_61_0_0(preset);
+}
+
 static void import_57_0_0(hb_value_t *preset)
 {
     import_passthru_preset_settings_57_0_0(preset);
+
+    import_60_0_0(preset);
 }
 
 static void import_55_0_0(hb_value_t *preset)
@@ -3929,6 +4006,21 @@ static int preset_import(hb_value_t *pre
             import_57_0_0(preset);
             result = 1;
         }
+        else if (cmpVersion(major, minor, micro, 60, 0, 0) <= 0)
+        {
+            import_60_0_0(preset);
+            result = 1;
+        }
+        else if (cmpVersion(major, minor, micro, 61, 0, 0) <= 0)
+        {
+            import_61_0_0(preset);
+            result = 1;
+        }
+        else if (cmpVersion(major, minor, micro, 63, 0, 0) <= 0)
+        {
+            import_63_0_0(preset);
+            result = 1;
+        }
 
         preset_clean(preset, hb_preset_template);
     }
diff -Naupr a/libhb/qsv_common.c b/libhb/qsv_common.c
--- a/libhb/qsv_common.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/qsv_common.c	2025-03-31 11:55:35.249884293 +0200
@@ -1,6 +1,6 @@
 /* qsv_common.c
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code.
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
@@ -24,12 +24,6 @@
 #include "handbrake/h265_common.h"
 #include "handbrake/av1_common.h"
 #include "handbrake/hbffmpeg.h"
-#include "libavfilter/avfilter.h"
-#include "libavfilter/buffersrc.h"
-#include "libavfilter/buffersink.h"
-#include "libavutil/hwcontext_qsv.h"
-#include "libavutil/hwcontext.h"
-#include "vpl/mfxadapter.h"
 
 typedef struct hb_qsv_adapter_details
 {
@@ -181,80 +175,6 @@ static hb_triplet_t hb_qsv_hyper_encode_
     { "Hyper Encode adaptive", "adaptive",      MFX_HYPERMODE_ADAPTIVE, },
     { NULL,                                                             },
 };
-static hb_triplet_t hb_qsv_h264_levels[] =
-{
-    { "1.0", "1.0", MFX_LEVEL_AVC_1,  },
-    { "1b",  "1b",  MFX_LEVEL_AVC_1b, },
-    { "1.1", "1.1", MFX_LEVEL_AVC_11, },
-    { "1.2", "1.2", MFX_LEVEL_AVC_12, },
-    { "1.3", "1.3", MFX_LEVEL_AVC_13, },
-    { "2.0", "2.0", MFX_LEVEL_AVC_2,  },
-    { "2.1", "2.1", MFX_LEVEL_AVC_21, },
-    { "2.2", "2.2", MFX_LEVEL_AVC_22, },
-    { "3.0", "3.0", MFX_LEVEL_AVC_3,  },
-    { "3.1", "3.1", MFX_LEVEL_AVC_31, },
-    { "3.2", "3.2", MFX_LEVEL_AVC_32, },
-    { "4.0", "4.0", MFX_LEVEL_AVC_4,  },
-    { "4.1", "4.1", MFX_LEVEL_AVC_41, },
-    { "4.2", "4.2", MFX_LEVEL_AVC_42, },
-    { "5.0", "5.0", MFX_LEVEL_AVC_5,  },
-    { "5.1", "5.1", MFX_LEVEL_AVC_51, },
-    { "5.2", "5.2", MFX_LEVEL_AVC_52, },
-    { NULL,                           },
-};
-static const char * const hb_h264_qsv_level_names[] =
-{
-    "auto", "1.0", "1b", "1.1", "1.2", "1.3", "2.0", "2.1", "2.2", "3.0",
-    "3.1", "3.2", "4.0", "4.1", "4.2", "5.0", "5.1", "5.2", NULL,
-};
-static hb_triplet_t hb_qsv_h265_levels[] =
-{
-    { "1.0", "1.0", MFX_LEVEL_HEVC_1,  },
-    { "2.0", "2.0", MFX_LEVEL_HEVC_2,  },
-    { "2.1", "2.1", MFX_LEVEL_HEVC_21, },
-    { "3.0", "3.0", MFX_LEVEL_HEVC_3,  },
-    { "3.1", "3.1", MFX_LEVEL_HEVC_31, },
-    { "4.0", "4.0", MFX_LEVEL_HEVC_4,  },
-    { "4.1", "4.1", MFX_LEVEL_HEVC_41, },
-    { "5.0", "5.0", MFX_LEVEL_HEVC_5,  },
-    { "5.1", "5.1", MFX_LEVEL_HEVC_51, },
-    { "5.2", "5.2", MFX_LEVEL_HEVC_52, },
-    { "6.0", "6.0", MFX_LEVEL_HEVC_6,  },
-    { "6.1", "6.1", MFX_LEVEL_HEVC_61, },
-    { "6.2", "6.2", MFX_LEVEL_HEVC_62, },
-    { NULL,                            },
-};
-static const char * const hb_h265_qsv_level_names[] =
-{
-    "auto", "1.0", "2.0", "2.1", "3.0", "3.1", "4.0", "4.1",
-    "5.0", "5.1", "5.2", "6.0", "6.1", "6.2", NULL,
-};
-static hb_triplet_t hb_qsv_av1_levels[] =
-{
-    { "2.0", "2.0", MFX_LEVEL_AV1_2,   },
-    { "2.1", "2.1", MFX_LEVEL_AV1_21,  },
-    { "2.2", "2.2", MFX_LEVEL_AV1_22,  },
-    { "2.3", "2.3", MFX_LEVEL_AV1_23,  },
-    { "3.0", "3.0", MFX_LEVEL_AV1_3,   },
-    { "3.1", "3.1", MFX_LEVEL_AV1_31,  },
-    { "3.2", "3.2", MFX_LEVEL_AV1_32,  },
-    { "3.3", "3.3", MFX_LEVEL_AV1_33,  },
-    { "4.0", "4.0", MFX_LEVEL_AV1_4,   },
-    { "4.1", "4.1", MFX_LEVEL_AV1_41,  },
-    { "4.2", "4.2", MFX_LEVEL_AV1_42,  },
-    { "4.3", "4.3", MFX_LEVEL_AV1_43,  },
-    { "5.0", "5.0", MFX_LEVEL_AV1_5,   },
-    { "5.1", "5.1", MFX_LEVEL_AV1_51,  },
-    { "5.2", "5.2", MFX_LEVEL_AV1_52,  },
-    { "5.3", "5.3", MFX_LEVEL_AV1_53,  },
-    { NULL,                            },
-};
-static const char * const hb_av1_qsv_level_names[] =
-{
-    "auto", "2.0", "2.1", "2.2", "2.3", "3.0", "3.1", "3.2",
-    "3.3", "4.0", "4.1", "4.2", "4.3", "5.0", "5.1", "5.2",
-    "5.3", NULL,
-};
 
 static const enum AVPixelFormat hb_qsv_pix_fmts[] =
 {
@@ -758,11 +678,11 @@ int hb_qsv_available()
     hb_log("qsv: is available on this system");
 
     // Return the codec capabilities for the highest platform generation
-    qsv_init_result = ((hb_qsv_video_encoder_is_enabled(hb_qsv_get_adapter_index(), HB_VCODEC_QSV_H264) ? HB_VCODEC_QSV_H264 : 0) |
-                      (hb_qsv_video_encoder_is_enabled(hb_qsv_get_adapter_index(), HB_VCODEC_QSV_H265) ? HB_VCODEC_QSV_H265 : 0) |
-                      (hb_qsv_video_encoder_is_enabled(hb_qsv_get_adapter_index(), HB_VCODEC_QSV_H265_10BIT) ? HB_VCODEC_QSV_H265_10BIT : 0) |
-                      (hb_qsv_video_encoder_is_enabled(hb_qsv_get_adapter_index(), HB_VCODEC_QSV_AV1) ? HB_VCODEC_QSV_AV1 : 0) |
-                      (hb_qsv_video_encoder_is_enabled(hb_qsv_get_adapter_index(), HB_VCODEC_QSV_AV1_10BIT) ? HB_VCODEC_QSV_AV1_10BIT : 0));
+    qsv_init_result = ((hb_qsv_video_encoder_is_enabled(hb_qsv_get_adapter_index(), HB_VCODEC_FFMPEG_QSV_H264) ? HB_VCODEC_FFMPEG_QSV_H264 : 0) |
+                      (hb_qsv_video_encoder_is_enabled(hb_qsv_get_adapter_index(), HB_VCODEC_FFMPEG_QSV_H265) ? HB_VCODEC_FFMPEG_QSV_H265 : 0) |
+                      (hb_qsv_video_encoder_is_enabled(hb_qsv_get_adapter_index(), HB_VCODEC_FFMPEG_QSV_H265_10BIT) ? HB_VCODEC_FFMPEG_QSV_H265_10BIT : 0) |
+                      (hb_qsv_video_encoder_is_enabled(hb_qsv_get_adapter_index(), HB_VCODEC_FFMPEG_QSV_AV1) ? HB_VCODEC_FFMPEG_QSV_AV1 : 0) |
+                      (hb_qsv_video_encoder_is_enabled(hb_qsv_get_adapter_index(), HB_VCODEC_FFMPEG_QSV_AV1_10BIT) ? HB_VCODEC_FFMPEG_QSV_AV1_10BIT : 0));
     return qsv_init_result;
 }
 
@@ -782,6 +702,21 @@ int hb_qsv_hyper_encode_available(int ad
     }
 }
 
+
+int hb_qsv_is_ffmpeg_supported_codec(int vcodec)
+{
+    if (vcodec == HB_VCODEC_FFMPEG_QSV_H264 ||
+        vcodec == HB_VCODEC_FFMPEG_QSV_H265 ||
+        vcodec == HB_VCODEC_FFMPEG_QSV_H265_10BIT ||
+        vcodec == HB_VCODEC_FFMPEG_QSV_AV1 ||
+        vcodec == HB_VCODEC_FFMPEG_QSV_AV1_10BIT
+        )
+    {
+        return 1;
+    }
+    return 0;
+}
+
 int hb_qsv_video_encoder_is_enabled(int adapter_index, int encoder)
 {
     hb_qsv_adapter_details_t* details = hb_qsv_get_adapters_details_by_index(adapter_index);
@@ -795,15 +730,15 @@ int hb_qsv_video_encoder_is_enabled(int
     {
         switch (encoder)
         {
-            case HB_VCODEC_QSV_H264:
+            case HB_VCODEC_FFMPEG_QSV_H264:
                 return details->hb_qsv_info_avc != NULL && details->hb_qsv_info_avc->available;
-            case HB_VCODEC_QSV_H265_10BIT:
+            case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
                 if (hb_qsv_hardware_generation(hb_qsv_get_platform(adapter_index)) < QSV_G6)
                     return 0;
-            case HB_VCODEC_QSV_H265:
+            case HB_VCODEC_FFMPEG_QSV_H265:
                 return details->hb_qsv_info_hevc != NULL && details->hb_qsv_info_hevc->available;
-            case HB_VCODEC_QSV_AV1_10BIT:
-            case HB_VCODEC_QSV_AV1:
+            case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
+            case HB_VCODEC_FFMPEG_QSV_AV1:
                 return details->hb_qsv_info_av1 != NULL && details->hb_qsv_info_av1->available;
             default:
                 return 0;
@@ -2083,13 +2018,13 @@ hb_qsv_info_t* hb_qsv_encoder_info_get(i
     {
         switch (encoder)
         {
-            case HB_VCODEC_QSV_H264:
+            case HB_VCODEC_FFMPEG_QSV_H264:
                 return details->hb_qsv_info_avc;
-            case HB_VCODEC_QSV_H265_10BIT:
-            case HB_VCODEC_QSV_H265:
+            case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+            case HB_VCODEC_FFMPEG_QSV_H265:
                 return details->hb_qsv_info_hevc;
-            case HB_VCODEC_QSV_AV1_10BIT:
-            case HB_VCODEC_QSV_AV1:
+            case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
+            case HB_VCODEC_FFMPEG_QSV_AV1:
                 return details->hb_qsv_info_av1;
             default:
                 return NULL;
@@ -2224,6 +2159,7 @@ static int hb_qsv_parse_options(hb_job_t
                 free(str);
                 if (!err)
                 {
+                    hb_log("hb_qsv_parse_options: gpu=%d", dx_index);
                     hb_qsv_param_parse_dx_index(job, dx_index);
                 }
             }
@@ -2302,16 +2238,6 @@ int hb_qsv_decode_is_enabled(hb_job_t *j
             qsv_decode_is_codec_supported;
 }
 
-int hb_qsv_hw_filters_via_video_memory_are_enabled(hb_job_t *job)
-{
-    return hb_qsv_full_path_is_enabled(job) && (hb_qsv_get_memory_type(job) == MFX_IOPATTERN_OUT_VIDEO_MEMORY) && (job->qsv.ctx->num_hw_filters > 0);
-}
-
-int hb_qsv_hw_filters_via_system_memory_are_enabled(hb_job_t *job)
-{
-    return hb_qsv_full_path_is_enabled(job) && (hb_qsv_get_memory_type(job) == MFX_IOPATTERN_OUT_SYSTEM_MEMORY) && (job->qsv.ctx->num_hw_filters > 0);
-}
-
 int hb_qsv_is_enabled(hb_job_t *job)
 {
     return hb_qsv_decode_is_enabled(job) || hb_qsv_encoder_info_get(hb_qsv_get_adapter_index(), job->vcodec);
@@ -2459,7 +2385,112 @@ float hb_qsv_atof(const char *str, int *
     return v;
 }
 
-int hb_qsv_param_parse(hb_qsv_param_t *param, hb_qsv_info_t *info, hb_job_t *job,
+int hb_qsv_apply_encoder_options(qsv_data_t *qsv_data, hb_job_t *job, AVDictionary **av_opts)
+{
+    qsv_data->is_sys_mem = (hb_qsv_get_memory_type(job) == MFX_IOPATTERN_OUT_SYSTEM_MEMORY);
+    qsv_data->qsv_info = hb_qsv_encoder_info_get(hb_qsv_get_adapter_index(), job->vcodec);
+
+    if (qsv_data != NULL && qsv_data->qsv_info != NULL)
+    {
+        int ret = hb_qsv_param_default(&qsv_data->param, qsv_data->qsv_info);
+        if (ret)
+        {
+            return ret;
+        }
+    }
+    else
+    {
+        hb_error("hb_qsv_apply_encoder_options: invalid pointer(s) qsv_data=%p qsv_data->qsv_info=%p", qsv_data, qsv_data->qsv_info);
+        return -1;
+    }
+
+    if (job->encoder_options != NULL && *job->encoder_options)
+    {
+        hb_dict_t *options_list;
+        options_list = hb_encopts_to_dict(job->encoder_options, job->vcodec);
+
+        hb_dict_iter_t iter;
+        for (iter  = hb_dict_iter_init(options_list);
+             iter != HB_DICT_ITER_DONE;
+             iter  = hb_dict_iter_next(options_list, iter))
+        {
+            const char *key = hb_dict_iter_key(iter);
+            hb_value_t *value = hb_dict_iter_value(iter);
+            char *str = hb_value_get_string_xform(value);
+
+            switch (hb_qsv_param_parse(av_opts, &qsv_data->param, qsv_data->qsv_info, job, key, str))
+            {
+                case HB_QSV_PARAM_OK:
+                    break;
+
+                case HB_QSV_PARAM_BAD_NAME:
+                    hb_log("qsv_encavcodecInit: hb_qsv_param_parse: bad key %s", key);
+                    break;
+                case HB_QSV_PARAM_BAD_VALUE:
+                    hb_log("qsv_encavcodecInit: hb_qsv_param_parse: bad value %s for key %s",
+                           str, key);
+                    break;
+                case HB_QSV_PARAM_UNSUPPORTED:
+                    hb_log("qsv_encavcodecInit: hb_qsv_param_parse: unsupported option %s",
+                           key);
+                    break;
+
+                case HB_QSV_PARAM_ERROR:
+                default:
+                    hb_log("qsv_encavcodecInit: hb_qsv_param_parse: unknown error");
+                    break;
+            }
+            free(str);
+        }
+        hb_dict_free(&options_list);
+    }
+
+    hb_log("encavcodec: using%s%s path",
+           hb_qsv_full_path_is_enabled(job) ? " full QSV" : " encode-only",
+           hb_qsv_get_memory_type(job) == MFX_IOPATTERN_OUT_VIDEO_MEMORY ? " via video memory" : " via system memory");
+
+    if(qsv_data->qsv_info->capabilities & HB_QSV_CAP_LOWPOWER_ENCODE)
+    {
+        char low_power[7];
+        snprintf(low_power, sizeof(low_power), "%d", qsv_data->param.low_power);
+        av_dict_set(av_opts, "low_power", low_power, 0);
+        if(qsv_data->param.low_power)
+            hb_log("encavcodec: using Low Power mode");
+    }
+
+    if((qsv_data->qsv_info->capabilities & HB_QSV_CAP_HYPERENCODE) &&
+        qsv_data->param.hyperEncodeParam->value != MFX_HYPERMODE_OFF)
+    {
+        char hyperencode[16];
+        snprintf(hyperencode, sizeof(hyperencode), "%s", qsv_data->param.hyperEncodeParam->key);
+        av_dict_set(av_opts, "dual_gfx", hyperencode, 0);
+        //av_dict_set(av_opts, "async_depth", "30", 0);
+        hb_log("encavcodec: Hyper Encoding mode: %s", hyperencode);
+    }
+
+    if((qsv_data->qsv_info->capabilities & HB_QSV_CAP_AV1_SCREENCONTENT) &&
+        qsv_data->param.av1ScreenContentToolsParam.IntraBlockCopy)
+    {
+        char intrabc[7];
+        snprintf(intrabc, sizeof(intrabc), "%d", qsv_data->param.av1ScreenContentToolsParam.IntraBlockCopy);
+        av_dict_set(av_opts, "intrabc", intrabc, 0);
+        hb_log("encavcodec: ScreenContentCoding is enabled IBC %s",
+            qsv_data->param.av1ScreenContentToolsParam.IntraBlockCopy ? "on" : "off");
+    }
+
+    if((qsv_data->qsv_info->capabilities & HB_QSV_CAP_AV1_SCREENCONTENT) &&
+        qsv_data->param.av1ScreenContentToolsParam.Palette)
+    {
+        char palette_mode[7];
+        snprintf(palette_mode, sizeof(palette_mode), "%d", qsv_data->param.av1ScreenContentToolsParam.Palette);
+        av_dict_set(av_opts, "palette_mode", palette_mode, 0);
+        hb_log("encavcodec: ScreenContentCoding is enabled Palette %s",
+            qsv_data->param.av1ScreenContentToolsParam.Palette ? "on" : "off");
+    }
+    return 0;
+}
+
+int hb_qsv_param_parse(AVDictionary** av_opts, hb_qsv_param_t *param, hb_qsv_info_t *info, hb_job_t *job,
                        const char *key, const char *value)
 {
     float fvalue;
@@ -2495,9 +2526,33 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
         ivalue = hb_qsv_atoi(value, &error);
         if (!error)
         {
-            param->videoParam->mfx.TargetUsage = HB_QSV_CLIP3(MFX_TARGETUSAGE_1,
-                                                              MFX_TARGETUSAGE_7,
-                                                              ivalue);
+            int target_usage = HB_QSV_CLIP3(MFX_TARGETUSAGE_1, MFX_TARGETUSAGE_7, ivalue);
+            switch (target_usage)
+            {
+                case MFX_TARGETUSAGE_1:
+                    av_dict_set(av_opts, "preset", "veryslow", 0);
+                    break;
+                case MFX_TARGETUSAGE_2:
+                    av_dict_set(av_opts, "preset", "slower", 0);
+                    break;
+                case MFX_TARGETUSAGE_3:
+                    av_dict_set(av_opts, "preset", "slow", 0);
+                    break;
+                case MFX_TARGETUSAGE_4:
+                    av_dict_set(av_opts, "preset", "medium", 0);
+                    break;
+                case MFX_TARGETUSAGE_5:
+                    av_dict_set(av_opts, "preset", "fast", 0);
+                    break;
+                case MFX_TARGETUSAGE_6:
+                    av_dict_set(av_opts, "preset", "faster", 0);
+                    break;
+                case MFX_TARGETUSAGE_7:
+                    av_dict_set(av_opts, "preset", "veryfast", 0);
+                    break;
+                default:
+                    break;
+            }
         }
     }
     else if (!strcasecmp(key, "num-ref-frame") ||
@@ -2506,7 +2561,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
         ivalue = hb_qsv_atoi(value, &error);
         if (!error)
         {
-            param->videoParam->mfx.NumRefFrame = HB_QSV_CLIP3(0, 16, ivalue);
+            char cvalue[7];
+            snprintf(cvalue, 7, "%d", HB_QSV_CLIP3(0, 16, ivalue));
+            av_dict_set(av_opts, "refs", cvalue, 0);
         }
     }
     else if (!strcasecmp(key, "gop-ref-dist"))
@@ -2514,7 +2571,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
         ivalue = hb_qsv_atoi(value, &error);
         if (!error)
         {
-            param->gop.gop_ref_dist = HB_QSV_CLIP3(-1, 32, ivalue);
+            char cvalue[7];
+            snprintf(cvalue, 7, "%d", HB_QSV_CLIP3(-1, 32, ivalue));
+            av_dict_set(av_opts, "bf", cvalue, 0);
         }
     }
     else if (!strcasecmp(key, "gop-pic-size") ||
@@ -2523,7 +2582,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
         ivalue = hb_qsv_atoi(value, &error);
         if (!error)
         {
-            param->gop.gop_pic_size = HB_QSV_CLIP3(-1, UINT16_MAX, ivalue);
+            char cvalue[7];
+            snprintf(cvalue, 7, "%d", HB_QSV_CLIP3(-1, UINT16_MAX, ivalue));
+            av_dict_set(av_opts, "g", cvalue, 0);
         }
     }
     else if (!strcasecmp(key, "b-pyramid"))
@@ -2533,7 +2594,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
             ivalue = hb_qsv_atoi(value, &error);
             if (!error)
             {
-                param->gop.b_pyramid = HB_QSV_CLIP3(-1, 1, ivalue);
+                char cvalue[7];
+                snprintf(cvalue, 7, "%d", HB_QSV_CLIP3(-1, 1, ivalue));
+                av_dict_set(av_opts, "b_strategy", cvalue, 0);
             }
         }
         else
@@ -2541,21 +2604,6 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
             return HB_QSV_PARAM_UNSUPPORTED;
         }
     }
-    else if (!strcasecmp(key, "scenecut"))
-    {
-        ivalue = hb_qsv_atobool(value, &error);
-        if (!error)
-        {
-            if (!ivalue)
-            {
-                param->videoParam->mfx.GopOptFlag |= MFX_GOP_STRICT;
-            }
-            else
-            {
-                param->videoParam->mfx.GopOptFlag &= ~MFX_GOP_STRICT;
-            }
-        }
-    }
     else if (!strcasecmp(key, "adaptive-i") ||
              !strcasecmp(key, "i-adapt"))
     {
@@ -2564,7 +2612,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
             ivalue = hb_qsv_atobool(value, &error);
             if (!error)
             {
-                param->codingOption2.AdaptiveI = hb_qsv_codingoption_xlat(ivalue);
+                char cvalue[7];
+                snprintf(cvalue, 7, "%d", hb_qsv_codingoption_xlat(ivalue));
+                av_dict_set(av_opts, "adaptive_i", cvalue, 0);
             }
         }
         else
@@ -2580,7 +2630,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
             ivalue = hb_qsv_atobool(value, &error);
             if (!error)
             {
-                param->codingOption2.AdaptiveB = hb_qsv_codingoption_xlat(ivalue);
+                char cvalue[7];
+                snprintf(cvalue, 7, "%d", hb_qsv_codingoption_xlat(ivalue));
+                av_dict_set(av_opts, "adaptive_b", cvalue, 0);
             }
         }
         else
@@ -2625,7 +2677,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
         fvalue = hb_qsv_atof(value, &error);
         if (!error)
         {
-            param->rc.vbv_buffer_init = HB_QSV_CLIP3(0, INT32_MAX, fvalue);
+            char cvalue[7];
+            snprintf(cvalue, 7, "%.2f", HB_QSV_CLIP3(0, INT32_MAX, fvalue));
+            av_dict_set(av_opts, "rc_initial_buffer_occupancy", cvalue, 0);
         }
     }
     else if (!strcasecmp(key, "vbv-bufsize"))
@@ -2633,7 +2687,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
         ivalue = hb_qsv_atoi(value, &error);
         if (!error)
         {
-            param->rc.vbv_buffer_size = HB_QSV_CLIP3(0, INT32_MAX, ivalue);
+            char cvalue[7];
+            snprintf(cvalue, 7, "%d", HB_QSV_CLIP3(0, INT32_MAX, ivalue));
+            av_dict_set(av_opts, "rc_buffer_size", cvalue, 0);
         }
     }
     else if (!strcasecmp(key, "vbv-maxrate"))
@@ -2641,7 +2697,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
         ivalue = hb_qsv_atoi(value, &error);
         if (!error)
         {
-            param->rc.vbv_max_bitrate = HB_QSV_CLIP3(0, INT32_MAX, ivalue);
+            char cvalue[7];
+            snprintf(cvalue, 7, "%d", HB_QSV_CLIP3(0, INT32_MAX, ivalue));
+            av_dict_set(av_opts, "rc_max_rate", cvalue, 0);
         }
     }
     else if (!strcasecmp(key, "cavlc") || !strcasecmp(key, "cabac"))
@@ -2667,32 +2725,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
             {
                 ivalue = !ivalue;
             }
-            param->codingOption.CAVLC = hb_qsv_codingoption_xlat(ivalue);
-        }
-    }
-    else if (!strcasecmp(key, "videoformat"))
-    {
-        if (info->capabilities & HB_QSV_CAP_VUI_VSINFO)
-        {
-            switch (info->codec_id)
-            {
-                case MFX_CODEC_AVC:
-                    ivalue = hb_qsv_atoindex(hb_h264_vidformat_names, value, &error);
-                    break;
-                case MFX_CODEC_HEVC:
-                    ivalue = hb_qsv_atoindex(hb_h265_vidformat_names, value, &error);
-                    break;
-                default:
-                    return HB_QSV_PARAM_UNSUPPORTED;
-            }
-        }
-        else
-        {
-            return HB_QSV_PARAM_UNSUPPORTED;
-        }
-        if (!error)
-        {
-            param->videoSignalInfo.VideoFormat = ivalue;
+            char cvalue[7];
+            snprintf(cvalue, 7, "%d", hb_qsv_codingoption_xlat(ivalue));
+            av_dict_set(av_opts, "cavlc", cvalue, 0);
         }
     }
     else if (!strcasecmp(key, "colorprim"))
@@ -2717,8 +2752,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
         }
         if (!error)
         {
-            param->videoSignalInfo.ColourDescriptionPresent = 1;
-            param->videoSignalInfo.ColourPrimaries = ivalue;
+            char cvalue[7];
+            snprintf(cvalue, 7, "%d", ivalue);
+            av_dict_set(av_opts, "color_primaries", cvalue, 0);
         }
     }
     else if (!strcasecmp(key, "transfer"))
@@ -2743,8 +2779,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
         }
         if (!error)
         {
-            param->videoSignalInfo.ColourDescriptionPresent = 1;
-            param->videoSignalInfo.TransferCharacteristics = ivalue;
+            char cvalue[7];
+            snprintf(cvalue, 7, "%d", ivalue);
+            av_dict_set(av_opts, "color_trc", cvalue, 0);
         }
     }
     else if (!strcasecmp(key, "colormatrix"))
@@ -2769,8 +2806,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
         }
         if (!error)
         {
-            param->videoSignalInfo.ColourDescriptionPresent = 1;
-            param->videoSignalInfo.MatrixCoefficients = ivalue;
+            char cvalue[7];
+            snprintf(cvalue, 7, "%d", ivalue);
+            av_dict_set(av_opts, "colorspace", cvalue, 0);
         }
     }
     else if (!strcasecmp(key, "tff") ||
@@ -2786,9 +2824,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
         }
         if (!error)
         {
-            param->videoParam->mfx.FrameInfo.PicStruct = (ivalue                  ?
-                                                          MFX_PICSTRUCT_FIELD_TFF :
-                                                          MFX_PICSTRUCT_PROGRESSIVE);
+            char cvalue[7];
+            snprintf(cvalue, 7, "+%d", ivalue ? MFX_PICSTRUCT_FIELD_TFF : MFX_PICSTRUCT_PROGRESSIVE);
+            av_dict_set(av_opts, "flags", cvalue, AV_DICT_APPEND);
         }
     }
     else if (!strcasecmp(key, "bff"))
@@ -2803,9 +2841,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
         }
         if (!error)
         {
-            param->videoParam->mfx.FrameInfo.PicStruct = (ivalue                  ?
-                                                          MFX_PICSTRUCT_FIELD_BFF :
-                                                          MFX_PICSTRUCT_PROGRESSIVE);
+            char cvalue[7];
+            snprintf(cvalue, 7, "+%d", ivalue ? MFX_PICSTRUCT_FIELD_BFF : MFX_PICSTRUCT_PROGRESSIVE);
+            av_dict_set(av_opts, "flags", cvalue, AV_DICT_APPEND);
         }
     }
     else if (!strcasecmp(key, "mbbrc"))
@@ -2815,7 +2853,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
             ivalue = hb_qsv_atobool(value, &error);
             if (!error)
             {
-                param->codingOption2.MBBRC = hb_qsv_codingoption_xlat(ivalue);
+                char cvalue[7];
+                snprintf(cvalue, 7, "%d", hb_qsv_codingoption_xlat(ivalue));
+                av_dict_set(av_opts, "mbbrc", cvalue, 0);
             }
         }
         else
@@ -2830,7 +2870,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
             ivalue = hb_qsv_atobool(value, &error);
             if (!error)
             {
-                param->codingOption2.ExtBRC = hb_qsv_codingoption_xlat(ivalue);
+                char cvalue[7];
+                snprintf(cvalue, 7, "%d", hb_qsv_codingoption_xlat(ivalue));
+                av_dict_set(av_opts, "extbrc", cvalue, 0);
             }
         }
         else
@@ -2862,8 +2904,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
             ivalue = hb_qsv_atoi(value, &error);
             if (!error)
             {
-                param->codingOption2.LookAheadDepth = HB_QSV_CLIP3(10, 100,
-                                                                   ivalue);
+                char cvalue[7];
+                snprintf(cvalue, 7, "%d", HB_QSV_CLIP3(10, 100, ivalue));
+                av_dict_set(av_opts, "look_ahead_depth", cvalue, 0);
             }
         }
         else
@@ -2879,9 +2922,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
             ivalue = hb_qsv_atoi(value, &error);
             if (!error)
             {
-                param->codingOption2.LookAheadDS = HB_QSV_CLIP3(MFX_LOOKAHEAD_DS_UNKNOWN,
-                                                                MFX_LOOKAHEAD_DS_4x,
-                                                                ivalue);
+                char cvalue[7];
+                snprintf(cvalue, 7, "%d", HB_QSV_CLIP3(MFX_LOOKAHEAD_DS_UNKNOWN, MFX_LOOKAHEAD_DS_4x, ivalue));
+                av_dict_set(av_opts, "look_ahead_downsampling", cvalue, 0);
             }
         }
         else
@@ -2896,7 +2939,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
             ivalue = hb_qsv_atoi(value, &error);
             if (!error)
             {
-                param->codingOption2.Trellis = hb_qsv_trellisvalue_xlat(ivalue);
+                char cvalue[7];
+                snprintf(cvalue, 7, "%d", hb_qsv_trellisvalue_xlat(ivalue));
+                av_dict_set(av_opts, "trellis", cvalue, 0);
             }
         }
         else
@@ -2911,7 +2956,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
             ivalue = hb_qsv_atobool(value, &error);
             if (!error)
             {
-                param->codingOption2.RepeatPPS = hb_qsv_codingoption_xlat(ivalue);
+                char cvalue[7];
+                snprintf(cvalue, 7, "%d", hb_qsv_codingoption_xlat(ivalue));
+                av_dict_set(av_opts, "repeat_pps", cvalue, 0);
             }
         }
         else
@@ -2926,7 +2973,7 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
             ivalue = hb_qsv_atobool(value, &error);
             if (!error)
             {
-                param->videoParam->mfx.LowPower = ivalue ? MFX_CODINGOPTION_ON : MFX_CODINGOPTION_OFF;
+                param->low_power = ivalue;
             }
         }
         else
@@ -3008,7 +3055,7 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
         }
         if (mode)
         {
-            param->hyperEncodeParam.Mode = mode->value;
+            param->hyperEncodeParam = mode;
         }
     }
     else if (!strcasecmp(key, "palette"))
@@ -3018,7 +3065,7 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
             ivalue = hb_qsv_atobool(value, &error);
             if (!error)
             {
-                param->av1ScreenContentToolsParam.Palette = ivalue ? MFX_CODINGOPTION_ON : MFX_CODINGOPTION_OFF;
+                param->av1ScreenContentToolsParam.Palette = ivalue;
             }
         }
         else
@@ -3033,7 +3080,7 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
             ivalue = hb_qsv_atobool(value, &error);
             if (!error)
             {
-                param->av1ScreenContentToolsParam.IntraBlockCopy = ivalue ? MFX_CODINGOPTION_ON : MFX_CODINGOPTION_OFF;
+                param->av1ScreenContentToolsParam.IntraBlockCopy = ivalue;
             }
         }
         else
@@ -3046,7 +3093,9 @@ int hb_qsv_param_parse(hb_qsv_param_t *p
         int async_depth = hb_qsv_atoi(value, &error);
         if (!error)
         {
-            param->videoParam->AsyncDepth = async_depth;
+            char cvalue[7];
+            snprintf(cvalue, 7, "%d", async_depth);
+            av_dict_set(av_opts, "async_depth", cvalue, 0);
         }
     }
     else
@@ -3107,7 +3156,7 @@ int hb_qsv_profile_parse(hb_qsv_param_t
     }
     /* HEVC 10 bits defaults to Main 10 */
     else if (((profile_key != NULL && !strcasecmp(profile_key, "auto")) || profile_key == NULL) &&
-              codec == HB_VCODEC_QSV_H265_10BIT &&
+              codec == HB_VCODEC_FFMPEG_QSV_H265_10BIT &&
               param->videoParam->mfx.CodecId == MFX_CODEC_HEVC &&
               hb_qsv_hardware_generation(hb_qsv_get_platform(hb_qsv_get_adapter_index())) >= QSV_G6)
     {
@@ -3116,7 +3165,7 @@ int hb_qsv_profile_parse(hb_qsv_param_t
     }
     /* AV1 10 bits defaults to Main */
     else if (((profile_key != NULL && !strcasecmp(profile_key, "auto")) || profile_key == NULL) &&
-              codec == HB_VCODEC_QSV_AV1_10BIT &&
+              codec == HB_VCODEC_FFMPEG_QSV_AV1_10BIT &&
               param->videoParam->mfx.CodecId == MFX_CODEC_AV1 &&
               hb_qsv_hardware_generation(hb_qsv_get_platform(hb_qsv_get_adapter_index())) > QSV_G8)
     {
@@ -3126,52 +3175,6 @@ int hb_qsv_profile_parse(hb_qsv_param_t
     return 0;
 }
 
-int hb_qsv_level_parse(hb_qsv_param_t *param, hb_qsv_info_t *info, const char *level_key)
-{
-    hb_triplet_t *level = NULL;
-    if (level_key != NULL && *level_key && strcasecmp(level_key, "auto"))
-    {
-        switch (param->videoParam->mfx.CodecId)
-        {
-            case MFX_CODEC_AVC:
-                level = hb_triplet4key(hb_qsv_h264_levels, level_key);
-                break;
-
-            case MFX_CODEC_HEVC:
-                level = hb_triplet4key(hb_qsv_h265_levels, level_key);
-                break;
-
-            case MFX_CODEC_AV1:
-                level = hb_triplet4key(hb_qsv_av1_levels, level_key);
-                break;
-
-            default:
-                break;
-        }
-        if (level == NULL)
-        {
-            return -1;
-        }
-        if (param->videoParam->mfx.CodecId == MFX_CODEC_AVC)
-        {
-            if (info->capabilities & HB_QSV_CAP_MSDK_API_1_6)
-            {
-                param->videoParam->mfx.CodecLevel = FFMIN(MFX_LEVEL_AVC_52, level->value);
-            }
-            else
-            {
-                // Media SDK API < 1.6, MFX_LEVEL_AVC_52 unsupported
-                param->videoParam->mfx.CodecLevel = FFMIN(MFX_LEVEL_AVC_51, level->value);
-            }
-        }
-        else
-        {
-            param->videoParam->mfx.CodecLevel = level->value;
-        }
-    }
-    return 0;
-}
-
 const char* const* hb_qsv_preset_get_names()
 {
     if (hb_qsv_hardware_generation(hb_qsv_get_platform(hb_qsv_get_adapter_index())) >= QSV_G3)
@@ -3188,14 +3191,14 @@ const char* const* hb_qsv_profile_get_na
 {
     switch (encoder)
     {
-        case HB_VCODEC_QSV_H264:
+        case HB_VCODEC_FFMPEG_QSV_H264:
             return hb_h264_profile_names_8bit;
-        case HB_VCODEC_QSV_H265_8BIT:
+        case HB_VCODEC_FFMPEG_QSV_H265_8BIT:
             return hb_h265_profile_names_8bit;
-        case HB_VCODEC_QSV_H265_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
             return hb_qsv_h265_profiles_names_10bit;
-        case HB_VCODEC_QSV_AV1_10BIT:
-        case HB_VCODEC_QSV_AV1:
+        case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_AV1:
             return hb_qsv_av1_profiles_names;
         default:
             return NULL;
@@ -3206,14 +3209,14 @@ const char* const* hb_qsv_level_get_name
 {
     switch (encoder)
     {
-        case HB_VCODEC_QSV_H264:
-            return hb_h264_qsv_level_names;
-        case HB_VCODEC_QSV_H265_10BIT:
-        case HB_VCODEC_QSV_H265:
-            return hb_h265_qsv_level_names;
-        case HB_VCODEC_QSV_AV1_10BIT:
-        case HB_VCODEC_QSV_AV1:
-            return hb_av1_qsv_level_names;
+        case HB_VCODEC_FFMPEG_QSV_H264:
+            return hb_qsv_h264_level_names;
+        case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_H265:
+            return hb_qsv_h265_level_names;
+        case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
+        case HB_VCODEC_FFMPEG_QSV_AV1:
+            return hb_qsv_av1_level_names;
         default:
             return NULL;
     }
@@ -3223,12 +3226,12 @@ const int* hb_qsv_get_pix_fmts(int encod
 {
     switch (encoder)
     {
-    case HB_VCODEC_QSV_H264:
-    case HB_VCODEC_QSV_H265:
-    case HB_VCODEC_QSV_AV1:
+    case HB_VCODEC_FFMPEG_QSV_H264:
+    case HB_VCODEC_FFMPEG_QSV_H265:
+    case HB_VCODEC_FFMPEG_QSV_AV1:
         return hb_qsv_pix_fmts;
-    case HB_VCODEC_QSV_H265_10BIT:
-    case HB_VCODEC_QSV_AV1_10BIT:
+    case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+    case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
         return hb_qsv_10bit_pix_fmts;
 
     default:
@@ -3244,17 +3247,17 @@ const char* hb_qsv_video_quality_get_nam
     {
         switch (codec)
         {
-            case HB_VCODEC_QSV_H264:
+            case HB_VCODEC_FFMPEG_QSV_H264:
                 if (details->hb_qsv_info_avc != NULL) caps = details->hb_qsv_info_avc->capabilities;
                 break;
 
-            case HB_VCODEC_QSV_H265_10BIT:
-            case HB_VCODEC_QSV_H265:
+            case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+            case HB_VCODEC_FFMPEG_QSV_H265:
                 if (details->hb_qsv_info_hevc != NULL) caps = details->hb_qsv_info_hevc->capabilities;
                 break;
 
-            case HB_VCODEC_QSV_AV1_10BIT:
-            case HB_VCODEC_QSV_AV1:
+            case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
+            case HB_VCODEC_FFMPEG_QSV_AV1:
                 if (details->hb_qsv_info_av1 != NULL) caps = details->hb_qsv_info_av1->capabilities;
                 break;
 
@@ -3274,8 +3277,8 @@ void hb_qsv_video_quality_get_limits(uin
     {
         switch (codec)
         {
-            case HB_VCODEC_QSV_H265_10BIT:
-            case HB_VCODEC_QSV_H265:
+            case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+            case HB_VCODEC_FFMPEG_QSV_H265:
                 if (details->hb_qsv_info_hevc != NULL) caps = details->hb_qsv_info_hevc->capabilities;
                 *direction   = 1;
                 *granularity = 1.;
@@ -3283,8 +3286,8 @@ void hb_qsv_video_quality_get_limits(uin
                 *high        = 51.;
                 break;
 
-            case HB_VCODEC_QSV_AV1_10BIT:
-            case HB_VCODEC_QSV_AV1:
+            case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
+            case HB_VCODEC_FFMPEG_QSV_AV1:
                 if (details->hb_qsv_info_av1 != NULL) caps = details->hb_qsv_info_av1->capabilities;
                 *direction   = 1;
                 *granularity = 1.;
@@ -3292,7 +3295,7 @@ void hb_qsv_video_quality_get_limits(uin
                 *high        = 51.;
                 break;
 
-            case HB_VCODEC_QSV_H264:
+            case HB_VCODEC_FFMPEG_QSV_H264:
             default:
                 if (details->hb_qsv_info_avc != NULL) caps = details->hb_qsv_info_avc->capabilities;
                 *direction   = 1;
@@ -3304,136 +3307,22 @@ void hb_qsv_video_quality_get_limits(uin
     }
 }
 
-int hb_qsv_param_default_preset(hb_qsv_param_t *param,
-                                mfxVideoParam *videoParam,
-                                hb_qsv_info_t *info, const char *preset)
+const char * hb_map_qsv_preset_name(const char * preset)
 {
-    if (param != NULL && videoParam != NULL && info != NULL)
+    if (preset == NULL)
     {
-        int ret = hb_qsv_param_default(param, videoParam, info);
-        if (ret)
-        {
-            return ret;
-        }
+        return "medium";
     }
-    else
-    {
-        hb_error("hb_qsv_param_default_preset: invalid pointer(s) param=%p videoParam=%p info=%p preset=%p", param, videoParam, info, preset);
-        return -1;
-    }
-    if (preset != NULL && preset[0] != '\0')
-    {
-        if (!strcasecmp(preset, "quality"))
-        {
-            /*
-             * HSW TargetUsage:     2
-             *     NumRefFrame:     0
-             *     GopRefDist:      4 (CQP), 3 (VBR)        -> -1 (set by encoder)
-             *     GopPicSize:     32 (CQP), 1 second (VBR) -> -1 (set by encoder)
-             *     BPyramid:        1 (CQP), 0 (VBR)        -> -1 (set by encoder)
-             *     LookAhead:       1 (on)
-             *     LookAheadDepth: 40
-             *
-             *
-             * SNB
-             * IVB Preset Not Available
-             *
-             * Note: this preset is the libhb default (like x264's "medium").
-             */
-            if (hb_qsv_hardware_generation(hb_qsv_get_platform(hb_qsv_get_adapter_index())) >= QSV_G7)
-            {
-                // Since IceLake only
-                param->rc.lookahead                = 0;
-                param->videoParam->mfx.TargetUsage = MFX_TARGETUSAGE_1;
-            }
-        }
-        else if (!strcasecmp(preset, "balanced"))
-        {
-            /*
-             * HSW TargetUsage:     4
-             *     NumRefFrame:     1
-             *     GopRefDist:      4 (CQP), 3 (VBR)        -> -1 (set by encoder)
-             *     GopPicSize:     32 (CQP), 1 second (VBR) -> -1 (set by encoder)
-             *     BPyramid:        1 (CQP), 0 (VBR)        -> -1 (set by encoder)
-             *     LookAhead:       0 (off)
-             *     LookAheadDepth: Not Applicable
-             */
-            if (hb_qsv_hardware_generation(hb_qsv_get_platform(hb_qsv_get_adapter_index())) >= QSV_G3)
-            {
-                param->rc.lookahead                = 0;
-                param->videoParam->mfx.NumRefFrame = 1;
-                param->videoParam->mfx.TargetUsage = MFX_TARGETUSAGE_4;
-            }
-            else
-            {
-                /*
-                 * SNB
-                 * IVB TargetUsage:     2
-                 *     NumRefFrame:     0
-                 *     GopRefDist:      4 (CQP), 3 (VBR)        -> -1 (set by encoder)
-                 *     GopPicSize:     32 (CQP), 1 second (VBR) -> -1 (set by encoder)
-                 *     BPyramid:       Not Applicable
-                 *     LookAhead:      Not Applicable
-                 *     LookAheadDepth: Not Applicable
-                 *
-                 * Note: this preset is not the libhb default,
-                 * but the settings are the same so do nothing.
-                 */
-            }
-        }
-        else if (!strcasecmp(preset, "speed"))
-        {
-            if (hb_qsv_hardware_generation(hb_qsv_get_platform(hb_qsv_get_adapter_index())) >= QSV_G7)
-            {
-                // Since IceLake only
-                param->rc.lookahead                = 0;
-                param->videoParam->mfx.NumRefFrame = 1;
-                param->videoParam->mfx.TargetUsage = MFX_TARGETUSAGE_7;
-            }
-            else if (hb_qsv_hardware_generation(hb_qsv_get_platform(hb_qsv_get_adapter_index())) >= QSV_G3)
-            {
-                /*
-                 * HSW TargetUsage:     6
-                 *     NumRefFrame:     0 (CQP), 1 (VBR)        -> see note
-                 *     GopRefDist:      4 (CQP), 3 (VBR)        -> -1 (set by encoder)
-                 *     GopPicSize:     32 (CQP), 1 second (VBR) -> -1 (set by encoder)
-                 *     BPyramid:        1 (CQP), 0 (VBR)        -> -1 (set by encoder)
-                 *     LookAhead:       0 (off)
-                 *     LookAheadDepth: Not Applicable
-                 *
-                 * Note: NumRefFrame depends on the RC method, which we don't
-                 *       know here. Rather than have an additional variable and
-                 *       having the encoder set it, we set it to 1 and let the
-                 *       B-pyramid code sanitize it. Since BPyramid is 1 w/CQP,
-                 *       the result (3) is the same as what MSDK would pick for
-                 *       NumRefFrame 0 GopRefDist 4 GopPicSize 32.
-                 */
-                param->rc.lookahead                = 0;
-                param->videoParam->mfx.NumRefFrame = 1;
-                param->videoParam->mfx.TargetUsage = MFX_TARGETUSAGE_6;
-            }
-            else
-            {
-                /*
-                 * SNB
-                 * IVB TargetUsage:     4
-                 *     NumRefFrame:     0
-                 *     GopRefDist:      4 (CQP), 3 (VBR)        -> -1 (set by encoder)
-                 *     GopPicSize:     32 (CQP), 1 second (VBR) -> -1 (set by encoder)
-                 *     BPyramid:       Not Applicable
-                 *     LookAhead:      Not Applicable
-                 *     LookAheadDepth: Not Applicable
-                 */
-                param->videoParam->mfx.TargetUsage = MFX_TARGETUSAGE_4;
-            }
-        }
-        else
-        {
-            hb_error("hb_qsv_param_default_preset: invalid preset '%s'", preset);
-            return -1;
-        }
+
+    if (strcmp(preset, "speed") == 0) {
+      return "veryfast";
+    } else if (strcmp(preset, "balanced") == 0) {
+      return "medium";
+    } else if (strcmp(preset, "quality") == 0) {
+      return "veryslow";
     }
-    return 0;
+
+    return "medium";
 }
 
 int hb_qsv_param_default_async_depth()
@@ -3441,10 +3330,9 @@ int hb_qsv_param_default_async_depth()
     return hb_qsv_hardware_generation(hb_qsv_get_platform(hb_qsv_get_adapter_index())) >= QSV_G7 ? 6 : HB_QSV_ASYNC_DEPTH_DEFAULT;
 }
 
-int hb_qsv_param_default(hb_qsv_param_t *param, mfxVideoParam *videoParam,
-                         hb_qsv_info_t  *info)
+int hb_qsv_param_default(hb_qsv_param_t *param, hb_qsv_info_t *info)
 {
-    if (param != NULL && videoParam != NULL && info != NULL)
+    if (param != NULL && info != NULL)
     {
         // introduced in API 1.0
         memset(&param->codingOption, 0, sizeof(mfxExtCodingOption));
@@ -3518,21 +3406,19 @@ int hb_qsv_param_default(hb_qsv_param_t
         param->codingOption2.LookAheadDS     = MFX_LOOKAHEAD_DS_OFF;
         param->codingOption2.NumMbPerSlice   = 0;
         // introduced in API 2.5
-        memset(&param->hyperEncodeParam, 0, sizeof(mfxExtHyperModeParam));
-        param->hyperEncodeParam.Header.BufferId = MFX_EXTBUFF_HYPER_MODE_PARAM;
-        param->hyperEncodeParam.Header.BufferSz = sizeof(mfxExtHyperModeParam);
-        param->hyperEncodeParam.Mode = MFX_HYPERMODE_OFF;
+        param->hyperEncodeParam              = hb_triplet4key(hb_qsv_hyper_encode_modes, "off");
 
         memset(&param->av1BitstreamParam, 0, sizeof(mfxExtAV1BitstreamParam));
         param->av1BitstreamParam.Header.BufferId = MFX_EXTBUFF_AV1_BITSTREAM_PARAM;
         param->av1BitstreamParam.Header.BufferSz = sizeof(mfxExtAV1BitstreamParam);
         param->av1BitstreamParam.WriteIVFHeaders = MFX_CODINGOPTION_OFF;
+
         // introduced in API 2.11
         memset(&param->av1ScreenContentToolsParam, 0, sizeof(mfxExtAV1ScreenContentTools));
         param->av1ScreenContentToolsParam.Header.BufferId = MFX_EXTBUFF_AV1_SCREEN_CONTENT_TOOLS;
         param->av1ScreenContentToolsParam.Header.BufferSz = sizeof(mfxExtAV1ScreenContentTools);
-        param->av1ScreenContentToolsParam.IntraBlockCopy  = MFX_CODINGOPTION_OFF;
-        param->av1ScreenContentToolsParam.Palette         = MFX_CODINGOPTION_OFF;
+        param->av1ScreenContentToolsParam.IntraBlockCopy  = 0;
+        param->av1ScreenContentToolsParam.Palette         = 0;
 
         // GOP & rate control
         param->gop.b_pyramid          =  1; // enabled by default (if supported)
@@ -3540,7 +3426,7 @@ int hb_qsv_param_default(hb_qsv_param_t
         param->gop.gop_ref_dist       = -1; // set automatically
         param->gop.int_ref_cycle_size = -1; // set automatically
         param->rc.icq                 =  1; // enabled by default (if supported)
-        param->rc.lookahead           =  1; // enabled by default (if supported)
+        param->rc.lookahead           =  0; // disabled by default
         param->rc.cqp_offsets[0]      =  0;
         param->rc.cqp_offsets[1]      =  2;
         param->rc.cqp_offsets[2]      =  4;
@@ -3548,73 +3434,12 @@ int hb_qsv_param_default(hb_qsv_param_t
         param->rc.vbv_buffer_size     =  0; // set automatically
         param->rc.vbv_buffer_init     = .0; // set automatically
 
-        // introduced in API 1.0
-        memset(videoParam, 0, sizeof(mfxVideoParam));
-        param->videoParam                   = videoParam;
-        param->videoParam->Protected        = 0; // reserved, must be 0
-        param->videoParam->NumExtParam      = 0;
-        param->videoParam->IOPattern        = MFX_IOPATTERN_IN_SYSTEM_MEMORY;
-        param->videoParam->mfx.TargetUsage  = MFX_TARGETUSAGE_BALANCED;
-        param->videoParam->mfx.GopOptFlag   = MFX_GOP_CLOSED;
-        param->videoParam->mfx.NumThread    = 0; // deprecated, must be 0
-        param->videoParam->mfx.EncodedOrder = 0; // input is in display order
-        param->videoParam->mfx.IdrInterval  = 0; // all I-frames are IDR
-        param->videoParam->mfx.NumSlice     = 0; // use Media SDK default
-        param->videoParam->mfx.NumRefFrame  = 0; // use Media SDK default
-        param->videoParam->mfx.GopPicSize   = 0; // use Media SDK default
-        param->videoParam->mfx.GopRefDist   = 0; // use Media SDK default
-        param->videoParam->mfx.LowPower     = MFX_CODINGOPTION_OFF; // use Media SDK default
-        // introduced in API 1.1
-        param->videoParam->AsyncDepth       = hb_qsv_param_default_async_depth();
-        // introduced in API 1.3
-        param->videoParam->mfx.BRCParamMultiplier = 0; // no multiplier
-
-        // FrameInfo: set by video encoder, except PicStruct
-        param->videoParam->mfx.FrameInfo.PicStruct = MFX_PICSTRUCT_PROGRESSIVE;
+        param->low_power              = 0;
 
-        // attach supported mfxExtBuffer structures to the mfxVideoParam
-        param->videoParam->NumExtParam                                = 0;
-        param->videoParam->ExtParam                                   = param->ExtParamArray;
-        if (info->capabilities & HB_QSV_CAP_VUI_VSINFO)
-        {
-            param->videoParam->ExtParam[param->videoParam->NumExtParam++] = (mfxExtBuffer*)&param->videoSignalInfo;
-        }
-        if (info->capabilities & HB_QSV_CAP_VUI_CHROMALOCINFO)
-        {
-            param->videoParam->ExtParam[param->videoParam->NumExtParam++] = (mfxExtBuffer*)&param->chromaLocInfo;
-        }
-        if (info->capabilities & HB_QSV_CAP_VUI_MASTERINGINFO)
-        {
-            param->videoParam->ExtParam[param->videoParam->NumExtParam++] = (mfxExtBuffer*)&param->masteringDisplayColourVolume;
-        }
-        if (info->capabilities & HB_QSV_CAP_VUI_CLLINFO)
-        {
-            param->videoParam->ExtParam[param->videoParam->NumExtParam++] = (mfxExtBuffer*)&param->contentLightLevelInfo;
-        }
-        if (info->capabilities & HB_QSV_CAP_OPTION1)
-        {
-            param->videoParam->ExtParam[param->videoParam->NumExtParam++] = (mfxExtBuffer*)&param->codingOption;
-        }
-        if (info->capabilities & HB_QSV_CAP_OPTION2)
-        {
-            param->videoParam->ExtParam[param->videoParam->NumExtParam++] = (mfxExtBuffer*)&param->codingOption2;
-        }
-        if (info->capabilities & HB_QSV_CAP_HYPERENCODE)
-        {
-            param->videoParam->ExtParam[param->videoParam->NumExtParam++] = (mfxExtBuffer*)&param->hyperEncodeParam;
-        }
-        if (info->capabilities & HB_QSV_CAP_AV1_BITSTREAM)
-        {
-            param->videoParam->ExtParam[param->videoParam->NumExtParam++] = (mfxExtBuffer*)&param->av1BitstreamParam;
-        }
-        if (info->capabilities & HB_QSV_CAP_AV1_SCREENCONTENT)
-        {
-            param->videoParam->ExtParam[param->videoParam->NumExtParam++] = (mfxExtBuffer*)&param->av1ScreenContentToolsParam;
-        }
 #if defined(_WIN32) || defined(__MINGW32__)
         if (info->capabilities & HB_QSV_CAP_LOWPOWER_ENCODE)
         {
-            param->videoParam->mfx.LowPower = MFX_CODINGOPTION_ON;
+            param->low_power          = 1;
         }
 #endif
     }
@@ -3703,29 +3528,6 @@ const char* hb_qsv_profile_name(uint32_t
     return profile != NULL ? profile->name : NULL;
 }
 
-const char* hb_qsv_level_name(uint32_t codec_id, uint16_t level_id)
-{
-    hb_triplet_t *level = NULL;
-    switch (codec_id)
-    {
-        case MFX_CODEC_AVC:
-            level = hb_triplet4value(hb_qsv_h264_levels, level_id);
-            break;
-
-        case MFX_CODEC_HEVC:
-            level = hb_triplet4value(hb_qsv_h265_levels, level_id);
-            break;
-
-        case MFX_CODEC_AV1:
-            level = hb_triplet4value(hb_qsv_av1_levels, level_id);
-            break;
-
-        default:
-            break;
-    }
-    return level != NULL ? level->name : NULL;
-}
-
 const char* hb_qsv_frametype_name(uint16_t qsv_frametype)
 {
     if      (qsv_frametype & MFX_FRAMETYPE_IDR)
@@ -3880,623 +3682,6 @@ int hb_qsv_param_parse_dx_index(hb_job_t
 }
 
 #if defined(_WIN32) || defined(__MINGW32__)
-// Direct X
-#define COBJMACROS
-#include <d3d11.h>
-
-static int hb_qsv_find_surface_idx(const QSVMid *mids, const int nb_mids, const QSVMid *mid)
-{
-    if (mids)
-    {
-        int i;
-        for (i = 0; i < nb_mids; i++) {
-            const QSVMid *m = &mids[i];
-            if ((m->handle_pair->first == mid->handle_pair->first) &&
-                (m->handle_pair->second == mid->handle_pair->second))
-                return i;
-        }
-    }
-    return -1;
-}
-
-int hb_qsv_replace_surface_mid(HBQSVFramesContext* hb_enc_qsv_frames_ctx, const QSVMid *mid, mfxFrameSurface1 *surface)
-{
-    if (!hb_enc_qsv_frames_ctx || !surface)
-        return -1;
-
-    int ret = hb_qsv_find_surface_idx(hb_enc_qsv_frames_ctx->mids, hb_enc_qsv_frames_ctx->nb_mids, mid);
-    if (ret < 0)
-    {
-        hb_error("hb_qsv_replace_surface_mid: Surface with MemId=%p has not been found in the pool", mid);
-        return -1;
-    }
-    else
-    {
-        surface->Data.MemId = &hb_enc_qsv_frames_ctx->mids[ret];
-    }
-    return 0;
-}
-
-int hb_qsv_release_surface_from_pool_by_surface_pointer(HBQSVFramesContext* hb_enc_qsv_frames_ctx, const mfxFrameSurface1 *surface)
-{
-    if (!(hb_enc_qsv_frames_ctx && hb_enc_qsv_frames_ctx->hw_frames_ctx) || !surface)
-        return -1;
-
-    AVHWFramesContext *frames_ctx = (AVHWFramesContext*)hb_enc_qsv_frames_ctx->hw_frames_ctx->data;
-    AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;
-
-    for(int i = 0; i < hb_enc_qsv_frames_ctx->nb_mids; i++)
-    {
-        mfxFrameSurface1 *pool_surface = &frames_hwctx->surfaces[i];
-        if(surface == pool_surface && hb_enc_qsv_frames_ctx->pool[i] > 0)
-        {
-            ff_qsv_atomic_dec(&hb_enc_qsv_frames_ctx->pool[i]);
-            return 0;
-        }
-    }
-    return -1;
-}
-
-int hb_qsv_get_mid_by_surface_from_pool(HBQSVFramesContext* hb_enc_qsv_frames_ctx, mfxFrameSurface1 *surface, QSVMid **out_mid)
-{
-    if (!hb_enc_qsv_frames_ctx || !surface)
-        return -1;
-
-    QSVMid *mid = NULL;
-    
-    AVHWFramesContext *frames_ctx = (AVHWFramesContext*)hb_enc_qsv_frames_ctx->hw_frames_ctx->data;
-    AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;
-    // find the first available surface in the pool
-    int count = 0;
-    while(1)
-    {
-        if(count > 30)
-        {
-            hb_error("hb_qsv_get_mid_by_surface_from_pool has not been found or busy", mid);
-            hb_qsv_sleep(10); // prevent hang when all surfaces all used
-            count = 0;
-        }
-
-        for(int i = 0; i < hb_enc_qsv_frames_ctx->nb_mids; i++)
-        {
-            mid = &hb_enc_qsv_frames_ctx->mids[i];
-            mfxFrameSurface1 *pool_surface = &frames_hwctx->surfaces[i];
-            if( (pool_surface->Data.Locked == 0) && (surface == pool_surface))
-            {
-                *out_mid = mid;
-                return 0;
-            }
-        }
-        count++;
-    }
-}
-
-int hb_qsv_get_free_surface_from_pool(HBQSVFramesContext* hb_enc_qsv_frames_ctx, AVFrame* frame, QSVMid** out_mid)
-{
-    if (!hb_enc_qsv_frames_ctx || !frame)
-        return -1;
-
-    AVHWFramesContext *frames_ctx = (AVHWFramesContext*)hb_enc_qsv_frames_ctx->hw_frames_ctx->data;
-    AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;
-
-    // find the first available surface in the pool
-    int count = 0;
-    while(1)
-    {
-        if(count > 30)
-        {
-            hb_qsv_sleep(10); // prevent hang when all surfaces all used
-            count = 0;
-        }
-
-        int ret = av_hwframe_get_buffer(hb_enc_qsv_frames_ctx->hw_frames_ctx, frame, 0);
-        if (ret)
-        {
-            continue;
-        }
-        else
-        {
-            mfxFrameSurface1 *output_surface = (mfxFrameSurface1 *)frame->data[3];
-            for(int i = 0; i < hb_enc_qsv_frames_ctx->nb_mids; i++)
-            {
-                QSVMid* mid = &hb_enc_qsv_frames_ctx->mids[i];
-                mfxFrameSurface1* cur_surface = &frames_hwctx->surfaces[i];
-                if(cur_surface == output_surface)
-                {
-                    if((hb_enc_qsv_frames_ctx->pool[i] == 0) && (output_surface->Data.Locked == 0))
-                    {
-                        *out_mid = mid;
-                        ff_qsv_atomic_inc(&hb_enc_qsv_frames_ctx->pool[i]);
-                        return 0;
-                    }
-                    else
-                    {
-                        // we need to do unref if surface is not taken to be used, otherwise -12.
-                        av_frame_unref(frame);
-                        break;
-                    }
-                }
-            }
-        }
-        count++;
-    }
-}
-
-static int hb_qsv_get_dx_device(hb_job_t *job)
-{
-    AVHWDeviceContext    *device_ctx = (AVHWDeviceContext*)job->qsv.ctx->hb_hw_device_ctx->data;
-    AVQSVDeviceContext *device_hwctx = device_ctx->hwctx;
-    mfxSession        parent_session = device_hwctx->session;
-
-    if (job->qsv.ctx->device_manager_handle == NULL)
-    {
-        mfxIMPL device_impl;
-        int err = MFXQueryIMPL(parent_session, &device_impl);
-        if (err != MFX_ERR_NONE)
-        {
-            hb_error("hb_qsv_get_dx_device: no impl could be retrieved");
-            return -1;
-        }
-
-        if (MFX_IMPL_VIA_D3D11 == MFX_IMPL_VIA_MASK(device_impl))
-        {
-            job->qsv.ctx->device_manager_handle_type = MFX_HANDLE_D3D11_DEVICE;
-        }
-        else
-        {
-            hb_error("hb_qsv_get_dx_device: unsupported impl");
-            return -1;
-        }
-
-        err = MFXVideoCORE_GetHandle(parent_session, job->qsv.ctx->device_manager_handle_type, &job->qsv.ctx->device_manager_handle);
-        if (err != MFX_ERR_NONE)
-        {
-            hb_error("hb_qsv_get_dx_device: no supported hw handle could be retrieved "
-                "from the session\n");
-            return -1;
-        }
-        if (job->qsv.ctx->device_manager_handle_type == MFX_HANDLE_D3D11_DEVICE)
-        {
-            if (job->qsv.ctx->device_context == NULL)
-            {
-                ID3D11Device *device = (ID3D11Device *)job->qsv.ctx->device_manager_handle;
-                ID3D11Device_GetImmediateContext(device, (ID3D11DeviceContext **)&job->qsv.ctx->device_context);
-                if (!job->qsv.ctx->device_context)
-                    return -1;
-            }
-        }
-    }
-    return 0;
-}
-
-void hb_qsv_get_free_surface_from_pool_with_range(HBQSVFramesContext* hb_enc_qsv_frames_ctx, const int start_index, const int end_index, QSVMid** out_mid, mfxFrameSurface1** out_surface)
-{
-    AVHWFramesContext *frames_ctx = (AVHWFramesContext*)hb_enc_qsv_frames_ctx->hw_frames_ctx->data;
-    AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;
-
-    // find the first available surface in the pool
-    int count = 0;
-    while(1)
-    {
-        if (count > 30)
-        {
-            hb_qsv_sleep(10); // prevent hang when all surfaces all used
-            count = 0;
-        }
-
-        for (int i = start_index; i < end_index; i++)
-        {
-            if ((hb_enc_qsv_frames_ctx->pool[i] == 0) && (frames_hwctx->surfaces[i].Data.Locked == 0))
-            {
-                *out_mid = &hb_enc_qsv_frames_ctx->mids[i];
-                *out_surface = &frames_hwctx->surfaces[i];
-                ff_qsv_atomic_inc(&hb_enc_qsv_frames_ctx->pool[i]);
-                return;
-            }
-        }
-        count++;
-    }
-}
-
-static ID3D11Texture2D* hb_qsv_create_dx11_texture_with_bytes(ID3D11Device* device, const byte* bytes, int stride, int width, int height, DXGI_FORMAT texture_format)
-{
-    if (device == NULL)
-    {
-        hb_error("hb_qsv_create_dx11_texture_with_bytes: device is NULL");
-        return NULL;
-    }
-
-    ID3D11Texture2D* tex;
-    D3D11_TEXTURE2D_DESC tdesc;
-    D3D11_SUBRESOURCE_DATA tbsd;
-    HRESULT hr;
-
-    tbsd.pSysMem = (void *)bytes;
-    tbsd.SysMemPitch = stride;
-
-    tdesc.Width = width;
-    tdesc.Height = height;
-    tdesc.MipLevels = 1;
-    tdesc.ArraySize = 1;
-    tdesc.SampleDesc.Count = 1;
-    tdesc.SampleDesc.Quality = 0;
-    tdesc.Usage = D3D11_USAGE_DEFAULT;
-    tdesc.Format = texture_format;
-    tdesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
-    tdesc.CPUAccessFlags = 0;
-    tdesc.MiscFlags = 0;
-
-    hr = ID3D11Device_CreateTexture2D(device, &tdesc, &tbsd, &tex);
-    if (FAILED(hr))
-    {
-        hb_error("CreateTexture: ID3D11Device_CreateTexture2D failed", hr);
-        return NULL;
-    }
-    return tex;
-}
-
-static int hb_qsv_copy_surface(hb_qsv_context *ctx, void* output_surface, int output_index, void* input_surface, int input_index)
-{
-    if(!ctx)
-    {
-        hb_error("hb_qsv_copy_surface: qsv context is NULL");
-        return -1;
-    }
-
-    if (ctx->device_manager_handle_type == MFX_HANDLE_D3D11_DEVICE)
-    {
-        ID3D11DeviceContext_CopySubresourceRegion((ID3D11DeviceContext *)ctx->device_context, output_surface, output_index, 0, 0, 0, input_surface, input_index, NULL);
-        ID3D11DeviceContext_Flush((ID3D11DeviceContext *)ctx->device_context);
-    }
-    else
-    {
-        hb_error("hb_qsv_copy_surface: incorrect device type %d", ctx->device_manager_handle_type);
-        return -1;
-    }
-    return 0;
-}
-
-hb_buffer_t * hb_qsv_copy_video_buffer_to_hw_video_buffer(hb_job_t *job, hb_buffer_t *in, const int is_vpp)
-{
-    hb_buffer_t *out = hb_buffer_wrapper_init();
-
-    if (out == NULL)
-    {
-        goto fail;
-    }
-
-    // Alloc new frame
-    AVFrame *frame = av_frame_alloc();
-
-    if (frame == NULL)
-    {
-        hb_error("hb_qsv_copy_video_buffer_to_hw_video_buffer: av_frame_alloc() failed");
-        goto fail;
-    }
-
-    frame->pts              = in->s.start;
-    frame->duration         = in->s.duration;
-    frame->width            = in->f.width;
-    frame->height           = in->f.height;
-    frame->format           = in->f.fmt;
-
-    if (in->s.combed)
-    {
-        frame->flags |= AV_FRAME_FLAG_INTERLACED;
-    }
-    else
-    {
-        frame->flags &= ~AV_FRAME_FLAG_INTERLACED;
-    }
-
-    if (in->s.flags & PIC_FLAG_TOP_FIELD_FIRST)
-    {
-        frame->flags |= AV_FRAME_FLAG_TOP_FIELD_FIRST;
-    }
-    else
-    {
-        frame->flags &= ~AV_FRAME_FLAG_TOP_FIELD_FIRST;
-    }
-
-    frame->format          = in->f.fmt;
-    frame->color_primaries = hb_colr_pri_hb_to_ff(in->f.color_prim);
-    frame->color_trc       = hb_colr_tra_hb_to_ff(in->f.color_transfer);
-    frame->colorspace      = hb_colr_mat_hb_to_ff(in->f.color_matrix);
-    frame->color_range     = in->f.color_range;
-    frame->chroma_location = in->f.chroma_location;
-
-    out->storage_type = AVFRAME;
-    out->storage = frame;
-    out->f = in->f;
-    hb_buffer_copy_props(out, in);
-
-    QSVMid *mid = NULL;
-    mfxFrameSurface1 *surface = NULL;
-    HBQSVFramesContext *hb_qsv_frames_ctx = NULL;
-
-    if (is_vpp)
-    {
-        hb_qsv_frames_ctx = job->qsv.ctx->hb_vpp_qsv_frames_ctx;
-    }
-    else
-    {
-        hb_qsv_frames_ctx = job->qsv.ctx->hb_dec_qsv_frames_ctx;
-    }
-
-    if (job->qsv.ctx->device_manager_handle_type == MFX_HANDLE_D3D11_DEVICE)
-    {
-        DXGI_FORMAT texture_format;
-        ID3D11Texture2D* output_surface;
-        D3D11_TEXTURE2D_DESC desc = { 0 };
-        if (job->input_pix_fmt == AV_PIX_FMT_NV12)
-        {
-            texture_format = DXGI_FORMAT_NV12;
-        }
-        else if(job->input_pix_fmt == AV_PIX_FMT_P010)
-        {
-            texture_format = DXGI_FORMAT_P010;
-        }
-        else
-        {
-            hb_error("hb_qsv_copy_video_buffer_to_hw_video_buffer: unsupported texture_format=%d", job->input_pix_fmt);
-            goto fail;
-        }
-        hb_qsv_get_free_surface_from_pool_with_range(hb_qsv_frames_ctx, 0, HB_QSV_POOL_SURFACE_SIZE, &mid, &surface);
-        output_surface = mid->handle_pair->first;
-        ID3D11Texture2D_GetDesc(output_surface, &desc);
-        ID3D11Texture2D* blank_surface = hb_qsv_create_dx11_texture_with_bytes(job->qsv.ctx->device_manager_handle,
-            in->data, in->plane[0].stride, desc.Width, desc.Height, texture_format);
-        if (!blank_surface)
-        {
-            hb_error("hb_qsv_copy_video_buffer_to_hw_video_buffer: hb_qsv_create_dx11_texture_with_bytes() failed");
-            goto fail;
-        }
-        mfxHDLPair* output_pair = (mfxHDLPair*)surface->Data.MemId;
-        int output_index = (int)(intptr_t)output_pair->second == MFX_INFINITE ? 0 : (int)(intptr_t)output_pair->second;
-        int ret = hb_qsv_copy_surface(job->qsv.ctx, output_surface, output_index, blank_surface, 0);
-        if (ret < 0)
-        {
-            hb_error("hb_qsv_copy_video_buffer_to_hw_video_buffer: hb_qsv_copy_surface() failed");
-            goto fail;
-        }
-        ID3D11Texture2D_Release(blank_surface);
-    }
-
-    frame->data[3] = (uint8_t *)surface;
-
-    out->qsv_details.qsv_frames_ctx = hb_qsv_frames_ctx;
-    out->qsv_details.qsv_atom       = NULL;
-    out->qsv_details.ctx            = job->qsv.ctx;
-
-    return out;
-
-fail:
-    hb_buffer_close(&out);
-    av_frame_free(&frame);
-    return NULL;
-}
-
-hb_buffer_t * hb_qsv_buffer_dup(hb_job_t *job, hb_buffer_t *in, const int is_vpp)
-{
-    if (in->storage == NULL || in->storage_type != AVFRAME)
-    {
-        hb_error("hb_qsv_buffer_dup: in->storage is NULL");
-        goto fail;
-    }
-
-    hb_buffer_t *out = hb_buffer_wrapper_init();
-
-    if (out == NULL)
-    {
-        goto fail;
-    }
-
-    // Alloc new frame
-    AVFrame *frame_copy = av_frame_alloc();
-
-    if (frame_copy == NULL)
-    {
-        hb_error("hb_qsv_buffer_dup: av_frame_alloc() failed");
-        goto fail;
-    }
-
-    AVFrame *frame = (AVFrame *)in->storage;
-    frame_copy->format     = frame->format;
-    frame_copy->width      = frame->width;
-    frame_copy->height     = frame->height;
-    frame_copy->ch_layout  = frame->ch_layout;
-    frame_copy->nb_samples = frame->nb_samples;
-
-    mfxFrameSurface1 *input_surface = (mfxFrameSurface1 *)frame->data[3];
-    mfxHDLPair *input_pair = (mfxHDLPair*)input_surface->Data.MemId;
-
-    int ret = av_frame_copy_props(frame_copy, frame);
-    if (ret < 0)
-    {
-        hb_error("hb_qsv_buffer_dup: av_frame_copy_props error %d", ret);
-        goto fail;
-    }
-
-    out->storage_type = AVFRAME;
-    out->storage = frame_copy;
-    out->f = in->f;
-    hb_buffer_copy_props(out, in);
-
-    QSVMid *mid = NULL;
-    mfxFrameSurface1 *surface = NULL;
-    HBQSVFramesContext *hb_qsv_frames_ctx = NULL;
-
-    if (is_vpp)
-    {
-        hb_qsv_frames_ctx = job->qsv.ctx->hb_vpp_qsv_frames_ctx;
-    }
-    else
-    {
-        hb_qsv_frames_ctx = job->qsv.ctx->hb_dec_qsv_frames_ctx;
-    }
-
-    if (job->qsv.ctx->device_manager_handle_type == MFX_HANDLE_D3D11_DEVICE)
-    {
-        hb_qsv_get_free_surface_from_pool_with_range(hb_qsv_frames_ctx, 0, HB_QSV_POOL_SURFACE_SIZE, &mid, &surface);
-        mfxHDLPair* output_pair = (mfxHDLPair*)surface->Data.MemId;
-        int input_index = (int)(intptr_t)input_pair->second == MFX_INFINITE ? 0 : (int)(intptr_t)input_pair->second;
-        int output_index = (int)(intptr_t)output_pair->second == MFX_INFINITE ? 0 : (int)(intptr_t)output_pair->second;
-        int ret = hb_qsv_copy_surface(job->qsv.ctx, mid->handle_pair->first, output_index, input_pair->first, input_index);
-        if (ret < 0)
-        {
-            hb_error("hb_qsv_buffer_dup: hb_qsv_copy_surface() failed");
-            goto fail;
-        }
-    }
-    else
-    {
-        hb_error("hb_qsv_buffer_dup: device_manager_handle_type unsupported=%d", job->qsv.ctx->device_manager_handle_type);
-        goto fail;
-    }
-
-    frame_copy->data[3] = (uint8_t *)surface;
-
-    out->qsv_details.qsv_frames_ctx = hb_qsv_frames_ctx;
-    out->qsv_details.qsv_atom       = NULL;
-    out->qsv_details.ctx            = job->qsv.ctx;
-
-    return out;
-
-fail:
-    hb_buffer_close(&out);
-    av_frame_free(&frame_copy);
-    return NULL;
-}
-
-hb_buffer_t * hb_qsv_copy_avframe_to_video_buffer(hb_job_t *job, AVFrame *frame, AVRational time_base, const int is_vpp)
-{
-    hb_buffer_t *out = hb_buffer_wrapper_init();
-
-    if (out == NULL)
-    {
-        return NULL;
-    }
-
-    // Alloc new frame
-    AVFrame *frame_copy = av_frame_alloc();
-    if (frame_copy == NULL)
-    {
-        goto fail;
-    }
-
-    frame_copy->format         = frame->format;
-    frame_copy->width          = frame->width;
-    frame_copy->height         = frame->height;
-    frame_copy->ch_layout      = frame->ch_layout;
-    frame_copy->nb_samples     = frame->nb_samples;
-
-    int ret = av_frame_copy_props(frame_copy, frame);
-    if (ret < 0)
-    {
-        hb_error("hb_qsv_copy_avframe_to_video_buffer: av_frame_copy_props error %d", ret);
-        goto fail;
-    }
-
-    out->storage_type = AVFRAME;
-    out->storage = frame_copy;
-
-    out->s.type = FRAME_BUF;
-    out->f.width  = frame_copy->width;
-    out->f.height = frame_copy->height;
-    hb_avframe_set_video_buffer_flags(out, frame, time_base);
-
-    out->side_data = (void **)frame_copy->side_data;
-    out->nb_side_data = frame_copy->nb_side_data;
-
-    QSVMid *mid = NULL;
-    mfxFrameSurface1 *output_surface = NULL;
-    HBQSVFramesContext *hb_qsv_frames_ctx = NULL;
-
-    if (is_vpp)
-    {
-        hb_qsv_frames_ctx = job->qsv.ctx->hb_vpp_qsv_frames_ctx;
-    }
-    else
-    {
-        hb_qsv_frames_ctx = job->qsv.ctx->hb_dec_qsv_frames_ctx;
-        if (!hb_qsv_frames_ctx || !hb_qsv_frames_ctx->hw_frames_ctx)
-        {
-            AVHWFramesContext *frames_ctx = (AVHWFramesContext *)frame->hw_frames_ctx->data;
-            ret = hb_qsv_create_ffmpeg_dec_pool(job, frame_copy->width, frame_copy->height, frames_ctx->sw_format);
-            if (ret < 0)
-            {
-                hb_error("hb_qsv_copy_avframe_to_video_buffer: hb_create_ffmpeg_pool decoder failed %d", ret);
-                goto fail;
-            }
-        }
-    }
-
-    if (!is_vpp && hb_qsv_hw_filters_via_video_memory_are_enabled(job))
-    {
-        ret = hb_qsv_get_free_surface_from_pool(hb_qsv_frames_ctx, frame_copy, &mid);
-        if (ret < 0)
-        {
-            hb_error("hb_qsv_copy_avframe_to_video_buffer: hb_qsv_get_free_surface_from_pool error %d", ret);
-            goto fail;
-        }
-        output_surface = (mfxFrameSurface1 *)frame_copy->data[3];
-    }
-    else
-    {
-        hb_qsv_get_free_surface_from_pool_with_range(hb_qsv_frames_ctx, 0, HB_QSV_POOL_SURFACE_SIZE, &mid, &output_surface);
-    }
-
-    if (job->qsv.ctx->device_manager_handle_type == MFX_HANDLE_D3D11_DEVICE)
-    {
-        mfxFrameSurface1 *input_surface = (mfxFrameSurface1 *)frame->data[3];
-        mfxHDLPair *input_pair = (mfxHDLPair *)input_surface->Data.MemId;
-
-        // Need to pass 0 instead of MFX_INFINITE to DirectX as index of surface
-        int input_index = (int)(intptr_t)input_pair->second == MFX_INFINITE ? 0 : (int)(intptr_t)input_pair->second;
-        int output_index = (int)(intptr_t)mid->handle_pair->second == MFX_INFINITE ? 0 : (int)(intptr_t)mid->handle_pair->second;
-
-        // Copy all surface fields
-        *output_surface = *input_surface;
-        output_surface->Info.CropW = frame->width;
-        output_surface->Info.CropH = frame->height;
-        if (hb_qsv_hw_filters_via_video_memory_are_enabled(job))
-        {
-            // Make sure that we pass handle_pair to scale_qsv
-            output_surface->Data.MemId = mid->handle_pair;
-        }
-        else
-        {
-            // Make sure that we pass QSVMid to QSV encoder
-            output_surface->Data.MemId = mid;
-        }
-
-        // Copy input surface to surface from the pool
-        ret = hb_qsv_copy_surface(job->qsv.ctx, mid->handle_pair->first, output_index, input_pair->first, input_index);
-        if (ret < 0)
-        {
-            hb_error("hb_qsv_copy_avframe_to_video_buffer: hb_qsv_copy_surface() failed");
-            goto fail;
-        }
-    }
-    else
-    {
-        hb_error("hb_qsv_copy_avframe_to_video_buffer: incorrect mfx impl");
-        goto fail;
-    }
-
-    frame_copy->data[3] = (uint8_t *)output_surface;
-
-    out->qsv_details.qsv_frames_ctx = hb_qsv_frames_ctx;
-    out->qsv_details.qsv_atom       = NULL;
-    out->qsv_details.ctx            = job->qsv.ctx;
-
-    return out;
-
-fail:
-    hb_buffer_close(&out);
-    av_frame_free(&frame_copy);
-    return NULL;
-}
 
 static int qsv_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)
 {
@@ -4508,19 +3693,8 @@ static int qsv_get_buffer(AVCodecContext
     return ret;
 }
 
-void hb_qsv_uninit_dec(AVCodecContext *s)
-{
-    if(s && s->hw_frames_ctx)
-        av_buffer_unref(&s->hw_frames_ctx);
-}
-
 void hb_qsv_uninit_enc(hb_job_t *job)
 {
-    if (job->qsv.ctx && job->qsv.ctx->device_context)
-    {
-        ID3D11DeviceContext_Release((ID3D11DeviceContext *)job->qsv.ctx->device_context);
-        job->qsv.ctx->device_context = NULL;
-    }
     if(job->qsv.ctx && job->qsv.ctx->hb_ffmpeg_qsv_hw_frames_ctx)
     {
         if (job->qsv.ctx->hb_ffmpeg_qsv_hw_frames_ctx)
@@ -4580,208 +3754,39 @@ static int hb_qsv_ffmpeg_set_options(hb_
     return 0;
 }
 
-int hb_qsv_device_init(hb_job_t *job)
+int hb_qsv_device_init(hb_job_t *job, void **hw_device_ctx)
 {
     int err;
     AVDictionary *dict = NULL;
+    AVBufferRef *ctx = NULL;
 
-    err = hb_qsv_ffmpeg_set_options(job, &dict);
-
-    if (err < 0)
-        return err;
+    if (job)
+    {
+        err = hb_qsv_ffmpeg_set_options(job, &dict);
+        if (err < 0)
+        {
+            return err;
+        }
+    }
 
-    err = av_hwdevice_ctx_create(&job->qsv.ctx->hb_hw_device_ctx, AV_HWDEVICE_TYPE_QSV,
+    err = av_hwdevice_ctx_create(&ctx, AV_HWDEVICE_TYPE_QSV,
                                  0, dict, 0);
-    if (err < 0) {
+    if (err < 0)
+    {
         hb_error("hb_qsv_device_init: error creating a QSV device %d", err);
         goto err_out;
     }
 
+    *hw_device_ctx = ctx;
 err_out:
     if (dict)
-        av_dict_free(&dict);
-
-    return err;
-}
-
-int hb_qsv_create_ffmpeg_pool(hb_job_t *job, int coded_width, int coded_height, enum AVPixelFormat sw_pix_fmt, int pool_size, int extra_hw_frames, AVBufferRef **out_hw_frames_ctx)
-{
-    AVHWFramesContext *frames_ctx;
-    AVQSVFramesContext *frames_hwctx;
-
-    AVBufferRef *hw_frames_ctx = *out_hw_frames_ctx;
-
-    int ret = 0;
-
-    if (job->qsv.ctx && !job->qsv.ctx->hb_hw_device_ctx) {
-        // parse and use user-specified encoder options for decoder, if present
-        if (job->encoder_options != NULL && *job->encoder_options)
-        {
-            hb_dict_t *options_list;
-            options_list = hb_encopts_to_dict(job->encoder_options, job->vcodec);
-
-            hb_dict_iter_t iter;
-            for (iter  = hb_dict_iter_init(options_list);
-                iter != HB_DICT_ITER_DONE;
-                iter  = hb_dict_iter_next(options_list, iter))
-            {
-                const char *key = hb_dict_iter_key(iter);
-                if ((!strcasecmp(key, "scalingmode") || !strcasecmp(key, "vpp-sm")) && (hb_qsv_hw_filters_via_video_memory_are_enabled(job) ||
-                      hb_qsv_hw_filters_via_system_memory_are_enabled(job)))
-                {
-                    hb_qsv_info_t *info = hb_qsv_encoder_info_get(hb_qsv_get_adapter_index(), job->vcodec);
-                    if (info && (info->capabilities & HB_QSV_CAP_VPP_SCALING))
-                    {
-                        hb_value_t *value = hb_dict_iter_value(iter);
-                        char *mode_key = hb_value_get_string_xform(value);
-                        hb_triplet_t *mode = NULL;
-                        if (mode_key != NULL)
-                        {
-                            mode = hb_triplet4key(hb_qsv_vpp_scale_modes, mode_key);
-                        }
-                        if (mode != NULL)
-                        {
-                            job->qsv.ctx->vpp_scale_mode = mode->key;
-                        }
-                    }
-                }
-                if ((!strcasecmp(key, "interpolationmethod") || !strcasecmp(key, "vpp-im")) && (hb_qsv_hw_filters_via_video_memory_are_enabled(job) ||
-                      hb_qsv_hw_filters_via_system_memory_are_enabled(job)))
-                {
-                    hb_qsv_info_t *info = hb_qsv_encoder_info_get(hb_qsv_get_adapter_index(), job->vcodec);
-                    if (info && (info->capabilities & HB_QSV_CAP_VPP_INTERPOLATION))
-                    {
-                        hb_value_t *value = hb_dict_iter_value(iter);
-                        char *mode_key = hb_value_get_string_xform(value);
-                        hb_triplet_t *mode = NULL;
-                        if (mode_key != NULL)
-                        {
-                            mode = hb_triplet4key(hb_qsv_vpp_interpolation_methods, mode_key);
-                        }
-                        if (mode != NULL)
-                        {
-                            job->qsv.ctx->vpp_interpolation_method = mode->key;
-                        }
-                    }
-                }
-            }
-            hb_dict_free(&options_list);
-        }
-
-        ret = hb_qsv_device_init(job);
-        if (ret < 0)
-            return ret;
-    }
-
-    av_buffer_unref(&hw_frames_ctx);
-    hw_frames_ctx = av_hwframe_ctx_alloc(job->qsv.ctx->hb_hw_device_ctx);
-    if (!hw_frames_ctx)
-        return AVERROR(ENOMEM);
-
-    *out_hw_frames_ctx = hw_frames_ctx;
-
-    frames_ctx   = (AVHWFramesContext*)hw_frames_ctx->data;
-    frames_hwctx = frames_ctx->hwctx;
-
-    frames_ctx->width             = FFALIGN(coded_width,  32);
-    frames_ctx->height            = FFALIGN(coded_height, 32);
-    frames_ctx->format            = AV_PIX_FMT_QSV;
-    frames_ctx->sw_format         = sw_pix_fmt;
-    frames_ctx->initial_pool_size = pool_size;
-    if (extra_hw_frames >= 0)
-        frames_ctx->initial_pool_size += extra_hw_frames;
-    frames_hwctx->frame_type      = MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET;
-
-    ret = av_hwframe_ctx_init(hw_frames_ctx);
-    if (ret < 0) {
-        hb_error("hb_create_ffmpeg_pool: av_hwframe_ctx_init failed %d", ret);
-        return ret;
-    }
-    return 0;
-}
-
-int hb_qsv_hw_frames_init(AVCodecContext *s)
-{
-    int ret;
-
-    hb_job_t *job = s->opaque;
-    if (!job) {
-        hb_error("hb_qsv_hw_frames_init: job is NULL");
-        return -1;
-    }
-
-    int                           coded_width = s->coded_width;
-    int                          coded_height = s->coded_height;
-    enum AVPixelFormat             sw_pix_fmt = s->sw_pix_fmt;
-    int                       extra_hw_frames = s->extra_hw_frames;
-    AVBufferRef           **out_hw_frames_ctx = &s->hw_frames_ctx;
-
-    ret = hb_qsv_create_ffmpeg_pool(job, coded_width, coded_height, sw_pix_fmt, HB_QSV_POOL_FFMPEG_SURFACE_SIZE, extra_hw_frames, out_hw_frames_ctx);
-    if (ret < 0) {
-        hb_error("hb_qsv_hw_frames_init: hb_create_ffmpeg_pool decoder failed %d", ret);
-        return ret;
-    }
-
-    // hb_qsv_hw_frames_init function called two times by FFmpeg, first with NV12 by default, second with P010 if requested
-    if(job->qsv.ctx && job->qsv.ctx->hb_ffmpeg_qsv_hw_frames_ctx)
     {
-        if (job->qsv.ctx->hb_ffmpeg_qsv_hw_frames_ctx)
-            av_buffer_unref(&job->qsv.ctx->hb_ffmpeg_qsv_hw_frames_ctx);
-        av_free(job->qsv.ctx->hb_ffmpeg_qsv_hw_frames_ctx);
-        job->qsv.ctx->hb_ffmpeg_qsv_hw_frames_ctx = NULL;
-    }
-    job->qsv.ctx->hb_ffmpeg_qsv_hw_frames_ctx = *out_hw_frames_ctx;
-
-    ret = hb_qsv_get_dx_device(job);
-    if (ret < 0) {
-        hb_error("qsv_init: hb_qsv_get_dx_device failed %d", ret);
-        return ret;
+        av_dict_free(&dict);
     }
 
-    return 0;
+    return err;
 }
 
-int hb_qsv_create_ffmpeg_dec_pool(hb_job_t * job, int width, int height, int sw_pix_fmt)
-{
-    if (job->qsv.ctx && job->qsv.ctx->hb_dec_qsv_frames_ctx && job->qsv.ctx->hb_dec_qsv_frames_ctx->hw_frames_ctx)
-    {
-        if (job->qsv.ctx->hb_dec_qsv_frames_ctx->mids_buf)
-            av_buffer_unref(&job->qsv.ctx->hb_dec_qsv_frames_ctx->mids_buf);
-        job->qsv.ctx->hb_dec_qsv_frames_ctx->mids_buf = NULL;
-        if (job->qsv.ctx->hb_dec_qsv_frames_ctx->hw_frames_ctx)
-            av_buffer_unref(&job->qsv.ctx->hb_dec_qsv_frames_ctx->hw_frames_ctx);
-        job->qsv.ctx->hb_dec_qsv_frames_ctx->hw_frames_ctx = NULL;
-    }
-
-    int ret = hb_qsv_create_ffmpeg_pool(job, width, height, sw_pix_fmt, HB_QSV_POOL_SURFACE_SIZE, 0, &job->qsv.ctx->hb_dec_qsv_frames_ctx->hw_frames_ctx);
-    if (ret < 0)
-    {
-        hb_error("hb_qsv_create_ffmpeg_dec_pool allocation failed");
-        return ret;
-    }
-
-    AVHWFramesContext *frames_ctx;
-    AVQSVFramesContext *frames_hwctx;
-    AVBufferRef *hw_frames_ctx;
-
-    hw_frames_ctx = job->qsv.ctx->hb_dec_qsv_frames_ctx->hw_frames_ctx;
-    frames_ctx   = (AVHWFramesContext*)hw_frames_ctx->data;
-    frames_hwctx = frames_ctx->hwctx;
-    mfxHDLPair* handle_pair = (mfxHDLPair*)frames_hwctx->surfaces[0].Data.MemId;
-    HBQSVFramesContext *hb_dec_qsv_frames_ctx = job->qsv.ctx->hb_dec_qsv_frames_ctx;
-    hb_dec_qsv_frames_ctx->input_texture = ((size_t)handle_pair->second != MFX_INFINITE) ? handle_pair->first : NULL;
-
-    /* allocate the memory ids for the external frames */
-    av_buffer_unref(&hb_dec_qsv_frames_ctx->mids_buf);
-    hb_dec_qsv_frames_ctx->mids_buf = hb_qsv_create_mids(hb_dec_qsv_frames_ctx->hw_frames_ctx);
-    if (!hb_dec_qsv_frames_ctx->mids_buf)
-        return AVERROR(ENOMEM);
-    hb_dec_qsv_frames_ctx->mids    = (QSVMid*)hb_dec_qsv_frames_ctx->mids_buf->data;
-    hb_dec_qsv_frames_ctx->nb_mids = frames_hwctx->nb_surfaces;
-    memset(hb_dec_qsv_frames_ctx->pool, 0, hb_dec_qsv_frames_ctx->nb_mids * sizeof(hb_dec_qsv_frames_ctx->pool[0]));
-
-    return 0;
-}
 int hb_qsv_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)
 {
     if (frame->format == AV_PIX_FMT_QSV)
@@ -4790,76 +3795,10 @@ int hb_qsv_get_buffer(AVCodecContext *s,
     return avcodec_default_get_buffer2(s, frame, flags);
 }
 
-enum AVPixelFormat hb_qsv_get_format(AVCodecContext *s, const enum AVPixelFormat *pix_fmts)
+int hb_qsv_are_filters_supported(hb_job_t *job)
 {
-    int n;
-    hb_job_t *job = s->opaque;
-
-    // Find end of list.
-    for (n = 0; pix_fmts[n] != AV_PIX_FMT_NONE; n++);
-    // if not full path, take the system format, it must be the last entry
-    if (hb_qsv_get_memory_type(job) == MFX_IOPATTERN_OUT_SYSTEM_MEMORY)
-        return pix_fmts[n - 1];
-
-    while (*pix_fmts != AV_PIX_FMT_NONE) {
-        if (*pix_fmts == AV_PIX_FMT_QSV) {
-            int ret = hb_qsv_hw_frames_init(s);
-            if (ret < 0) {
-                hb_error("hb_qsv_get_format: QSV hwaccel initialization failed");
-                return AV_PIX_FMT_NONE;
-            }
-            if (s->hw_frames_ctx) {
-                s->hw_frames_ctx = av_buffer_ref(s->hw_frames_ctx);
-                if (!s->hw_frames_ctx)
-                    return AV_PIX_FMT_NONE;
-            }
-            return AV_PIX_FMT_QSV;
-        }
-
-        pix_fmts++;
-    }
-
-    hb_error("hb_qsv_get_format: the QSV pixel format not offered in get_format()");
-    return AV_PIX_FMT_NONE;
-}
-
-int hb_qsv_create_ffmpeg_vpp_pool(hb_filter_init_t *init, int width, int height)
-{
-    if (init->job->qsv.ctx && init->job->qsv.ctx->hb_vpp_qsv_frames_ctx && init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->hw_frames_ctx)
-    {
-        if (init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->mids_buf)
-            av_buffer_unref(&init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->mids_buf);
-        init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->mids_buf = NULL;
-        if (init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->hw_frames_ctx)
-            av_buffer_unref(&init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->hw_frames_ctx);
-        init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->hw_frames_ctx = NULL;
-    }
-
-    int result = hb_qsv_create_ffmpeg_pool(init->job, width, height, init->pix_fmt, HB_QSV_POOL_SURFACE_SIZE, 0, &init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->hw_frames_ctx);
-    if (result < 0)
-    {
-        hb_error("hb_create_ffmpeg_pool vpp allocation failed");
-        return result;
-    }
-    AVHWFramesContext *frames_ctx;
-    AVQSVFramesContext *frames_hwctx;
-    AVBufferRef *hw_frames_ctx;
-
-    hw_frames_ctx = init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->hw_frames_ctx;
-    frames_ctx   = (AVHWFramesContext*)hw_frames_ctx->data;
-    frames_hwctx = frames_ctx->hwctx;
-    mfxHDLPair* handle_pair = (mfxHDLPair*)frames_hwctx->surfaces[0].Data.MemId;
-    init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->input_texture = ((size_t)handle_pair->second != MFX_INFINITE) ? handle_pair->first : NULL;
-
-    /* allocate the memory ids for the external frames */
-    av_buffer_unref(&init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->mids_buf);
-    init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->mids_buf = hb_qsv_create_mids(init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->hw_frames_ctx);
-    if (!init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->mids_buf)
-        return AVERROR(ENOMEM);
-    init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->mids    = (QSVMid*)init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->mids_buf->data;
-    init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->nb_mids = frames_hwctx->nb_surfaces;
-    memset(init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->pool, 0, init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->nb_mids * sizeof(init->job->qsv.ctx->hb_vpp_qsv_frames_ctx->pool[0]));
-    return 0;
+    hb_qsv_sanitize_filter_list(job); 
+    return job->qsv.ctx->num_sw_filters == 0;
 }
 
 int hb_qsv_sanitize_filter_list(hb_job_t *job)
@@ -4901,6 +3840,9 @@ int hb_qsv_sanitize_filter_list(hb_job_t
                             break;
                         }
                     }
+                    case HB_FILTER_AVFILTER:
+                        num_hw_filters++;
+                        break;
                     default:
                         // count only filters with access to frame data
                         num_sw_filters++;
@@ -4927,9 +3869,9 @@ int hb_qsv_sanitize_filter_list(hb_job_t
 
 #else // other OS
 
-int hb_create_ffmpeg_pool(hb_job_t *job, int coded_width, int coded_height, enum AVPixelFormat sw_pix_fmt, int pool_size, int extra_hw_frames, AVBufferRef **out_hw_frames_ctx)
+int hb_qsv_are_filters_supported(hb_job_t *job)
 {
-    return -1;
+    return 0;
 }
 
 int hb_qsv_hw_frames_init(AVCodecContext *s)
@@ -4937,42 +3879,7 @@ int hb_qsv_hw_frames_init(AVCodecContext
     return -1;
 }
 
-int hb_qsv_device_init(hb_job_t *job)
-{
-    return -1;
-}
-
-int hb_qsv_create_ffmpeg_pool(hb_job_t *job, int coded_width, int coded_height, enum AVPixelFormat sw_pix_fmt, int pool_size, int extra_hw_frames, AVBufferRef **out_hw_frames_ctx)
-{
-    return -1;
-}
-
-hb_buffer_t * hb_qsv_copy_video_buffer_to_hw_video_buffer(hb_job_t *job, hb_buffer_t *in, const int is_vpp)
-{
-    return NULL;
-}
-
-hb_buffer_t * hb_qsv_buffer_dup(hb_job_t *job, hb_buffer_t *in, const int is_vpp)
-{
-    return NULL;
-}
-
-hb_buffer_t * hb_qsv_copy_avframe_to_video_buffer(hb_job_t *job, AVFrame *frame, AVRational time_base, const int is_vpp)
-{
-    return NULL;
-}
-
-int hb_qsv_get_free_surface_from_pool(HBQSVFramesContext* hb_enc_qsv_frames_ctx, AVFrame* frame, QSVMid** out_mid)
-{
-    return -1;
-}
-
-void hb_qsv_get_free_surface_from_pool_with_range(HBQSVFramesContext* hb_enc_qsv_frames_ctx, const int start_index, const int end_index, QSVMid** out_mid, mfxFrameSurface1** out_surface)
-{
-    return;
-}
-
-int hb_qsv_replace_surface_mid(HBQSVFramesContext* hb_qsv_frames_ctx, const QSVMid *mid, mfxFrameSurface1 *surface)
+int hb_qsv_device_init(hb_job_t *job, void **hw_device_ctx)
 {
     return -1;
 }
@@ -4987,24 +3894,10 @@ int hb_qsv_get_buffer(AVCodecContext *s,
     return -1;
 }
 
-void hb_qsv_uninit_dec(AVCodecContext *s)
-{
-}
-
 void hb_qsv_uninit_enc(hb_job_t *job)
 {
 }
 
-int hb_qsv_get_mid_by_surface_from_pool(HBQSVFramesContext* hb_enc_qsv_frames_ctx, mfxFrameSurface1 *surface, QSVMid **out_mid)
-{
-    return -1;
-}
-
-int hb_qsv_release_surface_from_pool_by_surface_pointer(HBQSVFramesContext* hb_enc_qsv_frames_ctx, const mfxFrameSurface1 *surface)
-{
-    return -1;
-}
-
 #endif
 
 hb_qsv_context* hb_qsv_context_init()
diff -Naupr a/libhb/qsv_memory.c b/libhb/qsv_memory.c
--- a/libhb/qsv_memory.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/qsv_memory.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,74 +0,0 @@
-/* ********************************************************************* *\
-
-Copyright (C) 2013 Intel Corporation.  All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-- Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-- Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-- Neither the name of Intel Corporation nor the names of its contributors
-may be used to endorse or promote products derived from this software
-without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY INTEL CORPORATION "AS IS" AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL INTEL CORPORATION BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-\* ********************************************************************* */
-
-#include "handbrake/project.h"
-
-#if HB_PROJECT_FEATURE_QSV
-
-#include "handbrake/handbrake.h"
-#include "handbrake/hbffmpeg.h"
-#include "handbrake/qsv_memory.h"
-
-int qsv_copy_buffer_to_surface(mfxFrameSurface1* dst, hb_buffer_t* src)
-{
-    uint8_t* out_luma = dst->Data.Y;
-    uint8_t* out_chroma = dst->Data.VU;
-    int      out_pitch = dst->Data.Pitch;
-    int      out_height = dst->Info.Height;
-
-    // input buffer alignment from FFmpeg for p010 and nv12 could be different from surface alignment
-    if (out_pitch == src->plane[0].stride)
-    {
-        int height = FFMIN(out_height, src->plane[0].height);
-        memcpy(out_luma, src->plane[0].data, height * src->plane[0].stride);
-        height = FFMIN(out_height, src->plane[1].height);
-        memcpy(out_chroma, src->plane[1].data, height * src->plane[1].stride);
-    }
-    else
-    {
-        int pitch = FFMIN(out_pitch, src->plane[0].stride);
-        int height = FFMIN(out_height, src->plane[0].height);
-        for (int i = 0; i < height; i++)
-        {
-            uint8_t *out_row = out_luma + (i * out_pitch);
-            uint8_t *in_row = src->plane[0].data + i * src->plane[0].stride;
-            memcpy(out_row, in_row, pitch);
-        }
-        pitch = FFMIN(out_pitch, src->plane[1].stride);
-        height = FFMIN(out_height / 2, src->plane[1].height);
-        for (int i = 0; i < height; i++)
-        {
-            uint8_t *out_row = out_chroma + (i * out_pitch);
-            uint8_t *in_row = src->plane[1].data + i * src->plane[1].stride;
-            memcpy(out_row, in_row, pitch);
-        }
-    }
-
-    return 0;
-}
-#endif // HB_PROJECT_FEATURE_QSV
diff -Naupr a/libhb/reader.c b/libhb/reader.c
--- a/libhb/reader.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/reader.c	2025-03-31 11:55:35.250884276 +0200
@@ -1,6 +1,6 @@
 /* reader.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -429,7 +429,7 @@ static void reader_send_eof( hb_work_pri
     int ii;
 
     // send eof buffers downstream to decoders to signal we're done.
-    push_buf(r, r->job->fifo_mpeg2, hb_buffer_eof_init());
+    push_buf(r, r->job->fifo_in, hb_buffer_eof_init());
 
     hb_audio_t *audio;
     for (ii = 0; (audio = hb_list_item(r->job->list_audio, ii)); ++ii)
@@ -689,7 +689,7 @@ static hb_fifo_t ** GetFifoForId( hb_wor
         }
         else
         {
-            r->fifos[0] = job->fifo_mpeg2;
+            r->fifos[0] = job->fifo_in;
             r->fifos[1] = NULL;
             return r->fifos;
         }
diff -Naupr a/libhb/rendersub.c b/libhb/rendersub.c
--- a/libhb/rendersub.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/rendersub.c	2025-03-31 11:55:35.250884276 +0200
@@ -1,6 +1,6 @@
 /* rendersub.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -39,6 +39,7 @@ struct hb_filter_private_s
     int                sws_height;
 
     hb_buffer_list_t   rendered_sub_list;
+    int                changed;
 
     // VOBSUB && PGSSUB
     hb_buffer_list_t   sub_list; // List of active subs
@@ -462,7 +463,7 @@ static int vobsub_work(hb_filter_object_
     render_vobsubs(pv, in);
 
     *buf_in = NULL;
-    *buf_out = pv->blend->work(pv->blend, in, &pv->rendered_sub_list);
+    *buf_out = pv->blend->work(pv->blend, in, &pv->rendered_sub_list, 1);
 
     hb_buffer_list_close(&pv->rendered_sub_list);
 
@@ -659,6 +660,7 @@ static void render_ssa_subs(hb_filter_pr
             }
         }
     }
+    pv->changed = changed;
 }
 
 static void ssa_log(int level, const char *fmt, va_list args, void *data)
@@ -882,33 +884,18 @@ static int ssa_work(hb_filter_object_t *
     render_ssa_subs(pv, in->s.start);
 
     *buf_in  = NULL;
-    *buf_out = pv->blend->work(pv->blend, in, &pv->rendered_sub_list);
+    *buf_out = pv->blend->work(pv->blend, in, &pv->rendered_sub_list, pv->changed);
 
     return HB_FILTER_OK;
 }
 
 static int cc608sub_post_init(hb_filter_object_t *filter, hb_job_t *job)
 {
-    // Text subtitles for which we create a dummy ASS header need
-    // to have the header rewritten with the correct dimensions.
-    int height = job->title->geometry.height - job->crop[0] - job->crop[1];
-    int width = job->title->geometry.width - job->crop[2] - job->crop[3];
-    int safe_height = 0.8 * job->title->geometry.height;
-    // Use fixed width font for CC
-    hb_set_ssa_extradata(&filter->subtitle->extradata, HB_FONT_MONO,
-                         .08 * safe_height, width, height);
     return ssa_post_init(filter, job);
 }
 
 static int textsub_post_init(hb_filter_object_t *filter, hb_job_t *job)
 {
-    // Text subtitles for which we create a dummy ASS header need
-    // to have the header rewritten with the correct dimensions.
-    int height = job->title->geometry.height - job->crop[0] - job->crop[1];
-    int width = job->title->geometry.width - job->crop[2] - job->crop[3];
-    hb_set_ssa_extradata(&filter->subtitle->extradata, HB_FONT_SANS,
-                         .066 * job->title->geometry.height,
-                         width, height);
     return ssa_post_init(filter, job);
 }
 
@@ -1020,7 +1007,7 @@ static int textsub_work(hb_filter_object
     render_ssa_subs(pv, in->s.start);
 
     *buf_in  = NULL;
-    *buf_out = pv->blend->work(pv->blend, in, &pv->rendered_sub_list);
+    *buf_out = pv->blend->work(pv->blend, in, &pv->rendered_sub_list, pv->changed);
 
     return HB_FILTER_OK;
 }
@@ -1131,18 +1118,23 @@ static int pgssub_work(hb_filter_object_
     render_pgs_subs(pv, in);
 
     *buf_in = NULL;
-    *buf_out = pv->blend->work(pv->blend, in, &pv->rendered_sub_list);
+    *buf_out = pv->blend->work(pv->blend, in, &pv->rendered_sub_list, 1);
 
     hb_buffer_list_close(&pv->rendered_sub_list);
 
     return HB_FILTER_OK;
 }
 
-static hb_blend_object_t * hb_blend_init(int hw_pixfmt, int in_pix_fmt, int in_chroma_location, int sub_pix_fmt)
+static hb_blend_object_t * hb_blend_init(hb_filter_init_t init, int sub_pix_fmt)
 {
     hb_blend_object_t *blend;
-    switch (hw_pixfmt)
+    switch (init.hw_pix_fmt)
     {
+#if defined(__APPLE__)
+        case AV_PIX_FMT_VIDEOTOOLBOX:
+            blend = &hb_blend_vt;
+            break;
+#endif
         default:
             blend = &hb_blend;
             break;
@@ -1156,7 +1148,9 @@ static hb_blend_object_t * hb_blend_init
     }
 
     memcpy(blend_copy, blend, sizeof(hb_blend_object_t));
-    if (blend_copy->init(blend_copy, in_pix_fmt, in_chroma_location, sub_pix_fmt))
+    if (blend_copy->init(blend_copy, init.geometry.width, init.geometry.height,
+                         init.pix_fmt, init.chroma_location,
+                         init.color_range, sub_pix_fmt))
     {
         free(blend_copy);
         hb_error("render_sub: blend init failed");
@@ -1280,9 +1274,7 @@ static int hb_rendersub_post_init(hb_fil
         return 1;
     }
 
-    pv->blend = hb_blend_init(pv->input.hw_pix_fmt,
-                              pv->input.pix_fmt, pv->input.chroma_location,
-                              pv->pix_fmt_alpha);
+    pv->blend = hb_blend_init(pv->input, pv->pix_fmt_alpha);
 
     if (pv->blend == NULL)
     {
diff -Naupr a/libhb/rotate.c b/libhb/rotate.c
--- a/libhb/rotate.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/rotate.c	2025-03-31 11:55:35.250884276 +0200
@@ -1,6 +1,6 @@
 /* rotate.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -12,8 +12,6 @@
 
 #if HB_PROJECT_FEATURE_QSV && (defined( _WIN32 ) || defined( __MINGW32__ ))
 #include "handbrake/qsv_common.h"
-#include "libavutil/hwcontext_qsv.h"
-#include "libavutil/hwcontext.h"
 #endif
 
 static int rotate_init(hb_filter_object_t * filter, hb_filter_init_t * init);
@@ -90,16 +88,6 @@ static int qsv_rotate_init(hb_filter_pri
             break;
     }
 
-    if (hb_qsv_hw_filters_via_video_memory_are_enabled(init->job))
-    {
-        int result = hb_qsv_create_ffmpeg_vpp_pool(init, width, height);
-        if (result < 0)
-        {
-            hb_error("hb_create_ffmpeg_pool vpp allocation failed");
-            return result;
-        }
-    }
-
     if (trans != NULL)
     {
         hb_dict_t * avfilter = hb_dict_init();
@@ -195,7 +183,8 @@ static int rotate_init(hb_filter_object_
     }
 
 #if HB_PROJECT_FEATURE_QSV && (defined( _WIN32 ) || defined( __MINGW32__ ))
-    if (hb_qsv_hw_filters_via_video_memory_are_enabled(init->job) || hb_qsv_hw_filters_via_system_memory_are_enabled(init->job))
+    if (hb_hwaccel_is_full_hardware_pipeline_enabled(init->job) &&
+        hb_qsv_decode_is_enabled(init->job))
     {
         qsv_rotate_init(pv, init, angle, flip);
         return 0;
diff -Naupr a/libhb/rpu.c b/libhb/rpu.c
--- a/libhb/rpu.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/rpu.c	2025-03-31 11:55:35.250884276 +0200
@@ -1,6 +1,6 @@
 /* rpu.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -18,6 +18,9 @@ struct hb_filter_private_s
 {
     int        mode;
 
+    int        angle;
+    int        hflip;
+
     double     scale_factor_x;
     double     scale_factor_y;
 
@@ -48,7 +51,9 @@ static int rpu_work(hb_filter_object_t *
 static void rpu_close(hb_filter_object_t *filter);
 
 static const char rpu_template[] =
-    "mode=^"HB_INT_REG"$:scale-factor-x=^"HB_FLOAT_REG"$:scale-factor-y=^"HB_FLOAT_REG"$:"
+    "mode=^"HB_INT_REG"$:"
+    "angle=^(0|90|180|270)$:hflip=^"HB_BOOL_REG"$:"
+    "scale-factor-x=^"HB_FLOAT_REG"$:scale-factor-y=^"HB_FLOAT_REG"$:"
     "crop-top=^"HB_INT_REG"$:crop-bottom=^"HB_INT_REG"$:"
     "crop-left=^"HB_INT_REG"$:crop-right=^"HB_INT_REG"$:"
     "pad-top=^"HB_INT_REG"$:pad-bottom=^"HB_INT_REG"$:"
@@ -81,6 +86,7 @@ static int rpu_init(hb_filter_object_t *
     pv->input = *init;
 
     int mode = RPU_MODE_UPDATE_ACTIVE_AREA | RPU_MODE_EMIT_UNSPECT_62_NAL;
+    int angle = 0, hflip = 0;
     double scale_factor_x = 1, scale_factor_y = 1;
     int crop_top = 0, crop_bottom = 0, crop_left = 0, crop_right = 0;
     int pad_top = 0, pad_bottom = 0, pad_left = 0, pad_right = 0;
@@ -90,6 +96,9 @@ static int rpu_init(hb_filter_object_t *
         hb_dict_t *dict = filter->settings;
         hb_dict_extract_int(&mode, dict, "mode");
 
+        hb_dict_extract_int(&angle, dict, "angle");
+        hb_dict_extract_int(&hflip, dict, "hflip");
+
         hb_dict_extract_double(&scale_factor_x, dict, "scale-factor-x");
         hb_dict_extract_double(&scale_factor_y, dict, "scale-factor-y");
 
@@ -106,6 +115,9 @@ static int rpu_init(hb_filter_object_t *
 
     pv->mode = mode;
 
+    pv->angle = angle;
+    pv->hflip = hflip;
+
     pv->scale_factor_x = scale_factor_x;
     pv->scale_factor_y = scale_factor_y;
 
@@ -244,9 +256,7 @@ static int rpu_work(hb_filter_object_t *
 
             if (pv->mode & RPU_MODE_UPDATE_ACTIVE_AREA)
             {
-                uint16_t left_offset = 0, right_offset = 0;
-                uint16_t top_offset  = 0, bottom_offset = 0;
-
+                hb_geometry_crop_t geo = {0};
                 const DoviVdrDmData *vdr_dm_data = dovi_rpu_get_vdr_dm_data(rpu_in);
 
                 if (vdr_dm_data)
@@ -254,36 +264,41 @@ static int rpu_work(hb_filter_object_t *
                     const DoviExtMetadataBlockLevel5 *level5 = vdr_dm_data->dm_data.level5;
                     if (level5)
                     {
-                        left_offset   = level5->active_area_left_offset;
-                        right_offset  = level5->active_area_right_offset;
-                        top_offset    = level5->active_area_top_offset;
-                        bottom_offset = level5->active_area_bottom_offset;
+                        geo.crop[0] = level5->active_area_top_offset;
+                        geo.crop[1] = level5->active_area_bottom_offset;
+                        geo.crop[2] = level5->active_area_left_offset;
+                        geo.crop[3] = level5->active_area_right_offset;
                     }
                 }
 
+                if (pv->angle || pv->hflip)
+                {
+                    hb_rotate_geometry(&geo, &geo, pv->angle, pv->hflip);
+                }
+
                 // First subtract the crop values
-                left_offset   -= left_offset   > pv->crop_left   ? pv->crop_left   : left_offset;
-                right_offset  -= right_offset  > pv->crop_right  ? pv->crop_right  : right_offset;
-                top_offset    -= top_offset    > pv->crop_top    ? pv->crop_top    : top_offset;
-                bottom_offset -= bottom_offset > pv->crop_bottom ? pv->crop_bottom : bottom_offset;
+                geo.crop[0] -= geo.crop[0] > pv->crop_top    ? pv->crop_top    : geo.crop[0];
+                geo.crop[1] -= geo.crop[1] > pv->crop_bottom ? pv->crop_bottom : geo.crop[1];
+                geo.crop[2] -= geo.crop[2] > pv->crop_left   ? pv->crop_left   : geo.crop[2];
+                geo.crop[3] -= geo.crop[3] > pv->crop_right  ? pv->crop_right  : geo.crop[3];
 
                 // Then rescale
-                left_offset   = (double)left_offset   / pv->scale_factor_x;
-                right_offset  = (double)right_offset  / pv->scale_factor_x;
-                top_offset    = (double)top_offset    / pv->scale_factor_y;
-                bottom_offset = (double)bottom_offset / pv->scale_factor_y;
+                geo.crop[0] = (double)geo.crop[0] / pv->scale_factor_y;
+                geo.crop[1] = (double)geo.crop[1] / pv->scale_factor_y;
+                geo.crop[2] = (double)geo.crop[2] / pv->scale_factor_x;
+                geo.crop[3] = (double)geo.crop[3] / pv->scale_factor_x;
 
                 // At last add pad values
-                left_offset   += pv->pad_left;
-                right_offset  += pv->pad_right;
-                top_offset    += pv->pad_top;
-                bottom_offset += pv->pad_bottom;
+                geo.crop[0] += pv->pad_top;
+                geo.crop[1] += pv->pad_bottom;
+                geo.crop[2] += pv->pad_left;
+                geo.crop[3] += pv->pad_right;
 
                 dovi_rpu_set_active_area_offsets(rpu_in,
-                                                 left_offset,
-                                                 right_offset,
-                                                 top_offset,
-                                                 bottom_offset);
+                                                 geo.crop[2],
+                                                 geo.crop[3],
+                                                 geo.crop[0],
+                                                 geo.crop[1]);
 
                 if (vdr_dm_data)
                 {
diff -Naupr a/libhb/scan.c b/libhb/scan.c
--- a/libhb/scan.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/scan.c	2025-03-31 11:55:35.250884276 +0200
@@ -1,6 +1,6 @@
 /* scan.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -341,21 +341,23 @@ static void ScanFunc( void * _data )
             j++;
         }
 
-        // VOBSUB and PGS width and height needs to be set to the
-        // title width and height for any stream type that does
-        // not provide this information (DVDs, BDs, VOBs, and M2TSs).
-        // Title width and height don't get set until we decode
-        // previews, so we can't set subtitle width/height till
-        // we get here.
         for (j = 0; j < hb_list_count(title->list_subtitle); j++)
         {
             hb_subtitle_t *subtitle = hb_list_item(title->list_subtitle, j);
             if ((subtitle->source == VOBSUB || subtitle->source == PGSSUB) &&
                 (subtitle->width <= 0 || subtitle->height <= 0))
             {
+                // VOBSUB and PGS width and height needs to be set to the
+                // title width and height for any stream type that does
+                // not provide this information (DVDs, BDs, VOBs, and M2TSs).
+                // Title width and height don't get set until we decode
+                // previews, so we can't set subtitle width/height till
+                // we get here.
                 subtitle->width  = title->geometry.width;
                 subtitle->height = title->geometry.height;
             }
+            // Initialize subtitle extradata if not set by demux already
+            hb_subtitle_extradata_init(subtitle);
         }
         i++;
     }
@@ -715,6 +717,11 @@ static int DecodePreviews( hb_scan_t * d
     {
         hw_decode = HB_DECODE_SUPPORT_VIDEOTOOLBOX;
     }
+    else if (data->hw_decode == HB_DECODE_SUPPORT_QSV &&
+             hb_hwaccel_available(title->video_codec_param, "qsv"))
+    {
+        hw_decode = HB_DECODE_SUPPORT_QSV;
+    }
     else if (data->hw_decode == HB_DECODE_SUPPORT_MF &&
              hb_hwaccel_available(title->video_codec_param, "d3d11va"))
     {
@@ -724,7 +731,7 @@ static int DecodePreviews( hb_scan_t * d
     void *hw_device_ctx = NULL;
     if (hw_decode)
     {
-        hb_hwaccel_hw_ctx_init(title->video_codec_param, hw_decode, &hw_device_ctx);
+        hb_hwaccel_hw_ctx_init(title->video_codec_param, hw_decode, &hw_device_ctx, NULL);
     }
 
     hb_work_object_t *vid_decoder = hb_get_work(data->h, title->video_codec);
diff -Naupr a/libhb/ssautil.c b/libhb/ssautil.c
--- a/libhb/ssautil.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/ssautil.c	2025-03-31 11:55:35.250884276 +0200
@@ -1,6 +1,6 @@
 /* ssautil.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -542,7 +542,7 @@ static int add_style(hb_subtitle_style_c
     value = field_value(style, field_indices->bold_index);
     if (value == NULL)
     {
-        flag = HB_STYLE_FLAG_BOLD;
+        flag = 0;
     }
     else
     {
@@ -553,7 +553,7 @@ static int add_style(hb_subtitle_style_c
     value = field_value(style, field_indices->italic_index);
     if (value == NULL)
     {
-        flag = HB_STYLE_FLAG_ITALIC;
+        flag = 0;
     }
     else
     {
@@ -564,7 +564,7 @@ static int add_style(hb_subtitle_style_c
     value = field_value(style, field_indices->underline_index);
     if (value == NULL)
     {
-        flag = HB_STYLE_FLAG_UNDERLINE;
+        flag = 0;
     }
     else
     {
@@ -577,9 +577,17 @@ static int add_style(hb_subtitle_style_c
     return 0;
 }
 
-hb_subtitle_style_context_t * hb_subtitle_style_init(const char * ssa_header)
+hb_subtitle_style_context_t * hb_subtitle_style_init(const uint8_t * ssa_buf, int size)
 {
     hb_subtitle_style_context_t * ctx;
+    char * ssa_header = malloc(size + 1);
+
+    if (ssa_header == NULL)
+    {
+        return NULL;
+    }
+    memcpy(ssa_header, ssa_buf, size);
+    ssa_header[size] = 0;
 
     ctx = calloc(1, sizeof(*ctx));
     if (ctx == NULL)
@@ -597,7 +605,6 @@ hb_subtitle_style_context_t * hb_subtitl
             if (pos != NULL)
             {
                 char ** fields;
-                int     next = 7;
                 char  * line = sgetline(pos + 8);
 
                 fields = get_fields(line, 0);
@@ -614,7 +621,7 @@ hb_subtitle_style_context_t * hb_subtitl
                     {
                         char ** style;
 
-                        line = sgetline(pos + next);
+                        line = sgetline(pos + 7);
                         style = get_fields(line, 0);
                         free(line);
 
@@ -623,10 +630,8 @@ hb_subtitle_style_context_t * hb_subtitl
                             hb_str_vfree(style);
                             break;
                         }
-                        pos = strchr(pos + next, '\n');
-                        next = 1;
-
                         hb_str_vfree(style);
+                        pos = strstr(pos + 7, "\nStyle:");
                     }
 
                     hb_str_vfree(fields);
@@ -635,6 +640,7 @@ hb_subtitle_style_context_t * hb_subtitl
         }
     }
     ssa_style_reset(ctx);
+    free(ssa_header);
     return ctx;
 }
 
@@ -703,11 +709,17 @@ static int tx3g_update_style_atoms(hb_tx
     style_entry = ctx->style_atoms.buf + pos;
 
     if (ctx->out_style.flags & HB_STYLE_FLAG_BOLD)
+    {
         face |= 1;
+    }
     if (ctx->out_style.flags & HB_STYLE_FLAG_ITALIC)
+    {
         face |= 2;
+    }
     if (ctx->out_style.flags & HB_STYLE_FLAG_UNDERLINE)
+    {
         face |= 4;
+    }
 
     style_entry[0]  = (ctx->style_start >> 8) & 0xff;   // startChar
     style_entry[1]  = ctx->style_start & 0xff;
@@ -762,7 +774,7 @@ static int tx3g_update_style(hb_tx3g_sty
 }
 
 hb_tx3g_style_context_t *
-hb_tx3g_style_init(int height, const char * ssa_header)
+hb_tx3g_style_init(int height, const uint8_t * ssa_buf, int size)
 {
     hb_tx3g_style_context_t * ctx;
 
@@ -771,7 +783,7 @@ hb_tx3g_style_init(int height, const cha
     {
         return NULL;
     }
-    ctx->in_style = hb_subtitle_style_init(ssa_header);
+    ctx->in_style = hb_subtitle_style_init(ssa_buf, size);
     ctx->height            = height;
     ctx->style_atoms.buf   = NULL;
     ctx->style_atoms.size  = 0;
diff -Naupr a/libhb/stream.c b/libhb/stream.c
--- a/libhb/stream.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/stream.c	2025-03-31 11:55:35.251884258 +0200
@@ -1,6 +1,6 @@
 /* stream.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -17,6 +17,7 @@
 #include "handbrake/lang.h"
 #include "handbrake/extradata.h"
 #include "libbluray/bluray.h"
+#include "libavutil/parseutils.h"
 
 #define min(a, b) a < b ? a : b
 #define HB_MAX_PROBE_SIZE (1*1024*1024)
@@ -5801,7 +5802,7 @@ static void add_ffmpeg_subtitle( hb_titl
             subtitle->format = TEXTSUB;
             subtitle->source = TX3GSUB;
             subtitle->config.dest = PASSTHRUSUB;
-            subtitle->codec = WORK_DECTX3GSUB;
+            subtitle->codec       = WORK_DECTX3GSUB;
             break;
         case AV_CODEC_ID_ASS:
             subtitle->format      = TEXTSUB;
@@ -5845,7 +5846,7 @@ static void add_ffmpeg_subtitle( hb_titl
     // Copy the extradata for the subtitle track
     if (codecpar->extradata != NULL)
     {
-        hb_set_text_extradata(&subtitle->extradata, codecpar->extradata, codecpar->extradata_size);
+        hb_set_extradata(&subtitle->extradata, codecpar->extradata, codecpar->extradata_size);
     }
 
     if (st->disposition & AV_DISPOSITION_DEFAULT)
@@ -5925,6 +5926,54 @@ static void add_ffmpeg_attachment( hb_ti
     hb_list_add(title->list_attachment, attachment);
 }
 
+static void add_ffmpeg_coverart(hb_title_t *title, hb_stream_t *stream, int id)
+{
+    int type = HB_ART_UNDEFINED;
+    AVStream *st = stream->ffmpeg_ic->streams[id];
+    AVCodecParameters *codecpar = st->codecpar;
+    char *name = get_ffmpeg_metadata_value(st->metadata, "filename");
+
+    switch (codecpar->codec_id)
+    {
+        case AV_CODEC_ID_PNG:
+            type = HB_ART_PNG;
+            name = name ? name : "cover.png";
+            break;
+        case AV_CODEC_ID_MJPEG:
+            type = HB_ART_JPEG;
+            name = name ? name : "cover.jpg";
+            break;
+        default:
+            break;
+    }
+
+    if (type != HB_ART_UNDEFINED)
+    {
+        hb_metadata_add_coverart(title->metadata,
+                                 st->attached_pic.data,
+                                 st->attached_pic.size,
+                                 type, name);
+    }
+}
+
+static void ffmpeg_decdate(const char *hb_key, const char *av_key,
+                          AVDictionary *m, hb_title_t *title)
+{
+    int64_t parsed_timestamp;
+    AVDictionaryEntry *tag = NULL;
+    if ((tag = av_dict_get(m, av_key, NULL, 0)) &&
+        av_parse_time(&parsed_timestamp, tag->value, 0) >= 0)
+    {
+        struct tm dt = {0};
+        if (av_small_strptime(tag->value, "%Y-%m-%dT%H:%M:%S", &dt))
+        {
+            char buf[64];
+            strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%S+0000", &dt);
+            hb_update_meta_dict(title->metadata->dict, hb_key, buf);
+        }
+    }
+}
+
 static int ffmpeg_decmetadata( AVDictionary *m, hb_title_t *title )
 {
     int result = 0;
@@ -5939,6 +5988,26 @@ static int ffmpeg_decmetadata( AVDiction
             hb_update_meta_dict(title->metadata->dict, hb_key, tag->value);
         }
     }
+
+    // Android creation time to release date
+    if (hb_dict_get(title->metadata->dict, "ReleaseDate") == NULL)
+    {
+        if (av_dict_get(m, "com.android.version", NULL, 0) ||
+            av_dict_get(m, "firmware", NULL, 0))
+        {
+            ffmpeg_decdate("ReleaseDate", "creation_time", m, title);
+        }
+    }
+
+    // MXF modification date to creation time
+    if (hb_dict_get(title->metadata->dict, "CreationTime") == NULL)
+    {
+        if (av_dict_get(m, "modification_date", NULL, 0))
+        {
+            ffmpeg_decdate("CreationTime", "modification_date", m, title);
+        }
+    }
+
     return result;
 }
 
@@ -6089,6 +6158,12 @@ static hb_title_t *ffmpeg_title_scan( hb
         {
             add_ffmpeg_attachment( title, stream, i );
         }
+        else if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO &&
+                 st->disposition & AV_DISPOSITION_ATTACHED_PIC &&
+                 (st->disposition & AV_DISPOSITION_TIMED_THUMBNAILS) == 0)
+        {
+            add_ffmpeg_coverart(title, stream, i);
+        }
     }
     find_ffmpeg_fallback_audio(title);
 
diff -Naupr a/libhb/sync.c b/libhb/sync.c
--- a/libhb/sync.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/sync.c	2025-03-31 11:55:35.252884241 +0200
@@ -1,6 +1,6 @@
 /* sync.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -407,13 +407,6 @@ static hb_buffer_t * CreateBlackBuf( syn
                 }
             }
 
-#if HB_PROJECT_FEATURE_QSV
-            if (hb_qsv_get_memory_type(stream->common->job) == MFX_IOPATTERN_OUT_VIDEO_MEMORY)
-            {
-                buf = hb_qsv_copy_video_buffer_to_hw_video_buffer(stream->common->job, buf, hb_qsv_hw_filters_via_video_memory_are_enabled(stream->common->job));
-            }
-            else
-#endif
             if (hb_hwaccel_is_full_hardware_pipeline_enabled(stream->common->job))
             {
                 buf = hb_hwaccel_copy_video_buffer_to_hw_video_buffer(stream->common->job, &buf);
@@ -421,13 +414,6 @@ static hb_buffer_t * CreateBlackBuf( syn
         }
         else
         {
-#if HB_PROJECT_FEATURE_QSV
-            if (hb_qsv_get_memory_type(stream->common->job) == MFX_IOPATTERN_OUT_VIDEO_MEMORY)
-            {
-                buf = hb_qsv_buffer_dup(stream->common->job, buf, hb_qsv_hw_filters_via_video_memory_are_enabled(stream->common->job));
-            }
-            else
-#endif
             {
                 buf = hb_buffer_dup(buf);
             }
@@ -2161,14 +2147,7 @@ static int InitAudio( sync_common_t * co
     w->private_data = pv;
     w->audio        = audio;
     w->fifo_in      = audio->priv.fifo_raw;
-    if (audio->config.out.codec & HB_ACODEC_PASS_FLAG)
-    {
-        w->fifo_out = audio->priv.fifo_out;
-    }
-    else
-    {
-        w->fifo_out = audio->priv.fifo_sync;
-    }
+    w->fifo_out     = audio->priv.fifo_sync;
 
     pv->common                  = common;
     pv->stream                  = &common->streams[1 + index];
@@ -2272,14 +2251,14 @@ static int InitSubtitle( sync_common_t *
     pv->stream->last_scr_sequence = -1;
     pv->stream->last_duration     = (int64_t)AV_NOPTS_VALUE;
     pv->stream->subtitle.subtitle = subtitle;
-    pv->stream->fifo_out          = subtitle->fifo_out;
+    pv->stream->fifo_out          = subtitle->fifo_sync;
     pv->stream->fifo_in           = subtitle->fifo_in;
 
     w = hb_get_work(common->job->h, WORK_SYNC_SUBTITLE);
     w->private_data = pv;
     w->subtitle     = subtitle;
     w->fifo_in      = subtitle->fifo_raw;
-    w->fifo_out     = subtitle->fifo_out;
+    w->fifo_out     = subtitle->fifo_sync;
 
     memset(&pv->stream->subtitle.sanitizer, 0,
            sizeof(pv->stream->subtitle.sanitizer));
diff -Naupr a/libhb/taskset.c b/libhb/taskset.c
--- a/libhb/taskset.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/taskset.c	2025-03-31 11:55:35.252884241 +0200
@@ -1,6 +1,6 @@
 /* taskset.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/templates/comb_detect_template.c b/libhb/templates/comb_detect_template.c
--- a/libhb/templates/comb_detect_template.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/templates/comb_detect_template.c	2025-03-31 11:55:35.252884241 +0200
@@ -1,6 +1,6 @@
 /* comb_detect_template.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/templates/decomb_template.c b/libhb/templates/decomb_template.c
--- a/libhb/templates/decomb_template.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/templates/decomb_template.c	2025-03-31 11:55:35.252884241 +0200
@@ -1,6 +1,6 @@
 /* decomb_template.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/templates/eedi2_template.c b/libhb/templates/eedi2_template.c
--- a/libhb/templates/eedi2_template.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/templates/eedi2_template.c	2025-03-31 11:55:35.252884241 +0200
@@ -1,6 +1,6 @@
 /* eedi2_template.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/templates/nlmeans_template.c b/libhb/templates/nlmeans_template.c
--- a/libhb/templates/nlmeans_template.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/templates/nlmeans_template.c	2025-03-31 11:55:35.252884241 +0200
@@ -1,6 +1,6 @@
 /* common.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/unsharp.c b/libhb/unsharp.c
--- a/libhb/unsharp.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/unsharp.c	2025-03-31 11:55:35.252884241 +0200
@@ -1,7 +1,7 @@
 /* unsharp.c
 
    Copyright (c) 2002 Rmi Guyomarch <rguyom at pobox.com>
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/vce_common.c b/libhb/vce_common.c
--- a/libhb/vce_common.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/vce_common.c	2025-03-31 11:55:35.252884241 +0200
@@ -1,6 +1,6 @@
 /* vce_common.c
  *
- * Copyright (c) 2003-2024 HandBrake Team
+ * Copyright (c) 2003-2025 HandBrake Team
  * This file is part of the HandBrake source code.
  * Homepage: <http://handbrake.fr/>.
  * It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/vfr.c b/libhb/vfr.c
--- a/libhb/vfr.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/vfr.c	2025-03-31 11:55:35.252884241 +0200
@@ -1,6 +1,6 @@
 /* vfr.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/libhb/work.c b/libhb/work.c
--- a/libhb/work.c	2025-02-20 19:37:15.000000000 +0100
+++ b/libhb/work.c	2025-03-31 11:55:35.253884224 +0200
@@ -1,6 +1,6 @@
 /* work.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -267,13 +267,22 @@ hb_work_object_t* hb_video_encoder(hb_ha
         case HB_VCODEC_X264_10BIT:
             w = hb_get_work(h, WORK_ENCX264);
             break;
-        case HB_VCODEC_QSV_H264:
-        case HB_VCODEC_QSV_H265:
-        case HB_VCODEC_QSV_H265_10BIT:
-        case HB_VCODEC_QSV_AV1:
-        case HB_VCODEC_QSV_AV1_10BIT:
-            w = hb_get_work(h, WORK_ENCQSV);
+#if HB_PROJECT_FEATURE_QSV
+        case HB_VCODEC_FFMPEG_QSV_H264:
+            w = hb_get_work(h, WORK_ENCAVCODEC);
+            w->codec_param = AV_CODEC_ID_H264;
+            break;
+        case HB_VCODEC_FFMPEG_QSV_H265:
+        case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+            w = hb_get_work(h, WORK_ENCAVCODEC);
+            w->codec_param = AV_CODEC_ID_HEVC;
             break;
+        case HB_VCODEC_FFMPEG_QSV_AV1:
+        case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
+            w = hb_get_work(h, WORK_ENCAVCODEC);
+            w->codec_param = AV_CODEC_ID_AV1;
+            break;
+#endif
         case HB_VCODEC_THEORA:
             w = hb_get_work(h, WORK_ENCTHEORA);
             break;
@@ -352,8 +361,35 @@ hb_work_object_t* hb_video_encoder(hb_ha
     return w;
 }
 
+hb_work_object_t* hb_subtitle_encoder(hb_handle_t *h, int codec)
+{
+    hb_work_object_t *w = NULL;
+
+    switch (codec)
+    {
+        case HB_SCODEC_PASS:
+            w = hb_get_work(h, WORK_PASS);
+            break;
+        case HB_SCODEC_TX3G:
+            w = hb_get_work(h, WORK_ENCTX3GSUB);
+            break;
+        case HB_SCODEC_SRT:
+            w = hb_get_work(h, WORK_ENCAVSUB);
+            w->codec_param = AV_CODEC_ID_SUBRIP;
+            break;
+        default:
+            break;
+    }
+
+    return w;
+}
+
 hb_work_object_t* hb_audio_encoder(hb_handle_t *h, int codec)
 {
+    if (codec & HB_ACODEC_PASS_FLAG)
+    {
+        return hb_get_work(h, WORK_PASS);
+    }
     switch (codec)
     {
         case HB_ACODEC_LAME:    return hb_get_work(h, WORK_ENCAVCODEC_AUDIO);
@@ -584,11 +620,11 @@ void hb_display_job_info(hb_job_t *job)
                 case HB_VCODEC_X265_10BIT:
                 case HB_VCODEC_X265_12BIT:
                 case HB_VCODEC_X265_16BIT:
-                case HB_VCODEC_QSV_H264:
-                case HB_VCODEC_QSV_H265:
-                case HB_VCODEC_QSV_H265_10BIT:
-                case HB_VCODEC_QSV_AV1:
-                case HB_VCODEC_QSV_AV1_10BIT:
+                case HB_VCODEC_FFMPEG_QSV_H264:
+                case HB_VCODEC_FFMPEG_QSV_H265:
+                case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+                case HB_VCODEC_FFMPEG_QSV_AV1:
+                case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
                 case HB_VCODEC_FFMPEG_VCE_H264:
                 case HB_VCODEC_FFMPEG_VCE_H265:
                 case HB_VCODEC_FFMPEG_VCE_H265_10BIT:
@@ -620,11 +656,11 @@ void hb_display_job_info(hb_job_t *job)
                 case HB_VCODEC_X265_8BIT:
                 case HB_VCODEC_X265_10BIT:
                 case HB_VCODEC_X265_12BIT:
-                case HB_VCODEC_QSV_H264:
-                case HB_VCODEC_QSV_H265:
-                case HB_VCODEC_QSV_H265_10BIT:
-                case HB_VCODEC_QSV_AV1:
-                case HB_VCODEC_QSV_AV1_10BIT:
+                case HB_VCODEC_FFMPEG_QSV_H264:
+                case HB_VCODEC_FFMPEG_QSV_H265:
+                case HB_VCODEC_FFMPEG_QSV_H265_10BIT:
+                case HB_VCODEC_FFMPEG_QSV_AV1:
+                case HB_VCODEC_FFMPEG_QSV_AV1_10BIT:
                 case HB_VCODEC_FFMPEG_VCE_H264:
                 case HB_VCODEC_FFMPEG_VCE_H265:
                 case HB_VCODEC_FFMPEG_VCE_H265_10BIT:
@@ -699,7 +735,7 @@ void hb_display_job_info(hb_job_t *job)
             }
         }
 
-        if (job->passthru_dynamic_hdr_metadata & DOVI)
+        if (job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_DOVI)
         {
             hb_log("     + dolby vision configuration record: version: %d.%d, profile: %d, level: %d, rpu flag: %d, el flag: %d, bl flag: %d, compatibility id: %d",
                    job->dovi.dv_version_major,
@@ -712,7 +748,7 @@ void hb_display_job_info(hb_job_t *job)
                    job->dovi.dv_bl_signal_compatibility_id);
         }
 
-        if (job->passthru_dynamic_hdr_metadata & HDR_10_PLUS)
+        if (job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_HDR10PLUS)
         {
             hb_log("     + hdr10+ dynamic metadata");
 
@@ -1084,9 +1120,7 @@ static int sanitize_subtitles( hb_job_t
                 one_burned = 1;
             }
         }
-
-        if (subtitle->config.dest == PASSTHRUSUB &&
-            !hb_subtitle_can_pass(subtitle->source, job->mux))
+        else if (hb_subtitle_must_burn(subtitle, job->mux))
         {
             if (!one_burned)
             {
@@ -1103,6 +1137,20 @@ static int sanitize_subtitles( hb_job_t
                 continue;
             }
         }
+        else if (subtitle->format        == TEXTSUB &&
+                 subtitle->config.codec  == HB_SCODEC_PASS)
+        {
+            if (job->mux == HB_MUX_AV_MP4)
+            {
+                subtitle->config.codec = HB_SCODEC_TX3G;
+            }
+            else if (subtitle->source == UTF8SUB ||
+                     subtitle->source == SRTSUB  ||
+                     subtitle->source == TX3GSUB)
+            {
+                subtitle->config.codec = HB_SCODEC_SRT;
+            }
+        }
         /* Adjust output track number, in case we removed one.
          * Output tracks sadly still need to be in sequential order.
          * Note: out.track starts at 1, i starts at 0 */
@@ -1541,29 +1589,26 @@ static void sanitize_dynamic_hdr_metadat
 {
     hb_list_t *list = job->list_filter;
 
-    if (hb_filter_find(list, HB_FILTER_ROTATE)     != NULL ||
-        hb_filter_find(list, HB_FILTER_COLORSPACE) != NULL)
+    if (hb_filter_find(list, HB_FILTER_COLORSPACE) != NULL)
     {
-        job->passthru_dynamic_hdr_metadata = NONE;
+        job->passthru_dynamic_hdr_metadata = HB_HDR_DYNAMIC_METADATA_NONE;
         return;
     }
 
-    if (job->vcodec != HB_VCODEC_X265_10BIT    &&
-        job->vcodec != HB_VCODEC_VT_H265_10BIT &&
-        job->vcodec != HB_VCODEC_SVT_AV1_10BIT)
-    {
-        job->passthru_dynamic_hdr_metadata &= ~HDR_10_PLUS;
-    }
-
-    if ((job->dovi.dv_profile != 5 &&
-         job->dovi.dv_profile != 7 &&
-         job->dovi.dv_profile != 8 &&
-         job->dovi.dv_profile != 10) ||
-        (job->vcodec != HB_VCODEC_X265_10BIT &&
-         job->vcodec != HB_VCODEC_VT_H265_10BIT &&
-         job->vcodec != HB_VCODEC_SVT_AV1_10BIT))
+    if (job->title->hdr_10_plus == 0 ||
+        hb_video_hdr_dynamic_metadata_is_supported(job->vcodec,
+                                                   HB_HDR_DYNAMIC_METADATA_HDR10PLUS,
+                                                   0) == 0)
     {
-        job->passthru_dynamic_hdr_metadata &= ~DOVI;
+        job->passthru_dynamic_hdr_metadata &= ~HB_HDR_DYNAMIC_METADATA_HDR10PLUS;
+    }
+
+    if (job->title->dovi.dv_profile == 0 ||
+        hb_video_hdr_dynamic_metadata_is_supported(job->vcodec,
+                                                   HB_HDR_DYNAMIC_METADATA_DOVI,
+                                                   job->dovi.dv_profile) == 0)
+    {
+        job->passthru_dynamic_hdr_metadata &= ~HB_HDR_DYNAMIC_METADATA_DOVI;
     }
 
     if ((job->dovi.dv_profile == 8 || job->dovi.dv_profile == 10) &&
@@ -1572,11 +1617,11 @@ static void sanitize_dynamic_hdr_metadat
         if (job->mastering.has_primaries == 0 && job->mastering.has_luminance == 0)
         {
             hb_log("work: missing mastering metadata, disabling Dolby Vision");
-            job->passthru_dynamic_hdr_metadata &= ~DOVI;
+            job->passthru_dynamic_hdr_metadata &= ~HB_HDR_DYNAMIC_METADATA_DOVI;
         }
     }
 
-    if (job->passthru_dynamic_hdr_metadata & DOVI)
+    if (job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_DOVI)
     {
 #if HB_PROJECT_FEATURE_LIBDOVI
         int mode = 0;
@@ -1614,16 +1659,36 @@ static void sanitize_dynamic_hdr_metadat
             }
         }
 
+        int angle = 0, hflip = 0;
         double scale_factor_x = 1, scale_factor_y = 1;
         int crop_top = 0, crop_bottom = 0, crop_left = 0, crop_right = 0;
         int pad_top = 0, pad_bottom = 0, pad_left = 0, pad_right = 0;
 
-        hb_filter_object_t *filter = hb_filter_find(list, HB_FILTER_CROP_SCALE);
+        hb_filter_object_t *filter = hb_filter_find(list, HB_FILTER_ROTATE);
+        if (filter != NULL)
+        {
+            hb_dict_t *settings = filter->settings;
+            if (settings != NULL)
+            {
+                angle = hb_dict_get_int(settings, "angle");
+                hflip = hb_dict_get_int(settings, "hflip");
+            }
+        }
+
+        filter = hb_filter_find(list, HB_FILTER_CROP_SCALE);
         if (filter != NULL)
         {
             hb_dict_t *settings = filter->settings;
             if (settings != NULL)
             {
+                hb_geometry_crop_t title_geo = {0};
+                title_geo.geometry = job->title->geometry;
+
+                if (angle || hflip)
+                {
+                    hb_rotate_geometry(&title_geo, &title_geo, angle, hflip);
+                }
+
                 int width  = hb_dict_get_int(settings, "width");
                 int height = hb_dict_get_int(settings, "height");
                 crop_top    = hb_dict_get_int(settings, "crop-top");
@@ -1631,8 +1696,8 @@ static void sanitize_dynamic_hdr_metadat
                 crop_left   = hb_dict_get_int(settings, "crop-left");
                 crop_right  = hb_dict_get_int(settings, "crop-right");
 
-                scale_factor_x = (float)(job->title->geometry.width - crop_right - crop_left) / width;
-                scale_factor_y = (float)(job->title->geometry.height - crop_top - crop_bottom) / height;
+                scale_factor_x = (float)(title_geo.geometry.width - crop_right - crop_left) / width;
+                scale_factor_y = (float)(title_geo.geometry.height - crop_top - crop_bottom) / height;
             }
         }
 
@@ -1650,17 +1715,19 @@ static void sanitize_dynamic_hdr_metadat
         }
 
         filter = hb_filter_init(HB_FILTER_RPU);
-        char *settings = hb_strdup_printf("mode=%d:scale-factor-x=%f:scale-factor-y=%f:"
+        char *settings = hb_strdup_printf("mode=%d:angle=%d:hflip=%d:"
+                                          "scale-factor-x=%f:scale-factor-y=%f:"
                                           "crop-top=%d:crop-bottom=%d:crop-left=%d:crop-right=%d:"
                                           "pad-top=%d:pad-bottom=%d:pad-left=%d:pad-right=%d",
-                                          mode, scale_factor_x, scale_factor_y,
+                                          mode, angle, hflip,
+                                          scale_factor_x, scale_factor_y,
                                           crop_top, crop_bottom, crop_left, crop_right,
                                           pad_top, pad_bottom, pad_left, pad_right);
         hb_add_filter(job, filter, settings);
         free(settings);
 #else
         hb_log("work: libdovi not available, disabling Dolby Vision");
-        job->passthru_dynamic_hdr_metadata &= ~DOVI;
+        job->passthru_dynamic_hdr_metadata &= ~HB_HDR_DYNAMIC_METADATA_DOVI;
 #endif
     }
 }
@@ -1750,7 +1817,8 @@ static void do_job(hb_job_t *job)
         {
             hb_hwaccel_hw_ctx_init(job->title->video_codec_param,
                                    job->hw_decode,
-                                   &job->hw_device_ctx);
+                                   &job->hw_device_ctx,
+                                   job);
         }
 
         sanitize_dynamic_hdr_metadata_passthru(job);
@@ -1768,7 +1836,7 @@ static void do_job(hb_job_t *job)
         init.color_matrix = title->color_matrix;
         // Dolby Vision profile 5 requires full range
         // TODO: find a better way to handle this
-        init.color_range = job->passthru_dynamic_hdr_metadata & DOVI &&
+        init.color_range = job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_DOVI &&
                             (job->dovi.dv_profile == 5 ||
                              (job->dovi.dv_profile == 10 && job->dovi.dv_bl_signal_compatibility_id == 0)) ?
                             title->color_range : AVCOL_RANGE_MPEG;
@@ -1862,21 +1930,21 @@ static void do_job(hb_job_t *job)
     hb_reduce(&job->vrate.num, &job->vrate.den,
                job->vrate.num,  job->vrate.den);
 
-    if (job->passthru_dynamic_hdr_metadata & DOVI)
+    if (job->passthru_dynamic_hdr_metadata & HB_HDR_DYNAMIC_METADATA_DOVI)
     {
         // Dolby Vision level needs to be updated now that
         // the final width, height and frame rate is known
         update_dolby_vision_level(job);
     }
 
-    job->fifo_mpeg2  = hb_fifo_init( FIFO_SMALL, FIFO_SMALL_WAKE );
+    job->fifo_in     = hb_fifo_init( FIFO_SMALL, FIFO_SMALL_WAKE );
     job->fifo_raw    = hb_fifo_init( FIFO_SMALL, FIFO_SMALL_WAKE );
     if (!job->indepth_scan)
     {
         // When doing subtitle indepth scan, the pipeline ends at sync
         job->fifo_sync   = hb_fifo_init( FIFO_SMALL, FIFO_SMALL_WAKE );
         job->fifo_render = NULL; // Attached to filter chain
-        job->fifo_mpeg4  = hb_fifo_init( FIFO_LARGE, FIFO_LARGE_WAKE );
+        job->fifo_out    = hb_fifo_init( FIFO_LARGE, FIFO_LARGE_WAKE );
     }
 
     result = sanitize_audio(job);
@@ -1921,7 +1989,7 @@ static void do_job(hb_job_t *job)
         }
     }
 
-    // Subtitle fifos must be initialized before sync
+    // Subtitle decoder and sync fifos must be initialized before sync
     for (i = 0; i < hb_list_count( job->list_subtitle ); i++)
     {
         subtitle = hb_list_item( job->list_subtitle, i );
@@ -1950,7 +2018,8 @@ static void do_job(hb_job_t *job)
         if (!job->indepth_scan)
         {
             // When doing subtitle indepth scan, the pipeline ends at sync
-            subtitle->fifo_out = hb_fifo_init( FIFO_UNBOUNDED, FIFO_UNBOUNDED_WAKE );
+            subtitle->fifo_sync = hb_fifo_init( FIFO_UNBOUNDED, FIFO_SMALL_WAKE );
+            subtitle->fifo_out  = hb_fifo_init( FIFO_UNBOUNDED, FIFO_SMALL_WAKE);
         }
 
         w->fifo_in = subtitle->fifo_in;
@@ -1967,7 +2036,7 @@ static void do_job(hb_job_t *job)
         *job->die = 1;
         goto cleanup;
     }
-    w->fifo_in  = job->fifo_mpeg2;
+    w->fifo_in  = job->fifo_in;
     w->fifo_out = job->fifo_raw;
     hb_list_add(job->list_work, w);
 
@@ -1984,28 +2053,45 @@ static void do_job(hb_job_t *job)
             /*
             * Audio Encoder Thread
             */
-            if ( !(audio->config.out.codec & HB_ACODEC_PASS_FLAG ) )
+            w = hb_audio_encoder( job->h, audio->config.out.codec);
+            if (w == NULL)
             {
-                /*
-                * Add the encoder thread if not doing passthru
-                */
-                w = hb_audio_encoder( job->h, audio->config.out.codec);
-                if (w == NULL)
-                {
-                    hb_error("Invalid audio codec: %#x", audio->config.out.codec);
-                    w = NULL;
-                    *job->done_error = HB_ERROR_WRONG_INPUT;
-                    *job->die = 1;
-                    goto cleanup;
-                }
-                w->init_delay = &audio->priv.init_delay;
-                w->extradata  = &audio->priv.extradata;
-                w->fifo_in  = audio->priv.fifo_sync;
-                w->fifo_out = audio->priv.fifo_out;
-                w->audio    = audio;
+                hb_error("Invalid audio codec: %#x", audio->config.out.codec);
+                w = NULL;
+                *job->done_error = HB_ERROR_WRONG_INPUT;
+                *job->die = 1;
+                goto cleanup;
+            }
+            w->init_delay = &audio->priv.init_delay;
+            w->fifo_in    = audio->priv.fifo_sync;
+            w->fifo_out   = audio->priv.fifo_out;
+            w->extradata  = &audio->priv.extradata;
+            w->audio      = audio;
 
-                hb_list_add( job->list_work, w );
+            hb_list_add( job->list_work, w );
+        }
+
+        for( i = 0; i < hb_list_count( job->list_subtitle ); i++ )
+        {
+            subtitle = hb_list_item(job->list_subtitle, i);
+
+            /*
+            * Subtitle Encoder Thread
+            */
+            w = hb_subtitle_encoder( job->h, subtitle->config.codec);
+            if (w == NULL)
+            {
+                hb_error("Invalid subtitle codec: %#x", subtitle->config.codec);
+                w = NULL;
+                *job->done_error = HB_ERROR_WRONG_INPUT;
+                *job->die = 1;
+                goto cleanup;
             }
+            w->fifo_in  = subtitle->fifo_sync;
+            w->fifo_out = subtitle->fifo_out;
+            w->subtitle = subtitle;
+
+            hb_list_add( job->list_work, w );
         }
 
         /* Set up the video filter fifo pipeline */
@@ -2046,13 +2132,12 @@ static void do_job(hb_job_t *job)
         else
             w->fifo_in  = job->fifo_sync;
 
-        w->fifo_out  =  job->fifo_mpeg4;
+        w->fifo_out  =  job->fifo_out;
 
         w->init_delay = &job->init_delay;
         w->extradata  = &job->extradata;
 
         hb_list_add( job->list_work, w );
-
     }
 
     // Add Muxer work object
@@ -2163,10 +2248,10 @@ cleanup:
     hb_list_close( &job->list_work );
 
     /* Close fifos */
-    hb_fifo_close( &job->fifo_mpeg2 );
+    hb_fifo_close( &job->fifo_in );
     hb_fifo_close( &job->fifo_raw );
     hb_fifo_close( &job->fifo_sync );
-    hb_fifo_close( &job->fifo_mpeg4 );
+    hb_fifo_close( &job->fifo_out );
 
     for (i = 0; i < hb_list_count( job->list_subtitle ); i++)
     {
@@ -2175,6 +2260,7 @@ cleanup:
         {
             hb_fifo_close( &subtitle->fifo_in );
             hb_fifo_close( &subtitle->fifo_raw );
+            hb_fifo_close( &subtitle->fifo_sync );
             hb_fifo_close( &subtitle->fifo_out );
         }
     }
@@ -2210,15 +2296,6 @@ cleanup:
 
     hb_buffer_pool_free();
     hb_hwaccel_hw_ctx_close(&job->hw_device_ctx);
-
-#if HB_PROJECT_FEATURE_QSV
-    if (!job->indepth_scan &&
-        (job->pass_id != HB_PASS_ENCODE_ANALYSIS) &&
-        hb_qsv_is_enabled(job))
-    {
-        hb_qsv_context_uninit(job);
-    }
-#endif
 }
 
 static inline void copy_chapter( hb_buffer_t * dst, hb_buffer_t * src )
diff -Naupr a/libhb/workpass.c b/libhb/workpass.c
--- a/libhb/workpass.c	1970-01-01 01:00:00.000000000 +0100
+++ b/libhb/workpass.c	2025-03-31 11:55:35.253884224 +0200
@@ -0,0 +1,111 @@
+/* worknull.c
+
+   Copyright (c) 2003-2025 HandBrake Team
+   This file is part of the HandBrake source code
+   Homepage: <http://handbrake.fr/>.
+   It may be used under the terms of the GNU General Public License v2.
+   For full terms see the file COPYING file or visit http://www.gnu.org/licenses/gpl-2.0.html
+ */
+
+/* Does no work ;) but also serves as a example template */
+
+#include "handbrake/handbrake.h"
+
+struct hb_work_private_s
+{
+};
+
+/***********************************************************************
+ * Init
+ ***********************************************************************
+ * Initialize hb_work_private_t data
+ **********************************************************************/
+static int Init( hb_work_object_t * w, hb_job_t * job )
+{
+    w->private_data = NULL;
+
+    return 0;
+}
+
+/***********************************************************************
+ * Close
+ ***********************************************************************
+ * Free any allocation in hb_work_private_t
+ **********************************************************************/
+static void Close( hb_work_object_t * w )
+{
+    w->private_data = NULL;
+}
+
+/***********************************************************************
+ * Work
+ ***********************************************************************
+ * Take an input buffer, send an output buffer
+ **********************************************************************/
+static int Work( hb_work_object_t * w, hb_buffer_t ** buf_in,
+                 hb_buffer_t ** buf_out )
+{
+    hb_buffer_t * in = *buf_in;
+
+    // Pass input to output
+    *buf_out = *buf_in;
+    // Mark input buffer NULL so work loop doesn't delete it
+    *buf_in = NULL;
+
+    if (in->s.flags & HB_BUF_FLAG_EOF)
+    {
+        /* EOF on input stream - say that we're done */
+        return HB_WORK_DONE;
+    }
+    return HB_WORK_OK;
+}
+
+/***********************************************************************
+ * Info
+ ***********************************************************************
+ * Retrieve current info about context initialized during Init
+ **********************************************************************/
+static int Info( hb_work_object_t *w, hb_work_info_t *info )
+{
+    memset(info, 0, sizeof(*info));
+
+    // Indicate no info is returned
+    return 0;
+}
+
+/***********************************************************************
+ * BSInfo
+ ***********************************************************************
+ * Retrieve info, does not require Init(), but uses current context
+ * if Init has already been called.
+ * buf contains stream data to extract info from.
+ **********************************************************************/
+static int BSInfo( hb_work_object_t *w, const hb_buffer_t *buf,
+                   hb_work_info_t *info )
+{
+    memset( info, 0, sizeof(*info) );
+
+    // Indicate no info is returned
+    return 0;
+}
+
+/***********************************************************************
+ * Flush
+ ***********************************************************************
+ * Reset context without closing, kind of poorly named :(
+ **********************************************************************/
+static void Flush( hb_work_object_t *w )
+{
+}
+
+hb_work_object_t hb_workpass =
+{
+    .id     = WORK_PASS,
+    .name   = "Passthrough",
+    .init   = Init,
+    .work   = Work,
+    .close  = Close,
+    .info   = Info,
+    .bsinfo = BSInfo,
+    .flush  = Flush,
+};
diff -Naupr a/make/include/main.defs b/make/include/main.defs
--- a/make/include/main.defs	2025-02-20 19:37:15.000000000 +0100
+++ b/make/include/main.defs	2025-03-31 11:55:35.296883479 +0200
@@ -49,6 +49,7 @@ ifeq (1,$(FEATURE.x265))
 endif
 
 MODULES += contrib/libdav1d
+MODULES += contrib/cpuinfo
 MODULES += contrib/svt-av1
 MODULES += contrib/zimg
 MODULES += contrib/ffmpeg
diff -Naupr a/make/variant/mingw.defs b/make/variant/mingw.defs
--- a/make/variant/mingw.defs	2025-02-20 19:37:15.000000000 +0100
+++ b/make/variant/mingw.defs	2025-03-31 11:55:35.296883479 +0200
@@ -9,4 +9,14 @@ GCC.args.g.min  = -g1
 GCC.args.g.std  = -g2
 GCC.args.g.max  = -g3
 
-GCC.args.extra += -mno-ms-bitfields
\ Manca newline alla fine del file
+GCC.args.extra += -mno-ms-bitfields
+
+ifeq ($(HOST.machine),$(filter $(HOST.machine),aarch64))
+    ifneq (none,$(GCC.g))
+        GCC.args.g.max        += -gcodeview
+        GCC.args.g.min        += -gcodeview
+        GCC.args.g.std        += -gcodeview
+        GCC.args.extra.exe++  += -Wl-debug -Wl,--pdb=
+        GCC.args.extra.exe    += -Wl-debug -Wl,--pdb=
+    endif
+endif
diff -Naupr a/pkg/linux/flatpak/fr.handbrake.ghb.json b/pkg/linux/flatpak/fr.handbrake.ghb.json
--- a/pkg/linux/flatpak/fr.handbrake.ghb.json	2025-02-20 19:37:15.000000000 +0100
+++ b/pkg/linux/flatpak/fr.handbrake.ghb.json	2025-03-31 11:55:35.297883462 +0200
@@ -13,6 +13,7 @@
         "--filesystem=xdg-run/gvfs",
         "--filesystem=xdg-run/gvfsd",
         "--talk-name=org.gtk.vfs.*",
+        "--talk-name=org.freedesktop.Flatpak",
         "--system-talk-name=org.freedesktop.login1",
         "--system-talk-name=org.freedesktop.UPower",
         "--env=PATH=/app/bin:/app/extensions/bin:/usr/bin",
diff -Naupr a/preset/preset_builtin.json b/preset/preset_builtin.json
--- a/preset/preset_builtin.json	2025-02-20 19:37:15.000000000 +0100
+++ b/preset/preset_builtin.json	2025-03-31 11:55:35.298883445 +0200
@@ -98,16 +98,17 @@
                     "VideoFramerateMode": "pfr",
                     "VideoGrayScale": false,
                     "VideoScaler": "swscale",
-                    "VideoPreset": "9",
-                    "VideoTune": "",
+                    "VideoPreset": "8",
+                    "VideoTune": "vq",
                     "VideoProfile": "main",
                     "VideoLevel": "auto",
-                    "VideoOptionExtra": "",
+                    "VideoOptionExtra": "enable-variance-boost=1",
                     "VideoQualityType": 2,
                     "VideoQualitySlider": 35.0,
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -218,6 +219,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -327,6 +329,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -436,6 +439,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -545,6 +549,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -654,6 +659,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -754,16 +760,17 @@
                     "VideoFramerateMode": "pfr",
                     "VideoGrayScale": false,
                     "VideoScaler": "swscale",
-                    "VideoPreset": "8",
-                    "VideoTune": "",
+                    "VideoPreset": "7",
+                    "VideoTune": "vq",
                     "VideoProfile": "main",
                     "VideoLevel": "auto",
-                    "VideoOptionExtra": "",
+                    "VideoOptionExtra": "enable-variance-boost=1",
                     "VideoQualityType": 2,
                     "VideoQualitySlider": 30.0,
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -874,6 +881,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -983,6 +991,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -1092,6 +1101,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -1201,6 +1211,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -1310,6 +1321,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -1423,16 +1435,17 @@
                     "VideoFramerateMode": "pfr",
                     "VideoGrayScale": false,
                     "VideoScaler": "swscale",
-                    "VideoPreset": "7",
-                    "VideoTune": "",
+                    "VideoPreset": "6",
+                    "VideoTune": "vq",
                     "VideoProfile": "main",
                     "VideoLevel": "auto",
-                    "VideoOptionExtra": "",
+                    "VideoOptionExtra": "enable-variance-boost=1",
                     "VideoQualityType": 2,
                     "VideoQualitySlider": 25.0,
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -1556,6 +1569,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -1679,6 +1693,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -1802,6 +1817,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -1925,6 +1941,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -2048,6 +2065,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -2162,16 +2180,17 @@
                     "VideoFramerateMode": "pfr",
                     "VideoGrayScale": false,
                     "VideoScaler": "swscale",
-                    "VideoPreset": "5",
-                    "VideoTune": "",
+                    "VideoPreset": "4",
+                    "VideoTune": "vq",
                     "VideoProfile": "main",
                     "VideoLevel": "auto",
-                    "VideoOptionExtra": "",
+                    "VideoOptionExtra": "enable-variance-boost=1",
                     "VideoQualityType": 2,
                     "VideoQualitySlider": 20.0,
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -2296,6 +2315,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -2419,6 +2439,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -2542,6 +2563,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -2665,6 +2687,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -2788,6 +2811,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 }
@@ -2904,6 +2928,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -3013,6 +3038,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -3122,6 +3148,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -3231,6 +3258,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -3340,6 +3368,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -3449,6 +3478,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -3558,6 +3588,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -3667,6 +3698,337 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
+                    "x264Option": "",
+                    "x264UseAdvancedOptions": false
+                },
+                {
+                    "AlignAVStart": true,
+                    "AudioCopyMask": [
+                        "copy:aac"
+                    ],
+                    "AudioEncoderFallback": "aac",
+                    "AudioLanguageList": [
+                    ],
+                    "AudioList": [
+                        {
+                            "AudioBitrate": 160,
+                            "AudioCompressionLevel": -1.0,
+                            "AudioDitherMethod": "auto",
+                            "AudioEncoder": "aac",
+                            "AudioMixdown": "stereo",
+                            "AudioNormalizeMixLevel": false,
+                            "AudioSamplerate": "auto",
+                            "AudioTrackQualityEnable": false,
+                            "AudioTrackQuality": -1.0,
+                            "AudioTrackGainSlider": 0.0,
+                            "AudioTrackDRCSlider": 0.0
+                        }
+                    ],
+                    "AudioSecondaryEncoderMode": true,
+                    "AudioTrackSelectionBehavior": "first",
+                    "ChapterMarkers": true,
+                    "ChildrenArray": [
+                    ],
+                    "Default": false,
+                    "FileFormat": "mp4",
+                    "Folder": false,
+                    "FolderOpen": false,
+                    "InlineParameterSets": false,
+                    "Optimize": true,
+                    "Mp4iPodCompatible": false,
+                    "PictureCropMode": 0,
+                    "PictureBottomCrop": 0,
+                    "PictureLeftCrop": 0,
+                    "PictureRightCrop": 0,
+                    "PictureTopCrop": 0,
+                    "PictureDARWidth": 0,
+                    "PictureDeblockPreset": "off",
+                    "PictureDeblockTune": "medium",
+                    "PictureDeblockCustom": "strength=strong:thresh=20:blocksize=8",
+                    "PictureCombDetectCustom": "",
+                    "PictureCombDetectPreset": "off",
+                    "PictureDeinterlaceCustom": "",
+                    "PictureDeinterlaceFilter": "off",
+                    "PictureDeinterlacePreset": "default",
+                    "PictureDenoiseCustom": "",
+                    "PictureDenoiseFilter": "off",
+                    "PictureDenoisePreset": "medium",
+                    "PictureDenoiseTune": "none",
+                    "PictureChromaSmoothCustom": "",
+                    "PictureChromaSmoothPreset": "off",
+                    "PictureChromaSmoothTune": "none",
+                    "PictureColorspaceCustom": "",
+                    "PictureColorspacePreset": "off",
+                    "PictureSharpenCustom": "",
+                    "PictureSharpenFilter": "off",
+                    "PictureSharpenPreset": "medium",
+                    "PictureSharpenTune": "none",
+                    "PictureDetelecine": "off",
+                    "PictureDetelecineCustom": "",
+                    "PictureItuPAR": false,
+                    "PictureKeepRatio": true,
+                    "PictureModulus": 2,
+                    "PicturePAR": "auto",
+                    "PicturePARWidth": 853,
+                    "PicturePARHeight": 720,
+                    "PictureRotate": "angle=0:hflip=0",
+                    "PictureWidth": 1280,
+                    "PictureHeight": 720,
+                    "PictureForceHeight": 0,
+                    "PictureForceWidth": 0,
+                    "PresetDescription": "Up to 30 seconds of video in 10 MB or less, for sharing via online social communities such as Discord and email services such as Gmail. H.264 video (up to 720p60) and AAC stereo audio, in an MP4 container.",
+                    "PresetName": "Social 10 MB 30 Seconds 720p60",
+                    "Type": 0,
+                    "UsesPictureFilters": true,
+                    "UsesPictureSettings": 1,
+                    "SubtitleAddCC": false,
+                    "SubtitleAddForeignAudioSearch": true,
+                    "SubtitleAddForeignAudioSubtitle": false,
+                    "SubtitleBurnBehavior": "foreign",
+                    "SubtitleBurnBDSub": true,
+                    "SubtitleBurnDVDSub": true,
+                    "SubtitleLanguageList": [
+                    ],
+                    "SubtitleTrackSelectionBehavior": "none",
+                    "VideoAvgBitrate": 2250,
+                    "VideoColorMatrixCodeOverride": 0,
+                    "VideoEncoder": "x264",
+                    "VideoFramerate": "60",
+                    "VideoFramerateMode": "pfr",
+                    "VideoGrayScale": false,
+                    "VideoScaler": "swscale",
+                    "VideoPreset": "slow",
+                    "VideoTune": "",
+                    "VideoProfile": "high",
+                    "VideoLevel": "3.2",
+                    "VideoOptionExtra": "qcomp=0.5:aq-mode=2:aq-strength=0.8:bframes=2:b-adapt=2:b-pyramid=0",
+                    "VideoQualityType": 1,
+                    "VideoQualitySlider": 27.0,
+                    "VideoQSVDecode": false,
+                    "VideoMultiPass": true,
+                    "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
+                    "x264Option": "",
+                    "x264UseAdvancedOptions": false
+                },
+                {
+                    "AlignAVStart": true,
+                    "AudioCopyMask": [
+                        "copy:aac"
+                    ],
+                    "AudioEncoderFallback": "aac",
+                    "AudioLanguageList": [
+                    ],
+                    "AudioList": [
+                        {
+                            "AudioBitrate": 160,
+                            "AudioCompressionLevel": -1.0,
+                            "AudioDitherMethod": "auto",
+                            "AudioEncoder": "aac",
+                            "AudioMixdown": "stereo",
+                            "AudioNormalizeMixLevel": false,
+                            "AudioSamplerate": "auto",
+                            "AudioTrackQualityEnable": false,
+                            "AudioTrackQuality": -1.0,
+                            "AudioTrackGainSlider": 0.0,
+                            "AudioTrackDRCSlider": 0.0
+                        }
+                    ],
+                    "AudioSecondaryEncoderMode": true,
+                    "AudioTrackSelectionBehavior": "first",
+                    "ChapterMarkers": true,
+                    "ChildrenArray": [
+                    ],
+                    "Default": false,
+                    "FileFormat": "mp4",
+                    "Folder": false,
+                    "FolderOpen": false,
+                    "InlineParameterSets": false,
+                    "Optimize": true,
+                    "Mp4iPodCompatible": false,
+                    "PictureCropMode": 0,
+                    "PictureBottomCrop": 0,
+                    "PictureLeftCrop": 0,
+                    "PictureRightCrop": 0,
+                    "PictureTopCrop": 0,
+                    "PictureDARWidth": 0,
+                    "PictureDeblockPreset": "off",
+                    "PictureDeblockTune": "medium",
+                    "PictureDeblockCustom": "strength=strong:thresh=20:blocksize=8",
+                    "PictureCombDetectCustom": "",
+                    "PictureCombDetectPreset": "off",
+                    "PictureDeinterlaceCustom": "",
+                    "PictureDeinterlaceFilter": "off",
+                    "PictureDeinterlacePreset": "default",
+                    "PictureDenoiseCustom": "",
+                    "PictureDenoiseFilter": "off",
+                    "PictureDenoisePreset": "medium",
+                    "PictureDenoiseTune": "none",
+                    "PictureChromaSmoothCustom": "",
+                    "PictureChromaSmoothPreset": "off",
+                    "PictureChromaSmoothTune": "none",
+                    "PictureColorspaceCustom": "",
+                    "PictureColorspacePreset": "off",
+                    "PictureSharpenCustom": "",
+                    "PictureSharpenFilter": "off",
+                    "PictureSharpenPreset": "medium",
+                    "PictureSharpenTune": "none",
+                    "PictureDetelecine": "off",
+                    "PictureDetelecineCustom": "",
+                    "PictureItuPAR": false,
+                    "PictureKeepRatio": true,
+                    "PictureModulus": 2,
+                    "PicturePAR": "auto",
+                    "PicturePARWidth": 853,
+                    "PicturePARHeight": 720,
+                    "PictureRotate": "angle=0:hflip=0",
+                    "PictureWidth": 960,
+                    "PictureHeight": 540,
+                    "PictureForceHeight": 0,
+                    "PictureForceWidth": 0,
+                    "PresetDescription": "Up to 1 minute of video in 10 MB or less, for sharing via online social communities such as Discord and email services such as Gmail. H.264 video (up to 540p60) and AAC stereo audio, in an MP4 container.",
+                    "PresetName": "Social 10 MB 1 Minute 540p60",
+                    "Type": 0,
+                    "UsesPictureFilters": true,
+                    "UsesPictureSettings": 1,
+                    "SubtitleAddCC": false,
+                    "SubtitleAddForeignAudioSearch": true,
+                    "SubtitleAddForeignAudioSubtitle": false,
+                    "SubtitleBurnBehavior": "foreign",
+                    "SubtitleBurnBDSub": true,
+                    "SubtitleBurnDVDSub": true,
+                    "SubtitleLanguageList": [
+                    ],
+                    "SubtitleTrackSelectionBehavior": "none",
+                    "VideoAvgBitrate": 1125,
+                    "VideoColorMatrixCodeOverride": 0,
+                    "VideoEncoder": "x264",
+                    "VideoFramerate": "60",
+                    "VideoFramerateMode": "pfr",
+                    "VideoGrayScale": false,
+                    "VideoScaler": "swscale",
+                    "VideoPreset": "slow",
+                    "VideoTune": "",
+                    "VideoProfile": "high",
+                    "VideoLevel": "3.2",
+                    "VideoOptionExtra": "qcomp=0.5:aq-mode=2:aq-strength=0.8:bframes=2:b-adapt=2:b-pyramid=0",
+                    "VideoQualityType": 1,
+                    "VideoQualitySlider": 27.0,
+                    "VideoQSVDecode": false,
+                    "VideoMultiPass": true,
+                    "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
+                    "x264Option": "",
+                    "x264UseAdvancedOptions": false
+                },
+                {
+                    "AlignAVStart": true,
+                    "AudioCopyMask": [
+                        "copy:aac"
+                    ],
+                    "AudioEncoderFallback": "aac",
+                    "AudioLanguageList": [
+                    ],
+                    "AudioList": [
+                        {
+                            "AudioBitrate": 160,
+                            "AudioCompressionLevel": -1.0,
+                            "AudioDitherMethod": "auto",
+                            "AudioEncoder": "aac",
+                            "AudioMixdown": "stereo",
+                            "AudioNormalizeMixLevel": false,
+                            "AudioSamplerate": "auto",
+                            "AudioTrackQualityEnable": false,
+                            "AudioTrackQuality": -1.0,
+                            "AudioTrackGainSlider": 0.0,
+                            "AudioTrackDRCSlider": 0.0
+                        }
+                    ],
+                    "AudioSecondaryEncoderMode": true,
+                    "AudioTrackSelectionBehavior": "first",
+                    "ChapterMarkers": true,
+                    "ChildrenArray": [
+                    ],
+                    "Default": false,
+                    "FileFormat": "mp4",
+                    "Folder": false,
+                    "FolderOpen": false,
+                    "InlineParameterSets": false,
+                    "Optimize": true,
+                    "Mp4iPodCompatible": false,
+                    "PictureCropMode": 0,
+                    "PictureBottomCrop": 0,
+                    "PictureLeftCrop": 0,
+                    "PictureRightCrop": 0,
+                    "PictureTopCrop": 0,
+                    "PictureDARWidth": 0,
+                    "PictureDeblockPreset": "off",
+                    "PictureDeblockTune": "medium",
+                    "PictureDeblockCustom": "strength=strong:thresh=20:blocksize=8",
+                    "PictureCombDetectCustom": "",
+                    "PictureCombDetectPreset": "off",
+                    "PictureDeinterlaceCustom": "",
+                    "PictureDeinterlaceFilter": "off",
+                    "PictureDeinterlacePreset": "default",
+                    "PictureDenoiseCustom": "",
+                    "PictureDenoiseFilter": "off",
+                    "PictureDenoisePreset": "medium",
+                    "PictureDenoiseTune": "none",
+                    "PictureChromaSmoothCustom": "",
+                    "PictureChromaSmoothPreset": "off",
+                    "PictureChromaSmoothTune": "none",
+                    "PictureColorspaceCustom": "",
+                    "PictureColorspacePreset": "off",
+                    "PictureSharpenCustom": "",
+                    "PictureSharpenFilter": "off",
+                    "PictureSharpenPreset": "medium",
+                    "PictureSharpenTune": "none",
+                    "PictureDetelecine": "off",
+                    "PictureDetelecineCustom": "",
+                    "PictureItuPAR": false,
+                    "PictureKeepRatio": true,
+                    "PictureModulus": 2,
+                    "PicturePAR": "auto",
+                    "PicturePARWidth": 853,
+                    "PicturePARHeight": 720,
+                    "PictureRotate": "angle=0:hflip=0",
+                    "PictureWidth": 640,
+                    "PictureHeight": 360,
+                    "PictureForceHeight": 0,
+                    "PictureForceWidth": 0,
+                    "PresetDescription": "Up to 2 minutes of video in 10 MB or less, for sharing via online social communities such as Discord and email services such as Gmail. H.264 video (up to 360p60) and AAC stereo audio, in an MP4 container.",
+                    "PresetName": "Social 10 MB 2 Minutes 360p60",
+                    "Type": 0,
+                    "UsesPictureFilters": true,
+                    "UsesPictureSettings": 1,
+                    "SubtitleAddCC": false,
+                    "SubtitleAddForeignAudioSearch": true,
+                    "SubtitleAddForeignAudioSubtitle": false,
+                    "SubtitleBurnBehavior": "foreign",
+                    "SubtitleBurnBDSub": true,
+                    "SubtitleBurnDVDSub": true,
+                    "SubtitleLanguageList": [
+                    ],
+                    "SubtitleTrackSelectionBehavior": "none",
+                    "VideoAvgBitrate": 500,
+                    "VideoColorMatrixCodeOverride": 0,
+                    "VideoEncoder": "x264",
+                    "VideoFramerate": "60",
+                    "VideoFramerateMode": "pfr",
+                    "VideoGrayScale": false,
+                    "VideoScaler": "swscale",
+                    "VideoPreset": "slow",
+                    "VideoTune": "",
+                    "VideoProfile": "high",
+                    "VideoLevel": "3.2",
+                    "VideoOptionExtra": "qcomp=0.5:aq-mode=2:aq-strength=0.8:bframes=2:b-adapt=2:b-pyramid=0",
+                    "VideoQualityType": 1,
+                    "VideoQualitySlider": 27.0,
+                    "VideoQSVDecode": false,
+                    "VideoMultiPass": true,
+                    "VideoTurboMultiPass": true,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 }
@@ -3797,6 +4159,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -3920,6 +4283,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -4029,6 +4393,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -4138,6 +4503,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -4247,6 +4613,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -4356,6 +4723,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -4465,6 +4833,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -4588,6 +4957,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -4711,6 +5081,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -4834,6 +5205,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -4957,6 +5329,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -5080,6 +5453,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -5203,6 +5577,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -5326,6 +5701,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -5449,6 +5825,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -5570,6 +5947,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -5693,6 +6071,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -5802,6 +6181,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -5911,6 +6291,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -6037,6 +6418,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -6160,6 +6542,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -6283,6 +6666,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -6392,6 +6776,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -6501,6 +6886,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -6624,6 +7010,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 }
@@ -6729,16 +7116,17 @@
                     "VideoFramerateMode": "pfr",
                     "VideoGrayScale": false,
                     "VideoScaler": "swscale",
-                    "VideoPreset": "8",
-                    "VideoTune": "",
+                    "VideoPreset": "7",
+                    "VideoTune": "vq",
                     "VideoProfile": "main",
                     "VideoLevel": "auto",
-                    "VideoOptionExtra": "",
+                    "VideoOptionExtra": "enable-variance-boost=1",
                     "VideoQualityType": 2,
                     "VideoQualitySlider": 30.0,
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -6848,6 +7236,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -6957,6 +7346,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -7066,6 +7456,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -7175,6 +7566,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -7284,6 +7676,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -7393,6 +7786,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -7502,6 +7896,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -7611,6 +8006,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -7720,6 +8116,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -7829,6 +8226,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -7937,6 +8335,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -8045,6 +8444,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -8153,6 +8553,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -8261,6 +8662,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -8369,6 +8771,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 }
@@ -8485,6 +8888,7 @@
                     "VideoQSVDecode": true,
                     "VideoMultiPass": false,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -8594,6 +8998,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": false,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -8703,6 +9108,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": false,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -8812,6 +9218,7 @@
                     "VideoQSVDecode": true,
                     "VideoMultiPass": false,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -8921,6 +9328,7 @@
                     "VideoQSVDecode": true,
                     "VideoMultiPass": false,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -9030,6 +9438,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": false,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -9139,6 +9548,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": false,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -9248,6 +9658,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": false,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -9357,6 +9768,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": false,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -9466,6 +9878,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": false,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -9575,6 +9988,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": false,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 }
@@ -9691,6 +10105,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -9800,6 +10215,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -9909,6 +10325,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -10018,6 +10435,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 },
@@ -10138,6 +10556,7 @@
                     "VideoQSVDecode": false,
                     "VideoMultiPass": true,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 }
diff -Naupr a/preset/preset_builtin.list b/preset/preset_builtin.list
--- a/preset/preset_builtin.list	2025-02-20 19:37:15.000000000 +0100
+++ b/preset/preset_builtin.list	2025-03-31 11:55:35.298883445 +0200
@@ -1,6 +1,6 @@
 <resources>
     <section name="PresetTemplate">
-        <integer name="VersionMajor" value="59" />
+        <integer name="VersionMajor" value="64" />
         <integer name="VersionMinor" value="0" />
         <integer name="VersionMicro" value="0" />
         <json name="Preset" file="preset_template.json" />
diff -Naupr a/preset/preset_cli_default.json b/preset/preset_cli_default.json
--- a/preset/preset_cli_default.json	2025-02-20 19:37:15.000000000 +0100
+++ b/preset/preset_cli_default.json	2025-03-31 11:55:35.298883445 +0200
@@ -113,6 +113,7 @@
                     "VideoHWDecode": 0,
                     "VideoMultiPass": false,
                     "VideoTurboMultiPass": false,
+                    "VideoPasshtruHDRDynamicMetadata": "all",
                     "x264Option": "",
                     "x264UseAdvancedOptions": false
                 }
diff -Naupr a/preset/preset_template.json b/preset/preset_template.json
--- a/preset/preset_template.json	2025-02-20 19:37:15.000000000 +0100
+++ b/preset/preset_template.json	2025-03-31 11:55:35.298883445 +0200
@@ -123,6 +123,7 @@
         "VideoHWDecode": 0,
         "VideoMultiPass": false,
         "VideoTurboMultiPass": false,
+        "VideoPasshtruHDRDynamicMetadata": "all",
         "x264Option": "",
         "x264UseAdvancedOptions": false
     }
diff -Naupr a/scripts/mac-toolchain-build b/scripts/mac-toolchain-build
--- a/scripts/mac-toolchain-build	2025-02-20 19:37:15.000000000 +0100
+++ b/scripts/mac-toolchain-build	2025-03-31 11:55:35.299883427 +0200
@@ -1,7 +1,7 @@
 #!/usr/bin/env bash
 # mac-toolchain-build - download and build common macOS toolchain components
 #
-# Copyright 2024 Bradley Sepos
+# Copyright 2025 Bradley Sepos
 # Released under the MIT License. See LICENSE for details.
 # https://github.com/bradleysepos/mac-toolchain-build
 
diff -Naupr a/scripts/mingw-w64-build b/scripts/mingw-w64-build
--- a/scripts/mingw-w64-build	2025-02-20 19:37:15.000000000 +0100
+++ b/scripts/mingw-w64-build	2025-03-31 11:55:35.299883427 +0200
@@ -1,7 +1,7 @@
 #!/usr/bin/env bash
 # mingw-w64-build - download and build mingw-w64 toolchain
 #
-# Copyright 2023 Bradley Sepos
+# Copyright 2025 Bradley Sepos
 # Released under the MIT License. See LICENSE for details.
 # https://github.com/bradleysepos/mingw-w64-build
 
diff -Naupr a/test/fr.handbrake.HandBrakeCLI.metainfo.xml.in.in b/test/fr.handbrake.HandBrakeCLI.metainfo.xml.in.in
--- a/test/fr.handbrake.HandBrakeCLI.metainfo.xml.in.in	2025-02-20 19:37:15.000000000 +0100
+++ b/test/fr.handbrake.HandBrakeCLI.metainfo.xml.in.in	2025-03-31 11:55:35.299883427 +0200
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<!-- Copyright 2018-2024 John Stebbins <your@email.com> -->
+<!-- Copyright 2018-2025 John Stebbins <your@email.com> -->
 <component type="console-application">
   <id>fr.handbrake.HandBrakeCLI</id>
   <update_contact>jstebbins.hb_AT_gmail.com</update_contact>
diff -Naupr a/test/module.defs b/test/module.defs
--- a/test/module.defs	2025-02-20 19:37:15.000000000 +0100
+++ b/test/module.defs	2025-03-31 11:55:35.299883427 +0200
@@ -16,7 +16,7 @@ TEST.GCC.L = $(CONTRIB.build/)lib
 
 TEST.libs = $(LIBHB.a)
 
-TEST.pkgconfig_libs = libass libavformat libavfilter libavcodec libavutil libswresample dvdnav \
+TEST.pkgconfig_libs = libass libavformat libavfilter libavcodec libavutil libswresample libcpuinfo dvdnav \
 	dvdread libswscale theoraenc theoradec vorbis vorbisenc ogg x264 libbluray \
 	jansson libturbojpeg SvtAv1Enc
 
@@ -54,7 +54,7 @@ endif
 TEST.GCC.I += $(LIBHB.GCC.I)
 
 ifeq ($(HOST.system),darwin)
-    TEST.GCC.f += IOKit CoreServices CoreText CoreGraphics AudioToolbox VideoToolbox CoreMedia CoreVideo Foundation DiskArbitration Metal
+    TEST.GCC.f += IOKit CoreServices CoreText CoreGraphics AudioToolbox VideoToolbox CoreMedia CoreVideo IOSurface Foundation DiskArbitration Metal
     TEST.GCC.l += iconv
 else ifeq ($(HOST.system),linux)
     TEST.GCC.l += pthread dl m
diff -Naupr a/test/parsecsv.c b/test/parsecsv.c
--- a/test/parsecsv.c	2025-02-20 19:37:15.000000000 +0100
+++ b/test/parsecsv.c	2025-03-31 11:55:35.299883427 +0200
@@ -1,6 +1,6 @@
 /* parsecsv.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/test/parsecsv.h b/test/parsecsv.h
--- a/test/parsecsv.h	2025-02-20 19:37:15.000000000 +0100
+++ b/test/parsecsv.h	2025-03-31 11:55:35.299883427 +0200
@@ -1,6 +1,6 @@
 /* parsecsv.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
diff -Naupr a/test/test.c b/test/test.c
--- a/test/test.c	2025-02-20 19:37:15.000000000 +0100
+++ b/test/test.c	2025-03-31 11:55:35.300883410 +0200
@@ -1,6 +1,6 @@
 /* test.c
 
-   Copyright (c) 2003-2024 HandBrake Team
+   Copyright (c) 2003-2025 HandBrake Team
    This file is part of the HandBrake source code
    Homepage: <http://handbrake.fr/>.
    It may be used under the terms of the GNU General Public License v2.
@@ -59,6 +59,7 @@
 #define ROTATE_DEFAULT               "angle=180:hflip=0"
 #define DEBLOCK_DEFAULT_PRESET       "medium"
 #define COLORSPACE_DEFAULT_PRESET    "bt709"
+#define HDR_DYNAMIC_METADATA_DEFAULT_PRESET "all"
 
 /* Options */
 static int     debug               = HB_DEBUG_ALL;
@@ -211,6 +212,9 @@ static int      qsv_decode         = -1;
 #endif
 static int      hw_decode          = -1;
 static int      keep_duplicate_titles = 0;
+static int      hdr_dynamic_metadata_disable = 0;
+static char *   hdr_dynamic_metadata  = NULL;
+static int      metadata_passthru = -1;
 
 /* Exit cleanly on Ctrl-C */
 static volatile hb_error_code done_error = HB_ERROR_NONE;
@@ -1406,6 +1410,10 @@ static void ShowHelp(void)
 "       --align-av          Add audio silence or black video frames to start\n"
 "                           of streams so that all streams start at exactly\n"
 "                           the same time\n"
+"   --keep-metadata         Preserve the source's common metadata\n"
+"   --no-metadata           Disable preset 'keep-metadata'\n"
+"                           of streams so that all streams start at exactly\n"
+"                           the same time\n"
 "   --inline-parameter-sets Create adaptive streaming compatible output.\n"
 "                           Inserts parameter sets (SPS and PPS) inline\n"
 "                           in the video stream before each IDR.\n"
@@ -1497,11 +1505,18 @@ static void ShowHelp(void)
 "                           timing if it's below that rate.\n"
 "                           If none of these flags are given, the default\n"
 "                           is --pfr when -r is given and --vfr otherwise\n"
+"   --hdr-dynamic-metadata  <string>\n"
+"                           Set the kind of HDR dynamic metadata to preserve:\n"
+"                               hdr10plus\n"
+"                               dolbyvision\n"
+"                               all\n"
+"   --no-hdr-dynamic-metadata Disable HDR dynamic metadata passthru\n"
 "   --enable-hw-decoding <string>                                        \n"
 #if defined( __APPLE_CC__ )
 "                           Use 'videotoolbox' to enable VideoToolbox    \n"
 #else
 "                           Use 'nvdec' to enable NVDec                  \n"
+"                           Use 'qsv' to enable QSV decoding             \n"
 #endif
 "   --disable-hw-decoding   Disable hardware decoding of the video track,\n"
 "                           forcing software decoding instead\n"
@@ -2234,8 +2249,9 @@ static int ParseOptions( int argc, char
     #define CROP_MODE                     330
     #define HW_DECODE                     331
     #define KEEP_DUPLICATE_TITLES         332
-    #define MAX_DURATION         333
-    
+    #define MAX_DURATION                  333
+    #define HDR_DYNAMIC_METADATA          334
+
     for( ;; )
     {
         static struct option long_options[] =
@@ -2254,9 +2270,13 @@ static int ParseOptions( int argc, char
             { "enable-qsv-decoding",  no_argument,       &qsv_decode, 1,                  },
 #endif
             { "disable-hw-decoding", no_argument,        &hw_decode,  0, },
-            { "enable-hw-decoding",  required_argument,  NULL,  HW_DECODE, },
+            { "enable-hw-decoding",  required_argument,  NULL, HW_DECODE, },
+
             { "keep-duplicate-titles", no_argument,      NULL, KEEP_DUPLICATE_TITLES },
 
+            { "no-hdr-dynamic-metadata",  no_argument,       &hdr_dynamic_metadata_disable, 1 },
+            { "hdr-dynamic-metadata",     required_argument, NULL, HDR_DYNAMIC_METADATA },
+
             { "format",      required_argument, NULL,    'f' },
             { "input",       required_argument, NULL,    'i' },
             { "output",      required_argument, NULL,    'o' },
@@ -2278,6 +2298,8 @@ static int ParseOptions( int argc, char
             { "no-inline-parameter-sets", no_argument, &inline_parameter_sets, 0 },
             { "align-av",    no_argument,       &align_av_start, 1 },
             { "no-align-av", no_argument,       &align_av_start, 0 },
+            { "keep-metadata", no_argument,     &metadata_passthru, 1 },
+            { "no-metadata",   no_argument,     &metadata_passthru, 0 },
             { "audio-lang-list", required_argument, NULL, AUDIO_LANG_LIST },
             { "all-audio",   no_argument,       &audio_all, 1 },
             { "first-audio", no_argument,       &audio_all, 0 },
@@ -3225,6 +3247,13 @@ static int ParseOptions( int argc, char
                         }
 #endif
                     }
+#if HB_PROJECT_FEATURE_QSV
+                    else if (!strcmp(optarg, "qsv"))
+                    {
+                        qsv_decode = 1;
+                        hw_decode = HB_DECODE_SUPPORT_QSV;
+                    }
+#endif
                     else if (!strcmp(optarg, "mf"))
                     {
                         hw_decode = HB_DECODE_SUPPORT_MF;
@@ -3237,6 +3266,17 @@ static int ParseOptions( int argc, char
             case KEEP_DUPLICATE_TITLES:
                 keep_duplicate_titles = 1;
                 break;
+            case HDR_DYNAMIC_METADATA:
+                free(hdr_dynamic_metadata);
+                if (optarg != NULL)
+                {
+                    hdr_dynamic_metadata = strdup(optarg);
+                }
+                else
+                {
+                    hdr_dynamic_metadata = strdup(HDR_DYNAMIC_METADATA_DEFAULT_PRESET);
+                }
+                break;
             case ':':
                 fprintf( stderr, "missing parameter (%s)\n", argv[cur_optind] );
                 return -1;
@@ -3574,6 +3614,16 @@ static int ParseOptions( int argc, char
         }
     }
 
+    if (hdr_dynamic_metadata != NULL)
+    {
+        if (hdr_dynamic_metadata_disable)
+        {
+            fprintf(stderr,
+                    "Incompatible options --hdr-dynamic-metadata and --no-hdr-dynamic-metadata\n");
+            return -1;
+        }
+    }
+
     return 0;
 }
 
@@ -3777,6 +3827,10 @@ static hb_dict_t * PreparePreset(const c
     {
         hb_dict_set(preset, "AlignAVStart", hb_value_bool(align_av_start));
     }
+    if (metadata_passthru != -1)
+    {
+        hb_dict_set(preset, "MetadataPassthru", hb_value_bool(metadata_passthru));
+    }
     if (inline_parameter_sets != -1)
     {
         hb_dict_set(preset, "InlineParameterSets",
@@ -4374,12 +4428,21 @@ static hb_dict_t * PreparePreset(const c
     if (qsv_decode != -1)
     {
         hb_dict_set(preset, "VideoQSVDecode", hb_value_int(qsv_decode));
+        hw_decode = qsv_decode ? HB_DECODE_SUPPORT_QSV : 0;
     }
 #endif
     if (hw_decode != -1)
     {
         hb_dict_set(preset, "VideoHWDecode", hb_value_int(hw_decode));
     }
+    if (hdr_dynamic_metadata_disable)
+    {
+        hb_dict_set(preset, "VideoPasshtruHDRDynamicMetadata", hb_value_string("off"));
+    }
+    if (hdr_dynamic_metadata != NULL)
+    {
+        hb_dict_set(preset, "VideoPasshtruHDRDynamicMetadata", hb_value_string(hdr_dynamic_metadata));
+    }
     if (maxWidth > 0)
     {
         hb_dict_set(preset, "PictureWidth", hb_value_int(maxWidth));
@@ -4957,6 +5020,15 @@ PrepareJob(hb_handle_t *h, hb_title_t *t
                     hb_value_int(range_seek_points));
     }
 
+    if (hb_value_get_bool(hb_dict_get(preset_dict, "MetadataPassthru")) == 0)
+    {
+        hb_dict_t *metadata_dict = hb_dict_get(job_dict, "Metadata");
+        hb_dict_clear(metadata_dict);
+
+        hb_dict_t *arts_array = hb_dict_get(job_dict, "CoverArts");
+        hb_value_array_clear(arts_array);
+    }
+
     hb_dict_t *source_dict = hb_dict_get(job_dict, "Source");
 
     if (angle)
